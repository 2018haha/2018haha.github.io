<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>历史</title>
      <link href="/%E4%BC%9A%E8%80%83%E5%8E%86%E5%8F%B2/"/>
      <url>/%E4%BC%9A%E8%80%83%E5%8E%86%E5%8F%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="会考历史"><a href="#会考历史" class="headerlink" title="会考历史"></a>会考历史</h1><p>——partychicken，zf</p><h2 id="必修一"><a href="#必修一" class="headerlink" title="必修一"></a>必修一</h2><h3 id="第一单元-中国古代的中央集权制度"><a href="#第一单元-中国古代的中央集权制度" class="headerlink" title="第一单元 中国古代的中央集权制度"></a>第一单元 中国古代的中央集权制度</h3><h4 id="夏"><a href="#夏" class="headerlink" title="夏"></a>夏</h4><ul><li>禅让-&gt;世袭</li></ul><h4 id="商"><a href="#商" class="headerlink" title="商"></a>商</h4><ul><li>内外服制度</li><li>占卜和祭祀</li><li>神权和王权紧密结合</li></ul><h4 id="周"><a href="#周" class="headerlink" title="周"></a>周</h4><ul><li>分封制</li><li>宗法制<ul><li>核心：嫡长子继承制</li><li>大宗与小宗</li></ul></li><li>礼乐制：维护宗法制和分封制的工具</li></ul><h4 id="秦"><a href="#秦" class="headerlink" title="秦"></a>秦</h4><h4 id="中央官制"><a href="#中央官制" class="headerlink" title="中央官制"></a>中央官制</h4><ul><li>秦：三公九卿制</li><li>隋唐：三省六部制<ul><li>三省：<ul><li>中书：决策</li><li>尚书：执行</li><li>门下：审议</li></ul></li><li>六部：吏、户、礼、兵、刑、工</li></ul></li><li>宋：二府三司制</li><li>元：中书一省制</li><li>明：废丞相，设立内阁</li><li>清：设立内阁、军机处</li></ul><h4 id="地方行政体制"><a href="#地方行政体制" class="headerlink" title="地方行政体制"></a>地方行政体制</h4><ul><li>秦：郡县制</li><li>汉初：郡国并行制</li><li>元：行省制</li></ul><h4 id="选官制度"><a href="#选官制度" class="headerlink" title="选官制度"></a>选官制度</h4><ul><li>西周：世卿世禄制</li><li>战国、秦、西汉初：军功爵制</li><li>汉武帝时期：察举制（推荐）、征辟制（征聘）</li><li>魏晋南北朝：九品中正制</li><li>隋唐至明清：科举制</li></ul><h4 id="监察制度"><a href="#监察制度" class="headerlink" title="监察制度"></a>监察制度</h4><ul><li>秦：御史大夫</li><li>汉武帝：刺史</li><li>宋朝：通判</li><li>明清：达到顶峰。监察御史，六科给事中（中央），按察使司（地方）</li></ul><h3 id="第二单元-古希腊和古罗马的政治制度"><a href="#第二单元-古希腊和古罗马的政治制度" class="headerlink" title="第二单元 古希腊和古罗马的政治制度"></a>第二单元 古希腊和古罗马的政治制度</h3><h4 id="古希腊"><a href="#古希腊" class="headerlink" title="古希腊"></a>古希腊</h4><ul><li>城邦特点：小国寡民</li><li>民主政治特点：人民主权，轮番而治</li><li>公民条件<ul><li>祖籍本邦</li><li>成年男性</li></ul></li><li>民主进程<ul><li>1.梭伦改革——将雅典引上民主轨道</li><li>2.克利斯提尼改革——雅典民主制度确立 <ul><li>陶片放逐法</li></ul></li><li>3.伯利克里改革——雅典民主制度黄金时期 </li></ul></li></ul><h4 id="古罗马"><a href="#古罗马" class="headerlink" title="古罗马"></a>古罗马</h4><ul><li>习惯法</li><li>成文法<ul><li>古罗马第一部成文法：《十二铜表法》</li><li>罗马法发展完备：《查士丁尼民法大全》</li></ul></li><li>罗马法影响：<ul><li>对罗马的影响<ul><li>有利于协调社会矛盾 </li><li>巩固帝国统治 </li></ul></li><li>对世界的影响： <ul><li>为近代资本主义国家立法提供规范</li><li>罗马法一些规则沿用至今 </li></ul></li></ul></li></ul><h3 id="第三单元-近代西方资本主义政体的建立"><a href="#第三单元-近代西方资本主义政体的建立" class="headerlink" title="第三单元 近代西方资本主义政体的建立"></a>第三单元 近代西方资本主义政体的建立</h3><h4 id="英国"><a href="#英国" class="headerlink" title="英国"></a>英国</h4><ul><li>政体：君主立宪制</li><li>行政制度：议会制</li><li>政体确立途径：光荣革命、《权利法案》</li><li>以责任内阁制为核心，国王统而不治</li></ul><h4 id="美国"><a href="#美国" class="headerlink" title="美国"></a>美国</h4><ul><li>政体：民主共和制</li><li>行政制度：总统制</li><li>国家结构：联邦制</li><li>文件：《1787年宪法》<ul><li>三权分立原则：<ul><li>国会：立法</li><li>参议院，众议院：行政</li><li>最高法院：司法</li></ul></li><li>人民主权原则：总统、议会由民选产生</li><li>是近代世界第一部成文宪法</li></ul></li></ul><h4 id="法国"><a href="#法国" class="headerlink" title="法国"></a>法国</h4><ul><li>政体：民主共和制</li><li>行政制度：议会制</li><li>文件：《法兰西第三共和国宪法》（《1875年宪法》）<ul><li>行政权归内阁，总统</li><li>内阁对议会负责</li></ul></li></ul><h4 id="德国"><a href="#德国" class="headerlink" title="德国"></a>德国</h4><ul><li>政体：君主立宪制</li><li>文件：《德意志帝国宪法》</li><li>浓厚的帝国主义和专制主义色彩</li></ul><table><thead><tr><th>项目</th><th>美国</th><th>英国</th><th>德国</th><th>法国</th></tr></thead><tbody><tr><td>国家元首</td><td>总统</td><td>国王</td><td>国王</td><td>总统</td></tr><tr><td>国家元首产生方式</td><td>民选，有任期</td><td>世袭，终身制</td><td>世袭、终身制</td><td>议会选举、有任期</td></tr><tr><td>国家元首有无实权</td><td>有</td><td>无</td><td>有</td><td>有</td></tr><tr><td>政府首脑</td><td>总统</td><td>首相</td><td>首相</td><td>总统</td></tr><tr><td>政府产生方式</td><td>总统任命</td><td>议会产生</td><td>皇帝任命</td><td>议会产生</td></tr><tr><td>政府与议会关系</td><td>总统不对国会负责</td><td>内阁、首相对议会负责</td><td>政府不对议会负责</td><td>对议会负责</td></tr><tr><td>国家权力中心</td><td>总统</td><td>议会</td><td>皇帝</td><td>议会</td></tr></tbody></table><h3 id="第四单元-内忧外患与中华民族的奋起"><a href="#第四单元-内忧外患与中华民族的奋起" class="headerlink" title="第四单元 内忧外患与中华民族的奋起"></a>第四单元 内忧外患与中华民族的奋起</h3><h4 id="中国沦为半殖民地半封建化社会的过程"><a href="#中国沦为半殖民地半封建化社会的过程" class="headerlink" title="中国沦为半殖民地半封建化社会的过程"></a>中国沦为半殖民地半封建化社会的过程</h4><table><thead><tr><th>时间</th><th>战争</th><th>条约</th><th>事迹</th><th>内容</th><th>影响</th></tr></thead><tbody><tr><td>1840-1842</td><td>鸦片战争</td><td>《南京条约》</td><td></td><td>为开放五口通商：广州、福州、厦门、宁波、上海（广夏福宁上）</td><td>主权和领土完整被破坏，中国开始沦为半殖民地半封建化社会</td></tr><tr><td>1856-1860</td><td>第二次鸦片战争</td><td>《天津条约》 《北京条约》</td><td></td><td></td><td>开始认识到学习西方的重要性，中国半殖民地半封建化程度加深</td></tr><tr><td>1894-1895</td><td>甲午中日战争</td><td>《马关条约》</td><td>丁汝昌、邓世昌、刘永福</td><td>割让台湾，开放重庆、日本在华设厂</td><td>中国半殖民地半封建化程度大大加深</td></tr><tr><td>1900-1901</td><td>八国联军侵华</td><td>《辛丑条约》</td><td></td><td>允许外国驻兵保护</td><td>中国彻底沦为半殖民地半封建社会</td></tr></tbody></table><h4 id="太平天国运动"><a href="#太平天国运动" class="headerlink" title="太平天国运动"></a>太平天国运动</h4><ul><li>1851：洪秀全金田起义 </li><li>1853：定都南京，改名天京，《天朝田亩制度》</li><li>1856：天京事变，严重内讧</li><li>1859：洪仁玕《资政新篇》 （第一部有资本主义性质的施政方案）</li><li>1864：天京陷落 </li></ul><h4 id="辛亥革命"><a href="#辛亥革命" class="headerlink" title="辛亥革命"></a>辛亥革命</h4><ul><li><p>1905：同盟会成立，孙中山</p></li><li><p>“驱除鞑虏，恢复中华<code>民族主义</code>，创立民国<code>民权主义</code>，平均地权<code>民生主义</code>“</p></li><li><p>1911：武昌首义</p></li><li><p>1912《中华民国临时约法》</p><ul><li>第一部具有资产阶级共和国宪法性质的国家临时大法 </li></ul></li></ul><h4 id="五四运动"><a href="#五四运动" class="headerlink" title="五四运动"></a>五四运动</h4><ul><li>口号：“废除二十一条”、“外争国权，内惩国贼”等 </li><li>中国无产阶级力量登上历史舞台</li><li>中国拒绝在《凡尔赛和约》上签字 </li></ul><h3 id="第五单元-马克思主义的产生，发展和中国新民主主义革命"><a href="#第五单元-马克思主义的产生，发展和中国新民主主义革命" class="headerlink" title="第五单元 马克思主义的产生，发展和中国新民主主义革命"></a>第五单元 马克思主义的产生，发展和中国新民主主义革命</h3><h4 id="马克思主义的诞生（1848）"><a href="#马克思主义的诞生（1848）" class="headerlink" title="马克思主义的诞生（1848）"></a>马克思主义的诞生（1848）</h4><ul><li>《共产党宣言》发表</li><li>巴黎公社<ul><li>第一个工人政权</li><li>标志着社会主义由理论变为实践</li></ul></li></ul><h4 id="俄国十月革命"><a href="#俄国十月革命" class="headerlink" title="俄国十月革命"></a>俄国十月革命</h4><ul><li>1917：二月革命，资产阶级建立起临时政府</li><li>1917：列宁《四月提纲》，要实现社会主义革命</li><li>1917.7：七月流血事件（武力镇压革命力量）</li><li>1917.11：推翻临时政府</li><li>第一个社会主义国家<ul><li>政体：苏维埃社会主义共和政体</li><li>措施：<ul><li>《和平法令》宣布退出帝国主义战争</li><li>《土地法令》把土地分给劳动者使用</li></ul></li></ul></li><li>十月革命意义<ul><li>第一次获得胜利的社会主义革命</li><li>社会主义由理论变为现实</li><li>使俄国摆脱封建残余束缚和剥削阶级通知</li></ul></li></ul><h4 id="中国新民主主义革命"><a href="#中国新民主主义革命" class="headerlink" title="中国新民主主义革命"></a>中国新民主主义革命</h4><ul><li>1921 中共一大<ul><li>确立党的名称</li><li>党的奋斗目标：推翻资产阶级，建立无产阶级专政，废除私有制</li></ul></li><li>1922 中共二大<ul><li>更改目标：反对帝国主义、封建主义、军阀，建立民主共和国</li></ul></li><li>1923 中共三大<ul><li>寻求合作</li></ul></li><li>1924.1 国民党一大<ul><li>国共第一次合作形成。</li></ul></li><li>1925-1927 国民革命</li><li>1927-1937 国共十年对峙<ul><li>1927：八七会议，土地革命：废除封建剥削</li><li>1927：秋收起义，创建井冈山革命根据地，以农村包围城市，最后夺取全国政权</li></ul></li><li>1931-1945 抗日战争<ul><li>1931：九一八事变</li><li>1937：卢沟桥事变</li><li>百团大战：1940年，彭德怀</li><li>太平洋战争:1941年，敌后战场成为主要战场</li><li>胜利意义<ul><li>国际意义<ul><li>中国抗战是世界反法西斯战争的重要组成部分</li><li>时间最长，抗击日本兵力最多</li></ul></li><li>国内意义<ul><li>第一次取得反对帝国主义侵略的完全胜利</li><li>为民主革命胜利奠定基础</li></ul></li></ul></li></ul></li><li>1946-1949 解放战争<ul><li>1948-1949 三大战役：辽沈、淮海、平津</li><li>1949：渡江战役</li></ul></li><li>红军长征<ul><li>时间：1934-1936</li><li>1935.1 遵义会议<ul><li>确立毛泽东领导地位</li><li>扭转长期被动挨打局面</li></ul></li><li>1935 《八一宣言》<ul><li>建立抗日民族统一战线的主张</li></ul></li><li>1936.10 在甘肃会宁会师</li></ul></li><li>西安事变：1936年</li><li>重庆谈判：1945年，国共双方达成《双十协定》</li></ul><h3 id="第六单元-中国社会主义的政治建设与祖国统一"><a href="#第六单元-中国社会主义的政治建设与祖国统一" class="headerlink" title="第六单元 中国社会主义的政治建设与祖国统一"></a>第六单元 中国社会主义的政治建设与祖国统一</h3><h4 id="新中国的政治建设"><a href="#新中国的政治建设" class="headerlink" title="新中国的政治建设"></a>新中国的政治建设</h4><ul><li>开国大典<ul><li>第一次政治协商会议：1949.9</li><li>时间：1949.10.1</li></ul></li><li>1954年宪法<ul><li>中国第一部社会主义类型宪法</li></ul></li><li>人民代表大会制度<ul><li>确立标志：1954年宪法</li><li>曲折<ul><li>1957右派斗争扩大，建设停顿</li><li>文革期间，名存实亡</li></ul></li></ul></li><li>多党合作和政治协商制度<ul><li>指导思想：长期共存，互相监督</li><li>合作形式：政治协商</li><li>1982年提出：长期共存，互相监督，肝胆相照，荣辱与共</li></ul></li><li>民族区域自治制度</li></ul><h4 id="社会主义政治建设的曲折发展"><a href="#社会主义政治建设的曲折发展" class="headerlink" title="社会主义政治建设的曲折发展"></a>社会主义政治建设的曲折发展</h4><ul><li>文化大革命<ul><li>时间：1966-1976</li></ul></li><li>第十一届三中全会<ul><li>转折：胡耀邦主持，平反冤假错案</li><li>颁布1982年宪法，法律体系较完备</li><li>依法治国<ul><li>十五大确立为改革重点</li><li>1999写入宪法，标志中国进入建设法治化社会新时期</li></ul></li></ul></li></ul><h4 id="祖国统一的历史潮流"><a href="#祖国统一的历史潮流" class="headerlink" title="祖国统一的历史潮流"></a>祖国统一的历史潮流</h4><ul><li>一国两制<ul><li>提出：邓小平，针对台湾问题</li><li>香港：1997.7.1回归</li><li>澳门：1999.12.20回归</li></ul></li><li>台湾问题<ul><li>1979：《告台湾同胞书》和平统一</li><li>1992：九二共识，海峡两岸均坚持一个中国原则</li><li>1995：江泽民，八项主张</li><li>2005：《反分裂国家法》促进祖国和平统一</li></ul></li></ul><h3 id="第七单元-复杂多样的当代世界"><a href="#第七单元-复杂多样的当代世界" class="headerlink" title="第七单元 复杂多样的当代世界"></a>第七单元 复杂多样的当代世界</h3><h4 id="两极格局"><a href="#两极格局" class="headerlink" title="两极格局"></a>两极格局</h4><ul><li>政治上，1947杜鲁门主义<ul><li>标志着冷战开始</li><li>对抗：共产党和工人党情报局反击</li></ul></li><li>经济上，1947马歇尔计划<ul><li>对杜鲁门主义的大规模应用</li><li>对抗：经济互助委员会反击</li></ul></li><li>军事上，1949《北大西洋公约》，北约<ul><li>对抗：《华沙条约》，华约，标志着两极格局形成</li></ul></li><li>热战<ul><li>朝鲜战争（1950-1953）：中美关系破裂</li><li>越南战争（1961-1973）：苏联军事实力大体赶上美国</li></ul></li></ul><h4 id="世界政治格局多极化趋势"><a href="#世界政治格局多极化趋势" class="headerlink" title="世界政治格局多极化趋势"></a>世界政治格局多极化趋势</h4><ul><li>欧共体<ul><li>1951：欧洲煤钢共同体</li><li>1958：欧洲经济共同体、欧洲原子能共同体</li><li>1967：合并成欧洲共同体</li></ul></li><li>日本：成为资本主义世界第二经济大国</li><li>不结盟运动<ul><li>1961：第一次不结盟国家和政府首脑会议，标志不结盟运动诞生</li><li>不结盟运动标志着第三世界国家以独立的力量登上了国际政治舞台</li></ul></li></ul><h4 id="新中国外交"><a href="#新中国外交" class="headerlink" title="新中国外交"></a>新中国外交</h4><ul><li>外交政策：<ul><li>建国初期<ul><li>方针：独立自主的和平外交方针</li><li>“一边倒”，“另起炉灶”，“打扫干净屋子再请客”</li></ul></li><li>改革开放以来<ul><li>原则：平等互利，形式多样，讲求实效，共同发展</li></ul></li></ul></li><li>1950：中苏签订《中苏友好同盟互助条约》</li><li>1953：和平共处五项原则<ul><li>周恩来接见印度代表团时提出</li><li>标志中国外交政策的成熟，成为解决国与国问题的准则</li></ul></li><li>1954：参加日内瓦会议</li><li>1955：参加亚非会议，并提出“求同存异”</li><li>1971：第26届联大，中国在联合国的一切合法权利得到恢复</li><li>1972：尼克松访华，《中美上海公报》</li><li>1972：《中日联合声明》，中日关系正常化</li><li>1978：《中美建交联合公报》</li><li>1979：中美正式建交</li><li>2001：上海合作组织，促进地区和平与稳定</li></ul><h2 id="必修二"><a href="#必修二" class="headerlink" title="必修二"></a>必修二</h2>]]></content>
      
      
      <categories>
          
          <category> 文化课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文化课 </tag>
            
            <tag> 历史 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>各种Tarjan算法详解</title>
      <link href="/tarjan/"/>
      <url>/tarjan/</url>
      
        <content type="html"><![CDATA[<ul><li>注意：本文对强连通分量的介绍已经完成，而其他部分尚未完成。</li></ul><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>$\text{Tarjan}​$算法是图论中实用/常用的算法之一，能解决强连通分量，双连通分量，割点和桥，求$\text{LCA}​$等问题，本文将对以上用途一一介绍</p><h1 id="强连通分量"><a href="#强连通分量" class="headerlink" title="强连通分量"></a>强连通分量</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>一个强连通分量是指一个<strong>有向图</strong>中的最大强联通子图。</p><ul><li>强联通子图：任意两点可以互相到达的有向图。</li></ul><p>如下图，就有3个强联通分量：{1,2,3}，{4}，{5}。</p><h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h2><h3 id="（一）如何找强联通分量。"><a href="#（一）如何找强联通分量。" class="headerlink" title="（一）如何找强联通分量。"></a>（一）如何找强联通分量。</h3><p>进行$\text{Dfs}​$遍历，在$\text{Dfs}​$树上操作。如果在$\text{Dfs}​$时发现遍历到了一个访问过的的点（如下图的$1​$号节点），那么说明从这个点出发，可以回到自己，即这条路径构成了一个<strong>环</strong>，环上的点是强联通的。</p><p>但根据强联通分量的定义，这只能说明他们在同一个强联通分量内，不能保证他们就是一个强连通分量，还要接着处理。</p><h3 id="（二）找完整的强联通分量。"><a href="#（二）找完整的强联通分量。" class="headerlink" title="（二）找完整的强联通分量。"></a>（二）找完整的强联通分量。</h3><p>考虑什么情况下才能保证上述的环构成一个强连通分量。上述的环都是由一个节点$S$和它在Dfs树中的子树构成的，那么只要保证子树内没有节点连向$S$的祖先，即可保证这是一个强连通分量。</p><p>原因比较好理解：若该点子树中有点连向了他的祖先，那么他的祖先便属于这个强连通分量，显然可以构成一个<strong>更大的强联通图</strong>。</p><p>可以参见下图辅助理解。图中$2​$号节点的子树中，$4​$号节点连向了$2​$的父亲——$1​$号点，那么环{2,3,4}就属于强联通分量{1,2,3,4}，而不能单独构成强联通分量。</p><h3 id="（三）找准确的强连通分量。"><a href="#（三）找准确的强连通分量。" class="headerlink" title="（三）找准确的强连通分量。"></a>（三）找准确的强连通分量。</h3><p>以上的算法貌似还有一个问题：我们能通过第二条<code>（二）找完整的强联通分量</code>。找到强联通分量所在的子树，但是我们并不知道子树中哪些节点属于，哪些节点不属于。</p><p><strong>解决办法：</strong></p><p>就像$\text{Dfs}$找环一样，用一个栈记录即可。</p><p>$u​$之后的所有点在u被回溯到时$u​$和栈中所有在它之后的点都构成强连通分量。<br>具体见代码实现。</p><p><del>然后各位神仙们就可以脑补代码实现了，本次就到这里，感谢阅读！</del></p><h2 id="程序实现"><a href="#程序实现" class="headerlink" title="程序实现"></a>程序实现</h2><h3 id="定义一些数组："><a href="#定义一些数组：" class="headerlink" title="定义一些数组："></a>定义一些数组：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dfn[N];<span class="comment">//表示在Dfs时是第几个被搜到的</span></span><br><span class="line"><span class="keyword">int</span> low[N];<span class="comment">//表示这个点的子树节点及他们连向的点的最小$dfn$值。为了实现上面的第二步</span></span><br><span class="line"><span class="keyword">int</span> sta[N&#125;;<span class="comment">//</span></span><br><span class="line"><span class="keyword">int</span> vis[N];<span class="comment">//记录点是否在栈中</span></span><br></pre></td></tr></table></figure><h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><p>1.最外层框架是对树的$\text{Dfs}$。</p><p>2.每遍历到一个节点$u​$:</p><p>(1)初始化<code>dfn[u]=low[u]=++cnt</code>(cnt是计数器）。</p><p>根据数组含义可以理解，在处理前，子树中<code>dfn</code>最小的就是<code>dfn[u]</code>,所以把<code>low[u]</code>初始化为<code>dfn[u]</code></p><p>(2)把$u$入栈，标记<code>vis[u]=1</code></p><p>(3)接着遍历它所能到达的节点$v$，判断$v$是否访问过（方法：看dfn值是否等于0）。</p><p>a.未访问过：接着递归<code>Dfs(v)</code>，并用$v$的$low$值更新$u$:<br><code>low[u]=min(low[u],low[v])</code><br>因为子树中的节点可能连向$u$的祖先节点，所以按照$dfn$的含义更新它。</p><p>b.访问过：</p><p>如果$v$在栈中，说明$u$,$v$在一个强连通分量，那么更新<code>low[u]</code>:<code>low[u]=min(low[u],low[v])</code></p><p>如果不在栈中，说明$u$不能到达$v$,二者没有关联，不进行处理。</p><p>(4) 处理完$u$的子树后：</p><p>此时<code>dfn[u]</code>和<code>low[u]</code>都已经确定好。若<code>dfn[u]==low[u]</code>，根据数组含义，表明$u$是子树中所有点能到达的dfn最小的点，这也就满足了上文中的<code>（二）找完整的强联通分量。</code>（还记得吗），即满足了：<strong>u点与它的子孙节点构成了一个最大的强连通图,即强连通分量</strong>。</p><p>这时我们只需把栈中$u$后面的点和$u$一并弹出（别忘更新$\text{vis}$），弹出的这些点就是一个强连通分量了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="Tarjan"><a href="#Tarjan" class="headerlink" title="Tarjan"></a>Tarjan</h4><p>建议参照上文对比阅读代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dfn[N],low[N],t;<span class="comment">//数组定义同上面的解释</span></span><br><span class="line"><span class="keyword">int</span> sta[N],top;</span><br><span class="line"><span class="keyword">int</span> vis[N];</span><br><span class="line"><span class="keyword">int</span> col[N],tot;<span class="comment">//用于标记答案，col相同的点在一个强连通分量中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">low[u]=dfn[u]=++t;</span><br><span class="line">sta[++top]=u;</span><br><span class="line">vis[u]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=next[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=to[i];</span><br><span class="line"><span class="keyword">if</span>(!dfn[v])</span><br><span class="line">&#123;</span><br><span class="line">Tarjan(v);</span><br><span class="line">low[u]=min(low[u],low[v]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(vis[v])</span><br><span class="line">low[u]=min(low[u],dfn[v]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dfn[u]==low[u])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v;</span><br><span class="line">tot++;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">v=sta[top];</span><br><span class="line">top--;</span><br><span class="line">vis[v]=<span class="number">0</span>;</span><br><span class="line">col[v]=tot;</span><br><span class="line">&#125;<span class="keyword">while</span>(u!=v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h4><p><strong>注意：</strong>由于图可能不连通，从一个点开始Dfs可能不会遍历所有点，所以要这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#x2F;&#x2F;遍历所有点</span><br><span class="line">if(!dfn[i]) Tarjan(i);</span><br></pre></td></tr></table></figure><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>每个点只被入栈，出栈一次，时间复杂度为$O(n)$</p><h1 id="双连通分量、割点和桥"><a href="#双连通分量、割点和桥" class="headerlink" title="双连通分量、割点和桥"></a>双连通分量、割点和桥</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>双联通分量与强联通分量类似，是一个<strong>无向图</strong>中的最大双连通子图。它分为两类：点双连通分量，边双连通分量（简称点双，边双）。</p><h2 id="点双连通分量、割点"><a href="#点双连通分量、割点" class="headerlink" title="点双连通分量、割点"></a>点双连通分量、割点</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>点双连通分量：是指一个<strong>无向图</strong>中的最大点双连通子图。</p><ul><li>点双连通图：一个去掉任意一节点都不会改变它的连通性的<strong>无向图</strong>。</li></ul><p>例如，下面这个图中，{1,2,3,4,5}就是一个点双连通分量</p><ul><li>割点：若一个图中，有一点$A$,删掉该点会使图不连通，那么称点$A$为割点。</li></ul><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>根据定义可以看出，任意两点间都有至少两条点不重复的路径。</p><p>点双连通分量之间以割点连接，且两个点双连通分量之间有且只有一个割点。</p><h3 id="割点求法"><a href="#割点求法" class="headerlink" title="割点求法"></a>割点求法</h3><p>首先类似于强连通分量，Tarjan求割点也是在Dfs基础上运行的，所以先获得一个Dfs树。</p><ul><li>对于根节点：比较好判断。统计一下根节点的子树个数，若 子树个数$\geq 2$，那么割掉根节点，两个子树便不再联通，即可说明根节点是割点。</li><li>对于非根节点：根据割点的定义和Dfs树，可以知道，割点被割掉后，图一定是被分成了<code>割点的子树A</code>和<code>除子树节点外所有的点B</code>两部分。简单点说，割掉割点相当于把子树剪掉了。经过分析，只要割掉一个点后，A和B不连通，即可保证该点是割点。也就是说，当A中的所有点，都只是通过这个点连接着B，而没有其它边连接A和B，即可说明</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.cnblogs.com/stxy-ferryman/p/7779347.html" target="_blank" rel="noopener">https://www.cnblogs.com/stxy-ferryman/p/7779347.html</a></p><p><a href="https://www.cnblogs.com/ljk123-de-bo-ke/p/10888905.html" target="_blank" rel="noopener">https://www.cnblogs.com/ljk123-de-bo-ke/p/10888905.html</a></p><p><a href="https://www.luogu.org/blog/shiboao/post-ti-gao-ge-dian" target="_blank" rel="noopener">https://www.luogu.org/blog/shiboao/post-ti-gao-ge-dian</a> </p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> tarjan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> tarjan </tag>
            
            <tag> 强连通分量 </tag>
            
            <tag> 双连通分量 </tag>
            
            <tag> 割点 </tag>
            
            <tag> 桥 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/hello-world/"/>
      <url>/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>基础动态规划汇总</title>
      <link href="/%E5%9F%BA%E7%A1%80%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%B1%87%E6%80%BB/"/>
      <url>/%E5%9F%BA%E7%A1%80%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>动态规划是OI种经典的算法之一，用途较为广泛。</p><h1 id="背包"><a href="#背包" class="headerlink" title="背包"></a><a href="https://rpdreamer.blog.luogu.org/bei-bao-wen-ti" target="_blank" rel="noopener">背包</a></h1><p><strong>背包问题特点：</strong>每种物品都有一个价值val和体积wei.</p><p>你现在有一个背包容积为V,你想用一些物品装背包使得物品总价值最大.</p><hr><h2 id="0-1背包"><a href="#0-1背包" class="headerlink" title="0-1背包"></a>0-1背包</h2><h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><p><strong>状态转移方程：</strong><br>$dp[i][j]=max(dp[i-1][j],dp[i-1][j-wei[i]]+val[i]);$<br>$i$代表一共选几个物品，$j$代表背包剩余容量，$wei[i]$代表i占容量，$val[i]$代表i的价值</p><p><strong>由于$dp[i][ ]$只与$dp[i-1][ ]$有关，可以用滚动数组压掉第一维</strong></p><p>或者：只开一个数组，直接在原数组上修改</p><p><strong>由于$dp[i][j]$只与$dp[i-1]<a href="m<j">m</a>$有关，如果仍然从前向后枚举j，会更改前面的值，对后续决策产生影响，所以我们需要从后往前枚举$j$，更新$j$的值</strong></p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#x2F;&#x2F;枚举装几个物品</span><br><span class="line">&#123;</span><br><span class="line">for(int j&#x3D;v;j&gt;&#x3D;wei[i];j--)&#x2F;&#x2F;枚举体积</span><br><span class="line">    &#123;</span><br><span class="line">    dp[j]&#x3D;max(dp[j],dp[j-wei[i]]+w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="典型题："><a href="#典型题：" class="headerlink" title="典型题："></a>典型题：</h3><p><a href="https://www.luogu.org/problemnew/show/P1048" target="_blank" rel="noopener">P1048 采药</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int wei[105], val[105];</span><br><span class="line">int dp[1005];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int t,m,res&#x3D;-1;    </span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;t,&amp;m);</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;wei[i],&amp;val[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;m;i++) </span><br><span class="line">    &#123;</span><br><span class="line">        for(int j&#x3D;t;j&gt;&#x3D;0;j--) </span><br><span class="line">        &#123;</span><br><span class="line">            if(j&gt;&#x3D;wei[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dp[j]&#x3D;max(dp[j-wei[i]]+val[i], dp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    printf(&quot;%d&quot;,dp[t]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><p><strong>特点：</strong>此类背包问题与01背包不同的是：我们的每种物品有无限多个,可重复选取。</p><h3 id="实现方法-1"><a href="#实现方法-1" class="headerlink" title="实现方法"></a>实现方法</h3><p>01背包中，为了防止更新时对后续更新产生影响，$t$要从后往前枚举。而完全背包只需改为从前往后即可。</p><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#x2F;&#x2F;枚举装几个物品</span><br><span class="line">&#123;</span><br><span class="line">for(int j&#x3D;wei[i];j&lt;&#x3D;v;j++)&#x2F;&#x2F;枚举体积</span><br><span class="line">    &#123;</span><br><span class="line">    dp[j]&#x3D;max(dp[j],dp[j-wei[i]]+w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="典型题：-1"><a href="#典型题：-1" class="headerlink" title="典型题："></a>典型题：</h3><p><a href="https://www.luogu.org/problemnew/show/P1616" target="_blank" rel="noopener">P1616 疯狂的采药</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">long long f[1000001],v[1000001],h[1000001];</span><br><span class="line">long long max(long long a,long long b)</span><br><span class="line">&#123;</span><br><span class="line">    if(a&gt;b)</span><br><span class="line">    return a;</span><br><span class="line">    else</span><br><span class="line">    return b;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    long long i,j,m,n;</span><br><span class="line">    scanf(&quot;%ld %ld&quot;,&amp;m,&amp;n);</span><br><span class="line">    for(i&#x3D;1;i&lt;&#x3D;n;i++)</span><br><span class="line">    scanf(&quot;%ld %ld&quot;,&amp;h[i],&amp;v[i]);</span><br><span class="line">    for(i&#x3D;1;i&lt;&#x3D;n;i++)</span><br><span class="line">        for(j&#x3D;h[i];j&lt;&#x3D;m;j++)</span><br><span class="line">            f[j]&#x3D;max(f[j],f[j-h[i]]+v[i]);</span><br><span class="line">    printf(&quot;%ld\n&quot;,f[m]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><h1 id="线性动归"><a href="#线性动归" class="headerlink" title="线性动归"></a>线性动归</h1><p><strong>线性动归特点：</strong> 只在一个数列上的dp。</p><h2 id="实现方法-2"><a href="#实现方法-2" class="headerlink" title="实现方法"></a>实现方法</h2><p>用$dp[i]$代表到$i$为止最优策略。</p><h2 id="典型题"><a href="#典型题" class="headerlink" title="典型题"></a>典型题</h2><p>最长不下降子序列：<br>给定一个数列，求出最长不下降子序列的长度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[100000];</span><br><span class="line">int dp[1000000];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">for(int i&#x3D;1;i&lt;&#x3D;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;a[i];</span><br><span class="line">dp[i]&#x3D;1;</span><br><span class="line">&#125;</span><br><span class="line">for(int i&#x3D;1;i&lt;&#x3D;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j&#x3D;1;j&lt;i;j++)</span><br><span class="line">&#123;</span><br><span class="line">if(a[i]&gt;&#x3D;a[j])&#x2F;&#x2F;可以更新</span><br><span class="line">&#123;</span><br><span class="line">dp[i]&#x3D;max(dp[i],dp[j]+1);&#x2F;&#x2F;取所有可以更新的情况中，更新后的最优决策（即最大值）</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int ans&#x3D;0;</span><br><span class="line">for(int i&#x3D;1;i&lt;&#x3D;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">ans&#x3D;max(ans,dp[i]);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line">return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="变形：P1091-合唱队形"><a href="#变形：P1091-合唱队形" class="headerlink" title="变形：P1091 合唱队形"></a>变形：<a href="https://www.luogu.org/problemnew/show/P1091#sub" target="_blank" rel="noopener">P1091 合唱队形</a></h2> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,a[105],f[2][105],ans;</span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++) </span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)</span><br><span class="line">        for(int j&#x3D;0;j&lt;i;j++) </span><br><span class="line">            if(a[i]&gt;a[j])</span><br><span class="line">                f[0][i]&#x3D;max(f[0][i],f[0][j]+1);</span><br><span class="line">    a[n+1]&#x3D;0;</span><br><span class="line">    for(int i&#x3D;n;i;i--)</span><br><span class="line">        for(int j&#x3D;n+1;j&gt;i;j--)</span><br><span class="line">            if(a[i]&gt;a[j])</span><br><span class="line">                f[1][i]&#x3D;max(f[1][i],f[1][j]+1);</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++) </span><br><span class="line">        ans&#x3D;max(f[0][i]+f[1][i]-1,ans); </span><br><span class="line">    printf(&quot;%d\n&quot;,n-ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>导弹拦截</p><p>友好城市</p><h1 id="区间动归"><a href="#区间动归" class="headerlink" title="区间动归"></a>区间动归</h1><p><strong>区间动归特点：</strong> </p><h2 id="实现方法-3"><a href="#实现方法-3" class="headerlink" title="实现方法"></a>实现方法</h2><p>用$dp[i][j]$代表区间$[i,j]$的最大值；<br>或者表示区间$[i,i+j]$的最大值。</p><h2 id="典型题：-2"><a href="#典型题：-2" class="headerlink" title="典型题："></a>典型题：</h2><p><a href="https://www.luogu.org/problemnew/show/P1880#sub" target="_blank" rel="noopener">P1880 [NOI1995]石子合并</a></p><h1 id="树形动归"><a href="#树形动归" class="headerlink" title="树形动归"></a>树形动归</h1><p><strong>树形动归特点：</strong> 在一棵树上的动态规划</p><h2 id="实现方法-4"><a href="#实现方法-4" class="headerlink" title="实现方法"></a>实现方法</h2><p>类比<a href="https://www.luogu.org/problemnew/show/P1216" target="_blank" rel="noopener">P1216 [USACO1.5]数字三角形 Number Triangles</a><br>，这题的思路是从三角形底部一层层合并到最顶部，便可得到答案</p><p>数字三角形代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[10000][10000];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">int num&#x3D;0;</span><br><span class="line">for(int i&#x3D;0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j&#x3D;0;j&lt;&#x3D;i;j++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;a[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int j&#x3D;0;</span><br><span class="line">for(int i&#x3D;n-2;i&gt;&#x3D;0;i--)</span><br><span class="line">&#123;</span><br><span class="line">for(int j&#x3D;0;j&lt;&#x3D;i;j++)</span><br><span class="line">&#123;</span><br><span class="line">if(a[i+1][j]&gt;&#x3D;a[i+1][j+1])</span><br><span class="line">&#123;</span><br><span class="line">a[i][j]+&#x3D;a[i+1][j];</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">a[i][j]+&#x3D;a[i+1][j+1];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;a[0][0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>树形动归与这个类似，应该从树的底部开始，向上处理</strong></p><h2 id="程序实现"><a href="#程序实现" class="headerlink" title="程序实现"></a>程序实现</h2><h3 id="如何存树："><a href="#如何存树：" class="headerlink" title="如何存树："></a>如何存树：</h3><p>利用链式前向星把树存成无向图<br>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int head[1666],pre[3666],to[3666],cnt&#x3D;0;</span><br><span class="line">void add_edge(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">    to[++cnt]&#x3D;b;</span><br><span class="line">    pre[cnt]&#x3D;head[a];</span><br><span class="line">    head[a]&#x3D;cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细解释：<a href="https://www.luogu.org/blog/2018--haha/lian-shi-qian-xiang-xing" target="_blank" rel="noopener">链式前向星</a></p><h3 id="如何从底部向上动归："><a href="#如何从底部向上动归：" class="headerlink" title="如何从底部向上动归："></a>如何从底部向上动归：</h3><p><strong>递归实现</strong><br>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void treedp(int pos)&#x2F;&#x2F;pos是现在的位置 </span><br><span class="line">&#123;</span><br><span class="line">    vis[pos]&#x3D;1;&#x2F;&#x2F;标记已访问过 </span><br><span class="line">    for(int i&#x3D;head[pos];i!&#x3D;-1;i&#x3D;pre[i])&#x2F;&#x2F;链式前向星的遍历 </span><br><span class="line">    &#123;</span><br><span class="line">        if(!vis[to[i]])&#x2F;&#x2F;第一次到达（防止在返回过程中再次递归下去，形成死循环） </span><br><span class="line">        &#123;</span><br><span class="line">            treedp(to[i]);&#x2F;&#x2F;递归到下一层 </span><br><span class="line">            ···&#x2F;&#x2F;状态转移方程 </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="典型题-1"><a href="#典型题-1" class="headerlink" title="典型题"></a>典型题</h2><p><a href="https://www.luogu.org/problemnew/show/P1352" target="_blank" rel="noopener"> P1352 没有上司的舞会</a></p><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int f[5][6000];</span><br><span class="line">int n,b,a,root;</span><br><span class="line">int cun[12000],zhi[12000],geshu[12000];</span><br><span class="line">bool vis[100000];</span><br><span class="line">void dp(int x)</span><br><span class="line">&#123;</span><br><span class="line">    vis[x]&#x3D;1;</span><br><span class="line">    for(int i&#x3D;zhi[x];i;i&#x3D;cun[i])</span><br><span class="line">    &#123;</span><br><span class="line">        if(vis[i]&#x3D;&#x3D;0)</span><br><span class="line">        &#123;</span><br><span class="line">            dp(i);</span><br><span class="line">            f[1][x]&#x3D;max(max(f[1][x],f[0][i]+f[1][x]),f[0][i]);</span><br><span class="line">            f[0][x]&#x3D;max(max(f[0][x],f[1][i]+f[0][x]),max(f[1][i],f[0][i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;f[1][i]);</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++) </span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</span><br><span class="line">        geshu[a]++;</span><br><span class="line">        cun[a]&#x3D;zhi[b]; </span><br><span class="line">        zhi[b]&#x3D;a;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)</span><br><span class="line">    if(geshu[i]&#x3D;&#x3D;0) </span><br><span class="line">    &#123;</span><br><span class="line"> root&#x3D;i;</span><br><span class="line">    break;</span><br><span class="line">    &#125;</span><br><span class="line">    dp(root);   </span><br><span class="line">    printf(&quot;%d&quot;,max(f[1][root],f[0][root]));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.luogu.org/problemnew/show/P2016#sub" target="_blank" rel="noopener">P2016 战略游戏</a><br>此题技巧：用$dp[0][i]$代表i这点不放的最优值，$dp[1][i]$代表i这点放的最优值</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,a,b,c,cnt,head[1666],f[1666][2];</span><br><span class="line">struct edge</span><br><span class="line">&#123;</span><br><span class="line">    int to;</span><br><span class="line">int next;</span><br><span class="line">&#125;edge[3333];</span><br><span class="line">void add_edge(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">    ++cnt;</span><br><span class="line">    edge[cnt].to&#x3D;y;</span><br><span class="line">    edge[cnt].next&#x3D;head[x];</span><br><span class="line">    head[x]&#x3D;cnt;</span><br><span class="line">&#125;</span><br><span class="line">void tree(int x,int from)</span><br><span class="line">&#123;</span><br><span class="line">    f[x][1]&#x3D;1;</span><br><span class="line">    f[x][0]&#x3D;0;</span><br><span class="line">    if(head[x]&#x3D;&#x3D;0)</span><br><span class="line">    &#123;</span><br><span class="line">        f[x][0]&#x3D;10000000;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i&#x3D;head[x];i;i&#x3D;edge[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        if(edge[i].to!&#x3D;from)</span><br><span class="line">        &#123;</span><br><span class="line">            tree(edge[i].to,x);</span><br><span class="line">            f[x][1]+&#x3D;min(f[edge[i].to][1],f[edge[i].to][0]);</span><br><span class="line">            f[x][0]+&#x3D;f[edge[i].to][1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        a++;</span><br><span class="line">        for(int j&#x3D;1;j&lt;&#x3D;b;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;c;</span><br><span class="line">            c++;</span><br><span class="line">            add_edge(a,c);</span><br><span class="line">            add_edge(c,a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tree(1,0);</span><br><span class="line">    int ans&#x3D;min(f[1][1],f[1][0]);</span><br><span class="line">    printf(&quot;%d&quot;,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="状压动归"><a href="#状压动归" class="headerlink" title="状压动归"></a>状压动归</h1><p><strong>状压动归特点：</strong>一般在矩阵上进行动归，不过由于情况过多，不可以开<del>inf</del>维数组进行解决，就需要使用状态压缩动归。在这类动态规划中，每个点的状态往往只用0或1来表示（复杂一些的可能需要用0,1,2），每一行每个点上的数字可以连成一个01串，如果我们把它看成一个二进制数，即可用一个十进制数来表示复杂的状态，即状态压缩。</p><h3 id="实现方法-5"><a href="#实现方法-5" class="headerlink" title="实现方法"></a>实现方法</h3><ul><li><p>用十进制数表示一个状态，对每一个合法的状态（十进制数字）进行处理（通过位运算）</p></li><li><p>由于限制了摆放k个，所以需要统计当前状态摆放了几个（二进制中1的个数）</p></li><li><p>先进行预处理，将可能方案（用一个十进制数表示）存入数组，将这个方案中1的个数存入数组，顺便简要删除一些不可行的方案，降低复杂度，然后在剩余方案上进行动归。</p></li></ul><h3 id="典型题-2"><a href="#典型题-2" class="headerlink" title="典型题"></a>典型题</h3><p><a href="https://www.luogu.org/problemnew/show/P1896" target="_blank" rel="noopener"> P1896 [SCOI2005]互不侵犯</a></p><h4 id="题意分析"><a href="#题意分析" class="headerlink" title="题意分析"></a>题意分析</h4><ul><li>一个$n<em>n$的矩阵，有多少种方式，不重叠地摆放k个$3</em>3$的方块，要求输出方案数。</li><li>处理方块中心点位置，看中心点放在某个位置是否合法（它的上下左…八个方向有没有其他方块）</li><li>根据两个方块中心点一定不相邻，删掉一些方案<h4 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void prepare()&#x2F;&#x2F;预处理可用情况 </span><br><span class="line">&#123;</span><br><span class="line">int k;</span><br><span class="line">s0&#x3D;0;</span><br><span class="line">ans&#x3D;0;</span><br><span class="line">memset(f,0,sizeof(f));</span><br><span class="line">for(int i&#x3D;0;i&lt;(1&lt;&lt;n);i++)&#x2F;&#x2F;十进制数从0枚举到 1&lt;&lt;n，即可把所有状态处理全 </span><br><span class="line">&#123;</span><br><span class="line">if(i&amp;(i&lt;&lt;1))continue;&#x2F;&#x2F;如果这个方案中有两个相邻，一定不满足条件，略过 </span><br><span class="line">k&#x3D;0;&#x2F;&#x2F;计数器 </span><br><span class="line">for(int j&#x3D;0;j&lt;n;j++)&#x2F;&#x2F;------ </span><br><span class="line">&#123;&#x2F;&#x2F;统 </span><br><span class="line">if(i&amp;(1&lt;&lt;j))&#x2F;&#x2F;计 </span><br><span class="line">&#123;&#x2F;&#x2F;1的 </span><br><span class="line">k++;&#x2F;&#x2F;个 </span><br><span class="line">&#125;&#x2F;&#x2F;数 </span><br><span class="line">&#125;&#x2F;&#x2F;------</span><br><span class="line">s[++s0]&#x3D;i;</span><br><span class="line">num[s0]&#x3D;k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="斜率优化"><a href="#斜率优化" class="headerlink" title="斜率优化"></a><a href="https://blog.csdn.net/force_chl/article/details/79096609" target="_blank" rel="noopener">斜率优化</a></h1></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 背包 </tag>
            
            <tag> 树形动态规划 </tag>
            
            <tag> 区间动态规划 </tag>
            
            <tag> 状态压缩动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++STL-Map的使用</title>
      <link href="/c++STL-Map%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/c++STL-Map%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>$\text{map,unordered_map}​$是$\text{c++STL}​$ 中的一种数据结构，能够实现映射操作，在某些题目中可起到不可替代的作用，本文介绍它们的使用方法。</p><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>Map可用于将一种类型的变量映射到另一种类型的变量。所以，它应该保护两个关键字，从一个映射到另一个。其实，数组就是一种int到其他类型的映射。例如：$\text{int}$类型的数组a，<code>a[x]=y</code>也就是把$x$映射到$y​$。</p><p><strong>有了数组，要map干什么？</strong></p><p>数组只是数字到其他类型的映射，但是假如我们要字符串到数字的映射怎么办？比如，将字符串<code>abc</code>映射到数字$5​$，对于数组，<code>a[&quot;abc&quot;]=5</code>显然会CE，但是有了map就不一样了。有$map​$，你甚至可以这样：<code>a[10000000000000000000]++;</code>。</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;map&gt;</span><br></pre></td></tr></table></figure><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map&lt;int,int&gt; a;</span><br><span class="line">map&lt;string,char&gt; a;</span><br><span class="line">map&lt;string,int&gt; a;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>其中尖括号内，左面是第一关键字，右面是第二关键字。</p><h3 id="插入、修改、访问"><a href="#插入、修改、访问" class="headerlink" title="插入、修改、访问"></a>插入、修改、访问</h3><p>以<code>map&lt;string,int&gt; a</code>为例 </p><p>下标访问即可<code>a[&quot;abc&quot;]=2;</code></p><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>循环遍历，下标访问,想数组一样。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a[i];</span><br></pre></td></tr></table></figure><p>如果储存值域过大，这种方式会导致TLE。</p><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>利用迭代器，可以只遍历存在的映射，跳过空位。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::iterator i=a.begin();i!=a.end();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,i-&gt;first,i-&gt;second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不会指针或迭代器，背下来即可，无需理解。<br>这种方式遍历的顺序是 第一关键字由小至大。</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p> 内部实现是一颗平衡树，每次操作复杂度为$log$级别的。</p><h1 id="Unordered-map"><a href="#Unordered-map" class="headerlink" title="Unordered_map"></a>Unordered_map</h1><p>Unordered_map与Map的区别不大，这里不再重复介绍相同点。以下对其不同之处进行介绍。</p><h2 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h2><p>遍历的方式是一样的，不过值得注意的是，用迭代器遍历时，遍历的元素顺序是乱的。</p><h2 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>由于内部实现是哈希表 ，插入和查询的复杂度均为$\theta(n)$</p>]]></content>
      
      
      <categories>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
            <tag> Map </tag>
            
            <tag> Unordered_map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最小费用最大流</title>
      <link href="/%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
      <url>/%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文发表于：</p><ul><li>个人博客：<a href="https://2018haha.github.io" target="_blank" rel="noopener">链接</a></li><li>洛谷博客：<a href="https://www.luogu.org/blog/2018--haha/solution-p3381" target="_blank" rel="noopener">链接</a></li></ul><p>网络流是OI中比较常出现的算法，而最小费用最大流是其最常用的算法之一，阅读本文前，请确保掌握了网络最大流的Dinic的求法，详见<a href="https://2018haha.github.io/2019/06/27/%E7%BD%91%E7%BB%9C%E6%9C%80%E5%A4%A7%E6%B5%81/#more" target="_blank" rel="noopener">网络最大流</a></p><h1 id="最小费用最大流算法"><a href="#最小费用最大流算法" class="headerlink" title="最小费用最大流算法"></a>最小费用最大流算法</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>最小费用最大流（以下简称费用流），是在网络最大流的基础上，给每个边增加了另一个值——费用，代表每流过一个单位的流量，就会耗费这些费用。而费用流算法，就是在求最大流的同时，找出所花费用最小的方案，并求出这个最小费用。</p><h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><p>首先，对于同一个图，它的最大流是一个固定的值，但是有很多方案，而求费用最小的走法，便可以利用<strong>最短路算法</strong>，以费用为最短路的边权。</p><p>思考一下，Dinic中的反边思想实际上是让程序可以沿着反边跑回去，达到反悔目的。所以费用流中，反边的费用需要设置成正边的相反数，保证在返回时费用也会还回来。</p><p>由于反边有负边权，所以要用<del>已死的</del>SPFA</p><p>把$Dinic$中的$Bfs$改为$SPFA$即可,每次找残量图中$S-T$的最短路径（费用作为边权），并按照$Dinic$的方式增广这条路径。</p><p>$Dinic$增广时需要把残量图中流量更改，所以要用能记录路径的$SPFA$</p><h3 id="建图"><a href="#建图" class="headerlink" title="建图"></a>建图</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> head[N],to[N],next[N],f[N],c[N];<span class="comment">//f是容量，c是费用</span></span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z,<span class="keyword">int</span> cost)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    to[++cnt]=y;</span><br><span class="line">    f[cnt]=z;</span><br><span class="line">    c[cnt]=cost;</span><br><span class="line">    next[cnt]=head[x];</span><br><span class="line">    head[x]=cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dis[N];<span class="comment">/*spfa的距离数组*/</span></span><br><span class="line"><span class="keyword">int</span> flow[N];<span class="comment">/*源点到此处流量*/</span></span><br><span class="line"><span class="keyword">int</span> vis[N];</span><br><span class="line"><span class="keyword">int</span> pre[N];<span class="comment">//每个点的前驱 </span></span><br><span class="line"><span class="keyword">int</span> last[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Spfa</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dis,<span class="number">0x7f</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line"><span class="built_in">memset</span>(flow,<span class="number">0x7f</span>,<span class="keyword">sizeof</span>(flow));</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">q.push(S);</span><br><span class="line">vis[S]=<span class="number">1</span>,dis[S]=<span class="number">0</span>;</span><br><span class="line">pre[T]=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u=q.front();</span><br><span class="line">q.pop();</span><br><span class="line">vis[u]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=next[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=to[i];</span><br><span class="line"><span class="keyword">if</span>(f[i]&gt;<span class="number">0</span> &amp;&amp; dis[v]&gt;dis[u]+c[i])<span class="comment">//有残量，能松弛</span></span><br><span class="line">&#123;</span><br><span class="line">dis[v]=dis[u]+c[i];<span class="comment">//更新距离</span></span><br><span class="line">pre[v]=u;<span class="comment">//SPFA记录前驱</span></span><br><span class="line">last[v]=i;<span class="comment">//记录边的编号，便于增广时更改边权 </span></span><br><span class="line">flow[v]=min(flow[u],f[i]);</span><br><span class="line"><span class="keyword">if</span>(!vis[v])</span><br><span class="line">&#123;</span><br><span class="line">vis[v]=<span class="number">1</span>;</span><br><span class="line">q.push(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ~pre[T];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Flow,Cost;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mcmf</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(Spfa())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u=T;</span><br><span class="line">Flow+=flow[T];</span><br><span class="line">Cost+=flow[T]*dis[T];</span><br><span class="line"><span class="keyword">while</span>(u!=S)<span class="comment">//遍历这次的增广路（最短路） </span></span><br><span class="line">&#123;</span><br><span class="line">f[last[u]]-=flow[T];<span class="comment">//更新边权 </span></span><br><span class="line">f[last[u]^<span class="number">1</span>]+=flow[T];</span><br><span class="line">u=pre[u];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这种费用流算法实际上就是在增广时优先考虑费用（用最短路$\text{SPFA}$实现），保证费用最小（反正由于反边的存在，$\text{Dinic}$怎么流到最后都能流出最大流 ）。</p><p>完整代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next adjagag</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N],to[N],next[N],f[N],c[N];</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,S,T;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z,<span class="keyword">int</span> cost)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    to[++cnt]=y;</span><br><span class="line">    f[cnt]=z;</span><br><span class="line">    c[cnt]=cost;</span><br><span class="line">    next[cnt]=head[x];</span><br><span class="line">    head[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dis[N];</span><br><span class="line"><span class="keyword">int</span> flow[N];</span><br><span class="line"><span class="keyword">int</span> vis[N];</span><br><span class="line"><span class="keyword">int</span> pre[N];</span><br><span class="line"><span class="keyword">int</span> last[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Spfa</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dis,<span class="number">0x7f</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line"><span class="built_in">memset</span>(flow,<span class="number">0x7f</span>,<span class="keyword">sizeof</span>(flow));</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">q.push(S);</span><br><span class="line">vis[S]=<span class="number">1</span>,dis[S]=<span class="number">0</span>;</span><br><span class="line">pre[T]=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u=q.front();</span><br><span class="line">q.pop();</span><br><span class="line">vis[u]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=next[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=to[i];</span><br><span class="line"><span class="keyword">if</span>(f[i]&gt;<span class="number">0</span> &amp;&amp; dis[v]&gt;dis[u]+c[i])</span><br><span class="line">&#123;</span><br><span class="line">dis[v]=dis[u]+c[i];</span><br><span class="line">pre[v]=u;</span><br><span class="line">last[v]=i;</span><br><span class="line">flow[v]=min(flow[u],f[i]);</span><br><span class="line"><span class="keyword">if</span>(!vis[v])</span><br><span class="line">&#123;</span><br><span class="line">vis[v]=<span class="number">1</span>;</span><br><span class="line">q.push(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ~pre[T];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Flow,Cost;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mcmf</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(Spfa())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u=T;</span><br><span class="line">Flow+=flow[T];</span><br><span class="line">Cost+=flow[T]*dis[T];</span><br><span class="line"><span class="keyword">while</span>(u!=S)</span><br><span class="line">&#123;</span><br><span class="line">f[last[u]]-=flow[T];</span><br><span class="line">f[last[u]^<span class="number">1</span>]+=flow[T];</span><br><span class="line">u=pre[u];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>,&amp;n,&amp;m,&amp;S,&amp;T);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,z,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>,&amp;x,&amp;y,&amp;z,&amp;c);</span><br><span class="line">        Add(x,y,z,c);</span><br><span class="line">        Add(y,x,<span class="number">0</span>,-c);</span><br><span class="line">    &#125;</span><br><span class="line">    Mcmf();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,Flow,Cost);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 网络流 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络流 </tag>
            
            <tag> 费用流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络最大流</title>
      <link href="/%E7%BD%91%E7%BB%9C%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
      <url>/%E7%BD%91%E7%BB%9C%E6%9C%80%E5%A4%A7%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文发表于：</p><ul><li>个人博客：<a href="http://2018haha.github.io/2019/06/27/%E7%BD%91%E7%BB%9C%E6%9C%80%E5%A4%A7%E6%B5%81/#more" target="_blank" rel="noopener">传送门</a></li><li>洛谷博客：<a href="https://www.luogu.org/blog/2018--haha/solution-p3376" target="_blank" rel="noopener">传送门</a></li></ul><p>网络最大流算法能在信息学竞赛中处理很多问题，而且往往是不可被其它算法替代的。而最大流算法则是处理问题的方法之一。本文将介绍网络最大流的算法及其优化。</p><p><strong>关于本文代码</strong></p><ul><li>存图方式：数组链式前项星。</li></ul><h1 id="网络最大流算法-Dinic"><a href="#网络最大流算法-Dinic" class="headerlink" title="网络最大流算法-Dinic"></a>网络最大流算法-Dinic</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h3><ul><li>源点（$S$)：网络流流出的点</li><li>汇点（$T$)：网络流流入的点</li><li>流量：一条边上流过流的多少</li><li>容量：一条边最大流量</li><li>残量：一条边上剩余流量，即容量$-​$流量</li></ul><h2 id="朴素的算法"><a href="#朴素的算法" class="headerlink" title="朴素的算法"></a>朴素的算法</h2><p>由于网络流算法都是基于增广这一思路的，接下来对增广进行介绍。</p><p>要想求出网络最大流，思路大体上就是不停地寻找增广路，直到没有增广路，即可保证求到了最大流。</p><h3 id="增广："><a href="#增广：" class="headerlink" title="增广："></a>增广：</h3><p>1.找到一条从源点通向到汇点的路径，并且这条路径上，每条边都有残量（这代表这条路并没有流满，完全可以增加一些流量），这条路叫做增广路。</p><p>2.取这条增广路上残量最小值，代表这条增广路上可以增加这么多流量（取最小值的原因显然）。</p><p>3.将增广路上每条边残量减去增加的流量，加入答案；</p><p>4.直到找不到增广路。</p><h2 id="HACK"><a href="#HACK" class="headerlink" title="HACK"></a>HACK</h2><p>如果仔细思考，以上算法仍然存在缺陷：</p><p>如下图：</p><p><img src="/%E5%9B%BE1.png" alt=""></p><p>此时找到的最大流是$10$，而实际上是$15$，因此，我们要进行改进。</p><h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>这里是解决网络流问题的关键步骤：</p><p><strong>引入反向边</strong></p><p>即每次在找到增广路，更新残量时，同时将其反向边的残量相应增加：</p><p>具体过程如下图：</p><p><img src="/%E5%9B%BE2.png" alt=""></p><p>这样求出的最大流是15，正确。</p><p>实际上，引入了反向边，让程序可以进行一次$S-3-4-1-2-T​$这样的增广。</p><p>第一次增广不一定能寻得恰当的路线，而反向边可以让程序有<strong>反悔的机会</strong>，便是对的。</p><h3 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h3><p>这样多次进行增广，会导致程序效率便得非常低。例如下图：</p><p><img src="/%E5%9B%BE3.png" alt=""></p><p>会增广很多次。于是我们引入Dinic算法。</p><h2 id="Dinic"><a href="#Dinic" class="headerlink" title="Dinic"></a>Dinic</h2><p>$\text{Dinic}$在原有算法基础上，增加了分层图，即根据距离源点的距离，将每个点进行深度标号，每次找增广路时都保证深度递增地寻找。</p><h3 id="分层（BFS）"><a href="#分层（BFS）" class="headerlink" title="分层（BFS）"></a>分层（BFS）</h3><p>以下是分层部分的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Bfs</span><span class="params">()</span><span class="comment">//返回是否分层成功，即是否有最短路</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="built_in">memset</span>(dep,<span class="number">0</span>,<span class="keyword">sizeof</span>(dep));<span class="comment">//一定不要忘了清空</span></span><br><span class="line">    dep[S]=<span class="number">1</span>;</span><br><span class="line">    q.push(S);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=next[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v=to[i];</span><br><span class="line">            <span class="keyword">if</span>(w[i] &amp;&amp; !dep[v])<span class="comment">//有残量，而且通往的点还没有访问过（标记过深度）</span></span><br><span class="line">            &#123;</span><br><span class="line">                dep[v]=dep[u]+<span class="number">1</span>;</span><br><span class="line">                q.push(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[T];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="增广（DFS）"><a href="#增广（DFS）" class="headerlink" title="增广（DFS）"></a>增广（DFS）</h3><p>以下是找增广路部分的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> dis)</span><span class="comment">//当前节点，到目前为止可增加流量，返回可增加流量</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==T || (!dis)) <span class="keyword">return</span> dis;<span class="comment">//到达汇点||已无残量</span></span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=next[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v=to[i];</span><br><span class="line">        <span class="keyword">if</span>(dep[v]==dep[u]+<span class="number">1</span> &amp;&amp; w[i])<span class="comment">//通向的边在下一层且有残量</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> di=Dfs(v,min(dis,w[i]));</span><br><span class="line">            <span class="keyword">if</span>(di&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                w[i]-=di,w[i^<span class="number">1</span>]+=di;</span><br><span class="line">                <span class="keyword">return</span> di;<span class="comment">//传递;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//无增广路</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用部分"><a href="#调用部分" class="headerlink" title="调用部分"></a>调用部分</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(Bfs())<span class="comment">//能分层</span></span><br><span class="line">    &#123;</span><br><span class="line">        ans+=Dfs(S,<span class="number">10000000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h3><p>需要注意的是，为了实现增加反边，在建图时就需要提前建好容量为$0​$的反边。</p><p><strong>补充</strong></p><p>在链式前向星建图中，$cnt$初始值设成$1$,这样对于编号为$i$的边，它的反边编号就是$i$^$1$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>,&amp;n,&amp;m,&amp;S,&amp;T);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,z;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">        Add(x,y,z);</span><br><span class="line">        Add(y,x,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Dinic());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Dinic的优化"><a href="#Dinic的优化" class="headerlink" title="Dinic的优化"></a>Dinic的优化</h2><p>以上的$\text{Dinic}$算法是优化前的，一下对它的$3$种优化进行一一介绍：</p><h3 id="当前弧优化"><a href="#当前弧优化" class="headerlink" title="当前弧优化"></a>当前弧优化</h3><p>在每次增广后，某个节点引出的几条边的残量会被更新成$0$，在原有算法中，残量为$0$的边仍会被扫一遍，而当前弧优化即是对上次停下的位置进行记录，下次直接从上次结束的位置开始。</p><p>实现方法就是用一个数组记录每个点处理到了第几条边，在代码中只需要加入几行即可，如下：</p><h4 id="增广（DFS）-1"><a href="#增广（DFS）-1" class="headerlink" title="增广（DFS）"></a>增广（DFS）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cur[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> dis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==T || (!dis)) <span class="keyword">return</span> dis;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> &amp;i=cur[u];i;i=next[i])<span class="comment">//注意这里的&amp; 和cur，在i增加的同时，cur[i]的值也会相应增加，达到了记录的目的</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v=to[i];</span><br><span class="line">        <span class="keyword">if</span>(dep[v]==dep[u]+<span class="number">1</span> &amp;&amp; w[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> di=Dfs(v,min(dis,w[i]));</span><br><span class="line">            <span class="keyword">if</span>(di&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                w[i]-=di,w[i^<span class="number">1</span>]+=di;</span><br><span class="line">                <span class="keyword">return</span> di;<span class="comment">//传递;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//无增广路</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="调用部分-1"><a href="#调用部分-1" class="headerlink" title="调用部分"></a>调用部分</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(Bfs())<span class="comment">//能分层</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(cur,head,<span class="keyword">sizeof</span>(head));<span class="comment">//重新更改回第一条边</span></span><br><span class="line">        ans+=Dfs(S,<span class="number">10000000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多路增广"><a href="#多路增广" class="headerlink" title="多路增广"></a>多路增广</h3><p>每次不只是找一条增广路，而是只要可以就都递归下去，这样增广出来的不只是一条链，而是一个网，可以加快运行速度（降低常数）</p><h4 id="增广部分"><a href="#增广部分" class="headerlink" title="增广部分"></a>增广部分</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> dis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==T || (!dis)) <span class="keyword">return</span> dis;</span><br><span class="line">    <span class="keyword">int</span> flow=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=cur[u];i;i=next[i])</span><br><span class="line">    &#123;</span><br><span class="line">cur[u]=i;</span><br><span class="line">        <span class="keyword">int</span> v=to[i];</span><br><span class="line">        <span class="keyword">if</span>(dep[v]==dep[u]+<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="keyword">int</span> di=Dfs(v,min(dis,w[i]));<span class="comment">//注意这个一定要放到if里面，否则会导致图不分层，导致TLE/MLE </span></span><br><span class="line">            flow+=di;<span class="comment">//这里不急着return，而是记录一下这条链上能增广的流量，再接着找下一条链</span></span><br><span class="line">            dis-=di;<span class="comment">//把从u开始能增广的容量相应减去</span></span><br><span class="line">            w[i]-=di,w[i^<span class="number">1</span>]+=di;<span class="comment">//更新边权</span></span><br><span class="line">            <span class="keyword">if</span>(!dis) <span class="keyword">break</span>;<span class="comment">//没容量了</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="炸点"><a href="#炸点" class="headerlink" title="炸点"></a>炸点</h3><p>当一个点连的边的残量都为$0$时，这个点已经没有用了，之后就不要再进入这个点了，这就是“炸点”。</p><p>具体实现可以把这个点的深度设置成$-1$，保证不会再次访问这个点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> dis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==T || (!dis)) <span class="keyword">return</span> dis;</span><br><span class="line">    <span class="keyword">int</span> flow=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=cur[u];i;i=next[i])</span><br><span class="line">    &#123;</span><br><span class="line">cur[u]=i;</span><br><span class="line">        <span class="keyword">int</span> v=to[i];</span><br><span class="line">        <span class="keyword">if</span>(dep[v]==dep[u]+<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="keyword">int</span> di=Dfs(v,min(dis,w[i]));</span><br><span class="line">            flow+=di;</span><br><span class="line">            dis-=di;</span><br><span class="line">            w[i]-=di,w[i^<span class="number">1</span>]+=di;</span><br><span class="line">            <span class="keyword">if</span>(!dis) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!flow)<span class="comment">//这个点甚至没有增广出一点流量</span></span><br><span class="line">        dep[u]=<span class="number">-1</span>;<span class="comment">//炸掉它</span></span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Dinic算法是较为高效的网络流算法，建议使用时加入以上$3$条优化。</p><p>下面给出完整代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next adjagag</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N],to[N],next[N],w[N];</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,S,T;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    to[++cnt]=y;</span><br><span class="line">    w[cnt]=z;</span><br><span class="line">    next[cnt]=head[x];</span><br><span class="line">    head[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dep[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="built_in">memset</span>(dep,<span class="number">0</span>,<span class="keyword">sizeof</span>(dep));</span><br><span class="line">    dep[S]=<span class="number">1</span>;</span><br><span class="line">    q.push(S);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=next[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v=to[i];</span><br><span class="line">            <span class="keyword">if</span>(w[i] &amp;&amp; !dep[v])</span><br><span class="line">            &#123;</span><br><span class="line">                dep[v]=dep[u]+<span class="number">1</span>;</span><br><span class="line">                q.push(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[T];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> cur[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> dis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==T || (!dis)) <span class="keyword">return</span> dis;</span><br><span class="line">    <span class="keyword">int</span> flow=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=cur[u];i;i=next[i])</span><br><span class="line">    &#123;</span><br><span class="line">cur[u]=i;</span><br><span class="line">        <span class="keyword">int</span> v=to[i];</span><br><span class="line">        <span class="keyword">if</span>(dep[v]==dep[u]+<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="keyword">int</span> di=Dfs(v,min(dis,w[i]));</span><br><span class="line">            flow+=di;</span><br><span class="line">            dis-=di;</span><br><span class="line">            w[i]-=di,w[i^<span class="number">1</span>]+=di;</span><br><span class="line">            <span class="keyword">if</span>(!dis) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!flow)</span><br><span class="line">        dep[u]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(Bfs())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(cur,head,<span class="keyword">sizeof</span>(head));</span><br><span class="line">        ans+=Dfs(S,<span class="number">10000000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>,&amp;n,&amp;m,&amp;S,&amp;T);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,z;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">        Add(x,y,z);</span><br><span class="line">        Add(y,x,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Dinic());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.cnblogs.com/SYCstudio/p/7260613.html" target="_blank" rel="noopener">https://www.cnblogs.com/SYCstudio/p/7260613.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 网络流 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络流 </tag>
            
            <tag> 最大流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链式前向星</title>
      <link href="/%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F/"/>
      <url>/%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>链式前向星是类似于邻接表的存图方式，具有空间复杂度小，便于遍历等优点，不过无法快速判断两点间是否有边</p><h1 id="储存"><a href="#储存" class="headerlink" title="储存"></a>储存</h1><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>这种存图方式只需要开一个数组存储每个点引出的第一条边，然后存储每个点作为起点的每条边，这样就可以做到不重不漏。</p><p>在链式前向星存图中，我们需要定义一个结构体：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct EDGE </span><br><span class="line">&#123;</span><br><span class="line">    int next;</span><br><span class="line">    int to;</span><br><span class="line">&#125;edge[1000000];</span><br></pre></td></tr></table></figure><p>和一个数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int head[1000000];</span><br></pre></td></tr></table></figure><p>和一个变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int cnt&#x3D;0;&#x2F;&#x2F;指针</span><br></pre></td></tr></table></figure><p>你会发现竟然没存起点！！其实起点是用$head$存的</p><h2 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h2><p> <img src="https://cdn.luogu.org/upload/pic/43957.png" alt=""></p><p>如图：这样的一个有向图，输入是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure><h3 id="逐步分析："><a href="#逐步分析：" class="headerlink" title="逐步分析："></a>逐步分析：</h3><h4 id="1-输入1-2，代表1连向2。"><a href="#1-输入1-2，代表1连向2。" class="headerlink" title="1.输入1 2，代表1连向2。"></a>1.输入1 2，代表1连向2。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cnt++;&#x2F;&#x2F;作为结构体下标，没有意义</span><br><span class="line">head[1]&#x3D;cnt;&#x2F;&#x2F;结点1的第一个儿子存在了edge[cnt]里面</span><br><span class="line">edge[cnt].to&#x3D;2;结点1的儿子是2</span><br></pre></td></tr></table></figure><p>此时：<br>$cnt=1$</p><table><thead><tr><th align="center">$edge$</th><th align="center">$cnt=1$</th><th align="center">$cnt=2$</th><th align="center">$ cnt=3$</th><th align="center">$cnt=4$</th></tr></thead><tbody><tr><td align="center">$to $</td><td align="center">$2$</td><td align="center">$0$</td><td align="center">$ 0$</td><td align="center">$0$</td></tr><tr><td align="center">$next$</td><td align="center">$ 0 $</td><td align="center">$0 $</td><td align="center">$0$</td><td align="center">$0$</td></tr></tbody></table><table><thead><tr><th align="center">$head $</th><th align="center">下标$=1 $</th><th align="center">下标$=2$</th><th align="center">下标$=3 $</th><th align="center">下标$=4 $</th></tr></thead><tbody><tr><td align="center">值</td><td align="center">$1 $</td><td align="center">$ 0 $</td><td align="center">$ 0 $</td><td align="center">$ 0 $</td></tr></tbody></table><h4 id="2-输入1-3，代表1连向3。"><a href="#2-输入1-3，代表1连向3。" class="headerlink" title="2.输入1 3，代表1连向3。"></a>2.输入1 3，代表1连向3。</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cnt++;</span><br><span class="line">head[<span class="number">1</span>]=cnt;</span><br><span class="line">edge[cnt].to=<span class="number">3</span>;结点<span class="number">1</span>的儿子是<span class="number">3</span></span><br><span class="line"><span class="comment">//这时,3成为了结点1的儿子，不过2被挤了下去...</span></span><br><span class="line"><span class="comment">//所以要引入结构体中next元素，记录：3还有个兄弟（next）是2</span></span><br><span class="line"><span class="comment">//所以代码要换成：</span></span><br><span class="line">cnt++;</span><br><span class="line">edge[cnt].to=<span class="number">3</span>;<span class="comment">//结点1连向3</span></span><br><span class="line">edge[cnt].next=head[<span class="number">1</span>];<span class="comment">//3的兄弟是2</span></span><br><span class="line">head[<span class="number">1</span>]=cnt;<span class="comment">//更新head</span></span><br></pre></td></tr></table></figure><p>此时：<br>$cnt=2$</p><table><thead><tr><th align="center">$edge$</th><th align="center">$cnt=1$</th><th align="center">$cnt=2$</th><th align="center">$ cnt=3$</th><th align="center">$cnt=4$</th></tr></thead><tbody><tr><td align="center">$to $</td><td align="center">$2$</td><td align="center">$3$</td><td align="center">$ 0$</td><td align="center">$0$</td></tr><tr><td align="center">$next$</td><td align="center">$ 0 $</td><td align="center">$1 $</td><td align="center">$0$</td><td align="center">$0$</td></tr></tbody></table><table><thead><tr><th align="center">$head $</th><th align="center">下标$=1 $</th><th align="center">下标$=2$</th><th align="center">下标$=3 $</th><th align="center">下标$=4 $</th></tr></thead><tbody><tr><td align="center">值</td><td align="center">$2 $</td><td align="center">$ 0 $</td><td align="center">$ 0 $</td><td align="center">$ 0 $</td></tr></tbody></table><h4 id="3-输入1-4，代表1连向4。"><a href="#3-输入1-4，代表1连向4。" class="headerlink" title="3.输入1 4，代表1连向4。"></a>3.输入1 4，代表1连向4。</h4><p>此时：<br>$cnt=3$</p><table><thead><tr><th align="center">$edge$</th><th align="center">$cnt=1$</th><th align="center">$cnt=2$</th><th align="center">$ cnt=3$</th><th align="center">$cnt=4$</th></tr></thead><tbody><tr><td align="center">$to $</td><td align="center">$2$</td><td align="center">$3$</td><td align="center">$ 4$</td><td align="center">$0$</td></tr><tr><td align="center">$next$</td><td align="center">$ 0 $</td><td align="center">$1 $</td><td align="center">$2$</td><td align="center">$0$</td></tr></tbody></table><table><thead><tr><th align="center">$head $</th><th align="center">下标$=1 $</th><th align="center">下标$=2$</th><th align="center">下标$=3 $</th><th align="center">下标$=4 $</th></tr></thead><tbody><tr><td align="center">值</td><td align="center">$3 $</td><td align="center">$ 0 $</td><td align="center">$ 0 $</td><td align="center">$ 0 $</td></tr></tbody></table><h4 id="4-输入2-3，代表2连向3。"><a href="#4-输入2-3，代表2连向3。" class="headerlink" title="4.输入2 3，代表2连向3。"></a>4.输入2 3，代表2连向3。</h4><p>此时：<br>$cnt=4$</p><table><thead><tr><th align="center">$edge$</th><th align="center">$cnt=1$</th><th align="center">$cnt=2$</th><th align="center">$ cnt=3$</th><th align="center">$cnt=4$</th></tr></thead><tbody><tr><td align="center">$to $</td><td align="center">$2$</td><td align="center">$3$</td><td align="center">$ 4$</td><td align="center">$3$</td></tr><tr><td align="center">$next$</td><td align="center">$ 0 $</td><td align="center">$1 $</td><td align="center">$2$</td><td align="center">$0$</td></tr></tbody></table><table><thead><tr><th align="center">$head $</th><th align="center">下标$=1 $</th><th align="center">下标$=2$</th><th align="center">下标$=3 $</th><th align="center">下标$=4 $</th></tr></thead><tbody><tr><td align="center">值</td><td align="center">$3 $</td><td align="center">$ 4 $</td><td align="center">$ 0 $</td><td align="center">$ 0 $</td></tr></tbody></table><p><strong>注意</strong>：$edge[cnt].next$ 和$head[1]$存贮的都是结构体下标（即$cnt$的值）若要访问指向的边的编号，分别用$edge[edge[cnt].next].to$，$edge[head[1]].to$</p><p><strong>若需要记录权值，在结构体中加入一个元素即可</strong></p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><p>带权值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> wei;</span><br><span class="line">&#125;edge[MAXM];</span><br><span class="line"><span class="keyword">int</span> head[MAXN];<span class="comment">//head[i]为i点的第一条边</span></span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span> <span class="comment">//起点，终点，权值 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[++cnt].next=head[u];<span class="comment">//更新cnt</span></span><br><span class="line">    edge[cnt].to=v;</span><br><span class="line">    edge[cnt].w=w;</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,wei;</span><br><span class="line">        addedge(a,b,wei);</span><br><span class="line">        <span class="comment">//如果是无向图，还要addedge(b,a,wei);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p> 这里的$next$指的是遍历时的下一条边，$head$指的是遍历时的第一条边，而存边时相当于反过来操作，所以$next$记录上一条边，而$head$记录最后一条边。</p><hr><h1 id="边的遍历"><a href="#边的遍历" class="headerlink" title="边的遍历"></a>边的遍历</h1><p>在遍历以x为起点的所有边时，只需要这样就行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].next)</span><br></pre></td></tr></table></figure><p>这个循环的结束条件是$i$等于$0$，因为最后一条边，也就是存边时第一条边，在把$head$值存进$next$时，$head$还没有更新过，也就是$0$。所以当$next$返回$0$时，就说明这些边遍历完毕了。</p><hr><h1 id="优势与特点"><a href="#优势与特点" class="headerlink" title="优势与特点"></a>优势与特点</h1><p>既可以存图，也可以存树，比起邻接矩阵，链式前向星的空间复杂度是$O(n)$,大大节省了存储空间，因为按边存储省掉了很多两点无边的空间。并且在遍历的时候，那些与起点无边相连的点也不需要进行处理，可以说时间和空间都占优势，这就是被OIer们广泛使用的原因。</p><h1 id="补充-技巧"><a href="#补充-技巧" class="headerlink" title="补充+技巧"></a>补充+技巧</h1><p> （$2019/1/15 update​$）<br> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span> <span class="comment">//起点，终点，权值 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[++cnt].next=head[u];<span class="comment">//更新cnt</span></span><br><span class="line">    edge[cnt].to=v;</span><br><span class="line">    edge[cnt].w=w;</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个代码中，$cnt$代表边的编号。</p><p>如果$cnt​$初始值赋为$1​$,存的是无向图，那么：</p><p>边$cnt$的反向边是$cnt$^$1$</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 存图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后缀数组</title>
      <link href="/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"/>
      <url>/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是后缀数组："><a href="#什么是后缀数组：" class="headerlink" title="什么是后缀数组："></a>什么是后缀数组：</h1><h4 id="看几条定义-应该没啥用-："><a href="#看几条定义-应该没啥用-：" class="headerlink" title="看几条定义(应该没啥用)："></a>看几条定义(应该没啥用)：</h4><ul><li>子串</li></ul><p>在字符串$s$中，取任意$i&lt;=j$，那么在$s$中截取从$i$到$j$的这一段就叫做$s$的一个子串<br>后缀</p><ul><li>后缀</li></ul><p>就是从字符串的某个位置i到字符串末尾的子串，我们定义以$s$的第$i$个字符为第一个元素的后缀为$suff(i)$</p><ul><li>后缀数组</li></ul><p>把$s$的每个后缀按照字典序排序，</p><p>后缀数组$sa[i]$就表示排名为i的后缀的起始位置的下标</p><p>而它的映射数组$rk[i]$就表示起始位置的下标为i的后缀的排名</p><p>即：$sa$表示排名为$i$的是啥，$rk$表示第$i$个的排名是啥</p><h1 id="后缀数组的思想"><a href="#后缀数组的思想" class="headerlink" title="后缀数组的思想"></a>后缀数组的思想</h1><p>先说最暴力的情况，对每个后缀排序$(nlogn)%，但是这是一个字符串，所以比较任意两个后缀的复杂度其实是%O(n)%，复杂度$O(n^2logn)$的，肯定会$T$,接下来需要把优化。</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h4 id="优化1：倍增——对排序的优化"><a href="#优化1：倍增——对排序的优化" class="headerlink" title="优化1：倍增——对排序的优化"></a>优化1：倍增——对排序的优化</h4><p>我们不是把每一个后缀字符串列举出来，当做没有联系的字符串进行排序，而是<strong>把每一个后缀都放在原串中考虑。</strong></p><p>1.先根据<strong>单个字符</strong>排序，(即先按照每个后缀的第一个字符排序）。对于每个字符，我们按照字典序给一个排名(当然可以并列)，这里称作关键字。</p><p><img src="https://cdn.luogu.org/upload/pic/53019.png" alt=""></p><p>2.接下来我们再把相邻的两个关键字合并到一起(即先按照每个后缀的前两个字符排序）。这样就是以第一个字符(也就是自己本身)的排名为第一关键字，以第二个字符的排名为第二关键字，把组成的新数排完序之后再次标号。(没有第二关键字的补零)</p><p><img src="https://cdn.luogu.org/upload/pic/53021.png" alt=""></p><p>3.接下来就要倍增了：我们对于一个在第$i$位上的关键字，它的第二关键字就是第$i+2$位置上的，联想一下，因为现在第i位上的关键字是$suff(i)$的前两个字符的排名，第$i+2$位置上的关键字是$suff(i+2)$的前两个字符的排名，这两个一合并，不就是$suff(i)$的前四个字符的排名吗？方法同上，排序之后重新标号，没有第二关键字的补零。同理我们可以证明，下一次我们要合并的是第$i$位和第$i+4$位，以此类推即可</p><p>·<br>·<br>·</p><p>当所有的排名都不同的时候我们直接退出就可以了，因为已经排好了。</p><p>这样排序的速度稳定在$(logn)$</p><h4 id="优化2——基数排序"><a href="#优化2——基数排序" class="headerlink" title="优化2——基数排序"></a>优化2——基数排序</h4><p>如果我们用快排的话，复杂度就是$(nlog^2n)$ 还是太大。</p><p>这里我们用一波基数排序优化一下。在这里我们可以注意到，每一次排序都是排两位数，所以基数排序可以将它优化到$O(n)$级别，总复杂度就是$(nlogn)$。</p><p>介绍一下什么是基数排序，这里就拿两位数举例</p><p>我们要建两个桶，一个装个位，一个装十位，我们先把数加到个位桶里面，再加到十位桶里面，这样就能保证对于每个十位桶，桶内的顺序肯定是按个位升序的。</p><h1 id="最长公共前缀——后缀数组的辅助工具"><a href="#最长公共前缀——后缀数组的辅助工具" class="headerlink" title="最长公共前缀——后缀数组的辅助工具"></a>最长公共前缀——后缀数组的辅助工具</h1><h3 id="什么是LCP？"><a href="#什么是LCP？" class="headerlink" title="什么是LCP？"></a>什么是LCP？</h3><p>我们定义$LCP(i,j)$为$suff(sa[i])$与$suff(sa[j])$的最长公共前缀</p><h3 id="为什么要求LCP？"><a href="#为什么要求LCP？" class="headerlink" title="为什么要求LCP？"></a>为什么要求LCP？</h3><p>后缀数组这个东西，不可能只让你排个序就完事了……大多数情况下我们都需要用到这个辅助工具LCP来做题的<br>关于LCP的几条性质<br>显而易见的</p><pre><code>LCP(i,j)=LCP(j,i);LCP(i,i)=len(sa[i])=n-sa[i]+1;</code></pre><p>对于$i&gt;j$的情况，我们可以把它转化成$i&lt;j$，对于$i==j$的情况，我们可以直接算长度，所以我们直接讨论$i&lt;j$的情况就可以了。</p><p>我们每次依次比较字符肯定是不行的，单次复杂度为$O(n)$，太高了，所以我们要做一定的预处理才行。</p><h3 id="几个性质"><a href="#几个性质" class="headerlink" title="几个性质"></a>几个性质</h3><p>LCP(i,k)=min(LCP(i,j),LCP(j,k)) </p><p>LCP(i,k)=min(LCP(j,j-1)) 对于任意1&lt;i&lt;=j&lt;=k&lt;=n</p><h3 id="怎么求LCP？"><a href="#怎么求LCP？" class="headerlink" title="怎么求LCP？"></a>怎么求LCP？</h3><p>我们设$height[i]$为$LCP(i,i-1)$，$1&lt;i&lt;=n$，显然$height[1]=0;$</p><p>由上面的几个性质可得，$LCP(i,k)=min(height[j]) i+1&lt;=j&lt;=k$</p><p>那么$height$怎么求，我们要利用这些后缀之间的联系</p><p>设$h[i]=height[rk[i]]$，同样的，$height[i]=h[sa[i]]$;</p><p>那么现在来证明最关键的一条定理：</p><p>$h[i]&gt;=h[i-1]-1;$</p><p>首先我们设第$i-1$个字符串按排名来的前面的那个字符串是第k个字符串，注意$k$不一定是$i-2$，因为第$k$个字符串是按字典序排名来的$i-1$前面那个，并不是指在原字符串中位置在$i-1$前面的那个第$i-2$个字符串。</p><p>这时，依据$height[]$的定义，第k个字符串和第i-1个字符串的公共前缀自然是$height[rk[i-1]]$，现在先讨论一下第$k+1$个字符串和第$i$个字符串的关系。</p><p>第一种情况，第$k$个字符串和第$i-1$个字符串的首字符不同，那么第k+1个字符串的排名既可能在$i$的前面，也可能在i的后面，但没有关系，因为$height[rk[i-1]]$就是$0$了呀，那么无论$height[rk[i]]$是多少都会有$height[rk[i]]&gt;=height[rk[i-1]]-1$，也就是$h[i]&gt;=h[i-1]-1$。</p><p>第二种情况，第$k$个字符串和第$i-1$个字符串的首字符相同，那么由于第$k+1$个字符串就是第k个字符串去掉首字符得到的，第$i$个字符串也是第$i-1$个字符串去掉首字符得到的，那么显然第$k+1$个字符串要排在第$i$个字符串前面。同时，第$k$个字符串和第$i-1$个字符串的最长公共前缀是$height[rk[i-1]]$，</p><p>那么自然第k+1个字符串和第i个字符串的最长公共前缀就是$height[rk[i-1]]-1$。</p><p>到此为止，第二种情况的证明还没有完，我们可以试想一下，对于比第$i$个字符串的排名更靠前的那些字符串，谁和第i个字符串的相似度最高（这里说的相似度是指最长公共前缀的长度）？显然是排名紧邻第$i$个字符串的那个字符串了呀，即4sa[rank[i]-1]4。但是我们前面求得，有一个排在i前面的字符串$k+1$，$LCP(rk[i],rk[k+1])=height[rk[i-1]]-1;$</p><p>又因为$height[rk[i]]=LCP(i,i-1)&gt;=LCP(i,k+1)$</p><p>所以$height[rk[i]]&gt;=height[rk[i-1]]-1$，也即$h[i]&gt;=h[i-1]-1$.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#define rint register int</span><br><span class="line">#define inv inline void</span><br><span class="line">#define ini inline int</span><br><span class="line">#define maxn 1000050</span><br><span class="line">using namespace std;</span><br><span class="line">char s[maxn];</span><br><span class="line">int y[maxn],x[maxn],c[maxn],sa[maxn],rk[maxn],height[maxn],wt[30];</span><br><span class="line">int n,m;</span><br><span class="line">inv putout(int x)</span><br><span class="line">&#123;</span><br><span class="line">    if(!x) &#123;putchar(48);return;&#125;</span><br><span class="line">    rint l&#x3D;0;</span><br><span class="line">    while(x) wt[++l]&#x3D;x%10,x&#x2F;&#x3D;10;</span><br><span class="line">    while(l) putchar(wt[l--]+48);</span><br><span class="line">&#125;</span><br><span class="line">inv get_SA()</span><br><span class="line">&#123;</span><br><span class="line">    for (rint i&#x3D;1;i&lt;&#x3D;n;++i) ++c[x[i]&#x3D;s[i]];</span><br><span class="line">    &#x2F;&#x2F;c数组是桶 </span><br><span class="line">    &#x2F;&#x2F;x[i]是第i个元素的第一关键字 </span><br><span class="line">    for (rint i&#x3D;2;i&lt;&#x3D;m;++i) c[i]+&#x3D;c[i-1]; </span><br><span class="line">    &#x2F;&#x2F;做c的前缀和，我们就可以得出每个关键字最多是在第几名 </span><br><span class="line">    for (rint i&#x3D;n;i&gt;&#x3D;1;--i) sa[c[x[i]]--]&#x3D;i; </span><br><span class="line">    for (rint k&#x3D;1;k&lt;&#x3D;n;k&lt;&lt;&#x3D;1)</span><br><span class="line">    &#123;</span><br><span class="line">        rint num&#x3D;0;</span><br><span class="line">        for (rint i&#x3D;n-k+1;i&lt;&#x3D;n;++i) y[++num]&#x3D;i;</span><br><span class="line">        &#x2F;&#x2F;y[i]表示第二关键字排名为i的数，第一关键字的位置 </span><br><span class="line">        &#x2F;&#x2F;第n-k+1到第n位是没有第二关键字的 所以排名在最前面 </span><br><span class="line">        for (rint i&#x3D;1;i&lt;&#x3D;n;++i) if (sa[i]&gt;k) y[++num]&#x3D;sa[i]-k;</span><br><span class="line">        &#x2F;&#x2F;排名为i的数 在数组中是否在第k位以后</span><br><span class="line">        &#x2F;&#x2F;如果满足(sa[i]&gt;k) 那么它可以作为别人的第二关键字，就把它的第一关键字的位置添加进y就行了</span><br><span class="line">        &#x2F;&#x2F;所以i枚举的是第二关键字的排名，第二关键字靠前的先入队 </span><br><span class="line">        for (rint i&#x3D;1;i&lt;&#x3D;m;++i) c[i]&#x3D;0;</span><br><span class="line">        &#x2F;&#x2F;初始化c桶 </span><br><span class="line">        for (rint i&#x3D;1;i&lt;&#x3D;n;++i) ++c[x[i]];</span><br><span class="line">        &#x2F;&#x2F;因为上一次循环已经算出了这次的第一关键字 所以直接加就行了 </span><br><span class="line">        for (rint i&#x3D;2;i&lt;&#x3D;m;++i) c[i]+&#x3D;c[i-1];&#x2F;&#x2F;第一关键字排名为1~i的数有多少个 </span><br><span class="line">        for (rint i&#x3D;n;i&gt;&#x3D;1;--i) sa[c[x[y[i]]]--]&#x3D;y[i],y[i]&#x3D;0;</span><br><span class="line">        &#x2F;&#x2F;因为y的顺序是按照第二关键字的顺序来排的 </span><br><span class="line">        &#x2F;&#x2F;第二关键字靠后的，在同一个第一关键字桶中排名越靠后 </span><br><span class="line">        &#x2F;&#x2F;基数排序 </span><br><span class="line">        swap(x,y);</span><br><span class="line">        &#x2F;&#x2F;这里不用想太多，因为要生成新的x时要用到旧的，就把旧的复制下来，没别的意思 </span><br><span class="line">        x[sa[1]]&#x3D;1;num&#x3D;1;</span><br><span class="line">        for (rint i&#x3D;2;i&lt;&#x3D;n;++i)</span><br><span class="line">            x[sa[i]]&#x3D;(y[sa[i]]&#x3D;&#x3D;y[sa[i-1]] &amp;&amp; y[sa[i]+k]&#x3D;&#x3D;y[sa[i-1]+k]) ? num : ++num;</span><br><span class="line">        &#x2F;&#x2F;因为sa[i]已经排好序了，所以可以按排名枚举，生成下一次的第一关键字 </span><br><span class="line">        if (num&#x3D;&#x3D;n) break;</span><br><span class="line">        m&#x3D;num;</span><br><span class="line">        &#x2F;&#x2F;这里就不用那个122了，因为都有新的编号了 </span><br><span class="line">    &#125;</span><br><span class="line">    for (rint i&#x3D;1;i&lt;&#x3D;n;++i) putout(sa[i]),putchar(&#39; &#39;);</span><br><span class="line">&#125;</span><br><span class="line">inv get_height()</span><br><span class="line">&#123;</span><br><span class="line">    rint k&#x3D;0;</span><br><span class="line">    for (rint i&#x3D;1;i&lt;&#x3D;n;++i) rk[sa[i]]&#x3D;i;</span><br><span class="line">    for (rint i&#x3D;1;i&lt;&#x3D;n;++i)  </span><br><span class="line">    &#123;</span><br><span class="line">        if (rk[i]&#x3D;&#x3D;1) continue;&#x2F;&#x2F;第一名height为0 </span><br><span class="line">        if (k) --k;&#x2F;&#x2F;h[i]&gt;&#x3D;h[i-1]+1;</span><br><span class="line">        rint j&#x3D;sa[rk[i]-1];</span><br><span class="line">        while (j+k&lt;&#x3D;n &amp;&amp; i+k&lt;&#x3D;n &amp;&amp; s[i+k]&#x3D;&#x3D;s[j+k]) ++k;</span><br><span class="line">        height[rk[i]]&#x3D;k;&#x2F;&#x2F;h[i]&#x3D;height[rk[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    putchar(10);for (rint i&#x3D;1;i&lt;&#x3D;n;++i) putout(height[i]),putchar(&#39; &#39;);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    gets(s+1);</span><br><span class="line">    n&#x3D;strlen(s+1);m&#x3D;122;</span><br><span class="line">    &#x2F;&#x2F;因为这个题不读入n和m所以要自己设</span><br><span class="line">    &#x2F;&#x2F;n表示原字符串长度，m表示字符个数，ascll(&#39;z&#39;)&#x3D;122 </span><br><span class="line">    &#x2F;&#x2F;我们第一次读入字符直接不用转化，按原来的ascll码来就可以了 </span><br><span class="line">    &#x2F;&#x2F;因为转化数字和大小写字母还得分类讨论，怪麻烦的 </span><br><span class="line">    get_SA();</span><br><span class="line">    &#x2F;&#x2F;get_height();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>&lt;img src=&quot;https://img-blog.csdn.net/20151129213701642&quot; width=256 height=256 /&gt;</code></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单源最短路算法——Dijkstra</title>
      <link href="/Dijkstra/"/>
      <url>/Dijkstra/</url>
      
        <content type="html"><![CDATA[<ul><li>提示：本文为作者早期时所写，部分内容可能描述不清，过于复杂，包含错误等。</li></ul><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>$ \text{Dijkstra} ​$ 算法用于解决单源最短路问题的算法之一，是图论较为基础的部分。</p><h2 id="实现方法："><a href="#实现方法：" class="headerlink" title="实现方法："></a>实现方法：</h2><p><strong>1.</strong>定义ans[100000]，ans[i]代表到达i点的最小花费</p><p><strong>2.</strong>定义bool数组visit，代表是否来过这里</p><p><strong>2.</strong>ans[起点]=0,其余的赋值为inf</p><p><strong>3.</strong>定义一个curr变量，visit[current]=1（访问过），代表现在的位置，初始值为起点。</p><p><strong>4.</strong>列举所有与curr相联通的的点，将这些点(i)的ans值更新：</p><p>$ ans[i]=min(ans[i],ans[curr]+ ​$ 到这些点需要的花费 $)​$</p><p><strong>5.</strong> 列举所有访问过的的点，找到ans值最小的点，赋值给curr，visit[current]=1（访问过）</p><p><strong>6</strong> 所有点都访问过（visit[i]都==1），程序结束。此时，ans[i]代表从起点到i的最短路径</p><hr><h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> vis[<span class="number">1000000</span>];<span class="comment">//是否访问过</span></span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">1000000</span>];</span><br><span class="line"><span class="keyword">int</span> curr=起点;</span><br><span class="line"><span class="built_in">memset</span>(ans,<span class="number">0x7fffffff</span>,<span class="keyword">sizeof</span>(ans))</span><br><span class="line"><span class="keyword">while</span>(vis[curr]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">vis[curr]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i;列举所有curr连通的点）</span><br><span class="line">    &#123;</span><br><span class="line">    ans[i]=min(ans[i],ans[curr]+k)<span class="comment">//k代表从curr点到i点的最短路</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> minn=<span class="number">2147483647</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)<span class="comment">//列举所有点</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">if</span>(vis[i]==<span class="number">1</span>&amp;&amp;ans[i]&lt;minn)<span class="comment">//访问过且小</span></span><br><span class="line">        &#123;</span><br><span class="line">        minn=ans[i];<span class="comment">//更新最小值</span></span><br><span class="line">            curr=i;<span class="comment">//更新下一个点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="存图方式"><a href="#存图方式" class="headerlink" title="存图方式"></a>存图方式</h2><p>链式前向星<br><strong>以下是关于链式前向星的介绍 ，会的可以跳过：</strong></p><h2 id="边的存储"><a href="#边的存储" class="headerlink" title="边的存储"></a>边的存储</h2><p>这种存图方式只需要开一个数组存储每个点引出的第一条边，然后存储每个点作为起点的每条边，这样就可以做到不重不漏。</p><p>在链式前向星存图中，我们需要定义一个结构体：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EDGE</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">&#125;edge[<span class="number">1000000</span>];</span><br></pre></td></tr></table></figure><p>和一个数组：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> head[<span class="number">1000000</span>];</span><br></pre></td></tr></table></figure><p>和一个变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;<span class="comment">//指针</span></span><br></pre></td></tr></table></figure><p>你会发现竟然没存起点！！其实起点是用$head$存的</p><h3 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h3><p> <img src="https://cdn.luogu.org/upload/pic/43957.png" alt=""></p><p>如图：这样的一个有向图，输入是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure><h3 id="逐步分析："><a href="#逐步分析：" class="headerlink" title="逐步分析："></a>逐步分析：</h3><h4 id="1-输入1-2，代表1连向2。"><a href="#1-输入1-2，代表1连向2。" class="headerlink" title="1.输入1 2，代表1连向2。"></a>1.输入1 2，代表1连向2。</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cnt++;<span class="comment">//作为结构体下标，没有意义</span></span><br><span class="line">head[<span class="number">1</span>]=cnt;<span class="comment">//结点1的第一个儿子存在了edge[cnt]里面</span></span><br><span class="line">edge[cnt].to=<span class="number">2</span>;结点<span class="number">1</span>的儿子是<span class="number">2</span></span><br></pre></td></tr></table></figure><p>此时：<br>$cnt=1$</p><table><thead><tr><th align="center">$edge$</th><th align="center">$cnt=1$</th><th align="center">$cnt=2$</th><th align="center">$ cnt=3$</th><th align="center">$cnt=4$</th></tr></thead><tbody><tr><td align="center">$to $</td><td align="center">$2$</td><td align="center">$0$</td><td align="center">$ 0$</td><td align="center">$0$</td></tr><tr><td align="center">$next$</td><td align="center">$ 0 $</td><td align="center">$0 $</td><td align="center">$0$</td><td align="center">$0$</td></tr></tbody></table><table><thead><tr><th align="center">$head $</th><th align="center">下标$=1 $</th><th align="center">下标$=2$</th><th align="center">下标$=3 $</th><th align="center">下标$=4 $</th></tr></thead><tbody><tr><td align="center">值</td><td align="center">$1 $</td><td align="center">$ 0 $</td><td align="center">$ 0 $</td><td align="center">$ 0 $</td></tr></tbody></table><h4 id="2-输入1-3，代表1连向3。"><a href="#2-输入1-3，代表1连向3。" class="headerlink" title="2.输入1 3，代表1连向3。"></a>2.输入1 3，代表1连向3。</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cnt++;</span><br><span class="line">head[<span class="number">1</span>]=cnt;</span><br><span class="line">edge[cnt].to=<span class="number">3</span>;结点<span class="number">1</span>的儿子是<span class="number">3</span></span><br><span class="line"><span class="comment">//这时,3成为了结点1的儿子，不过2被挤了下去...</span></span><br><span class="line"><span class="comment">//所以要引入结构体中next元素，记录：3还有个兄弟（next）是2</span></span><br><span class="line"><span class="comment">//所以代码要换成：</span></span><br><span class="line">cnt++;</span><br><span class="line">edge[cnt].to=<span class="number">3</span>;<span class="comment">//结点1连向3</span></span><br><span class="line">edge[cnt].next=head[<span class="number">1</span>];<span class="comment">//3的兄弟是2</span></span><br><span class="line">head[<span class="number">1</span>]=cnt;<span class="comment">//更新head</span></span><br></pre></td></tr></table></figure><p>此时：<br>$cnt=2$</p><table><thead><tr><th align="center">$edge$</th><th align="center">$cnt=1$</th><th align="center">$cnt=2$</th><th align="center">$ cnt=3$</th><th align="center">$cnt=4$</th></tr></thead><tbody><tr><td align="center">$to $</td><td align="center">$2$</td><td align="center">$3$</td><td align="center">$ 0$</td><td align="center">$0$</td></tr><tr><td align="center">$next$</td><td align="center">$ 0 $</td><td align="center">$1 $</td><td align="center">$0$</td><td align="center">$0$</td></tr></tbody></table><table><thead><tr><th align="center">$head $</th><th align="center">下标$=1 $</th><th align="center">下标$=2$</th><th align="center">下标$=3 $</th><th align="center">下标$=4 $</th></tr></thead><tbody><tr><td align="center">值</td><td align="center">$2 $</td><td align="center">$ 0 $</td><td align="center">$ 0 $</td><td align="center">$ 0 $</td></tr></tbody></table><h4 id="3-输入1-4，代表1连向4。"><a href="#3-输入1-4，代表1连向4。" class="headerlink" title="3.输入1 4，代表1连向4。"></a>3.输入1 4，代表1连向4。</h4><p>此时：<br>$cnt=3$</p><table><thead><tr><th align="center">$edge$</th><th align="center">$cnt=1$</th><th align="center">$cnt=2$</th><th align="center">$ cnt=3$</th><th align="center">$cnt=4$</th></tr></thead><tbody><tr><td align="center">$to $</td><td align="center">$2$</td><td align="center">$3$</td><td align="center">$ 4$</td><td align="center">$0$</td></tr><tr><td align="center">$next$</td><td align="center">$ 0 $</td><td align="center">$1 $</td><td align="center">$2$</td><td align="center">$0$</td></tr></tbody></table><table><thead><tr><th align="center">$head $</th><th align="center">下标$=1 $</th><th align="center">下标$=2$</th><th align="center">下标$=3 $</th><th align="center">下标$=4 $</th></tr></thead><tbody><tr><td align="center">值</td><td align="center">$3 $</td><td align="center">$ 0 $</td><td align="center">$ 0 $</td><td align="center">$ 0 $</td></tr></tbody></table><h4 id="4-输入2-3，代表2连向3。"><a href="#4-输入2-3，代表2连向3。" class="headerlink" title="4.输入2 3，代表2连向3。"></a>4.输入2 3，代表2连向3。</h4><p>此时：<br>$cnt=4$</p><table><thead><tr><th align="center">$edge$</th><th align="center">$cnt=1$</th><th align="center">$cnt=2$</th><th align="center">$ cnt=3$</th><th align="center">$cnt=4$</th></tr></thead><tbody><tr><td align="center">$to $</td><td align="center">$2$</td><td align="center">$3$</td><td align="center">$ 4$</td><td align="center">$3$</td></tr><tr><td align="center">$next$</td><td align="center">$ 0 $</td><td align="center">$1 $</td><td align="center">$2$</td><td align="center">$0$</td></tr></tbody></table><table><thead><tr><th align="center">$head $</th><th align="center">下标$=1 $</th><th align="center">下标$=2$</th><th align="center">下标$=3 $</th><th align="center">下标$=4 $</th></tr></thead><tbody><tr><td align="center">值</td><td align="center">$3 $</td><td align="center">$ 4 $</td><td align="center">$ 0 $</td><td align="center">$ 0 $</td></tr></tbody></table><h3 id="注意：-edge-cnt-next-和-head-1-存贮的都是结构体下标（即-cnt-的值）若要访问指向的边的编号，分别用-edge-edge-cnt-next-to-，-edge-head-1-to"><a href="#注意：-edge-cnt-next-和-head-1-存贮的都是结构体下标（即-cnt-的值）若要访问指向的边的编号，分别用-edge-edge-cnt-next-to-，-edge-head-1-to" class="headerlink" title="注意：$edge[cnt].next$ 和$head[1]$存贮的都是结构体下标（即$cnt$的值）若要访问指向的边的编号，分别用$edge[edge[cnt].next].to$，$edge[head[1]].to$"></a>注意：$edge[cnt].next$ 和$head[1]$存贮的都是结构体下标（即$cnt$的值）若要访问指向的边的编号，分别用$edge[edge[cnt].next].to$，$edge[head[1]].to$</h3><h4 id="若需要记录权值，在结构体中加入一个元素即可"><a href="#若需要记录权值，在结构体中加入一个元素即可" class="headerlink" title="若需要记录权值，在结构体中加入一个元素即可"></a>若需要记录权值，在结构体中加入一个元素即可</h4><p>代码：(带权值）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> wei;</span><br><span class="line">&#125;edge[MAXM];</span><br><span class="line"><span class="keyword">int</span> head[MAXN];<span class="comment">//head[i]为i点的第一条边</span></span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span> <span class="comment">//起点，终点，权值 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[++cnt].next=head[u];<span class="comment">//更新cnt</span></span><br><span class="line">    edge[cnt].to=v;</span><br><span class="line">    edge[cnt].w=w;</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,wei;</span><br><span class="line">        addedge(a,b,wei);</span><br><span class="line">        <span class="comment">//如果是无向图，还要addedge(b,a,wei);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p> 这里的next指的是遍历时的下一条边，head指的是遍历时的第一条边，而存边时相当于反过来操作，所以next记录上一条边，而head记录最后一条边。</p><hr><h2 id="边的遍历"><a href="#边的遍历" class="headerlink" title="边的遍历"></a>边的遍历</h2><p>在遍历以x为起点的所有边时，只需要这样就行</p><pre><code>for(int i=head[x];i!=0;i=edge[i].next)</code></pre><p>这个循环的结束条件是i等于0，因为最后一条边，也就是存边时第一条边，在把head值存进next时，head还没有更新过，也就是0。所以当next返回0时，就说明这些边遍历完毕了。</p><hr><h2 id="优势与特点"><a href="#优势与特点" class="headerlink" title="优势与特点"></a>优势与特点</h2><p>既可以存图，也可以存树，比起邻接矩阵，链式前向星的空间复杂度是O（n），大大节省了存储空间，因为按边存储省掉了很多两点无边的空间。并且在遍历的时候，那些与起点无边相连的点也不需要进行处理，可以说时间和空间都占优势，这就是被OIer们广泛使用的原因。</p><hr><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> head[<span class="number">100000</span>],cnt;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans[<span class="number">1000000</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">1000000</span>];</span><br><span class="line"><span class="keyword">int</span> m,n,s;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> to;</span><br><span class="line"><span class="keyword">int</span> nextt;</span><br><span class="line"><span class="keyword">int</span> wei;</span><br><span class="line">&#125;edge[<span class="number">1000000</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">edge[++cnt].to=y;</span><br><span class="line">edge[cnt].wei=z;</span><br><span class="line">edge[cnt].nextt=head[x];</span><br><span class="line">head[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;m&gt;&gt;n&gt;&gt;s;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">ans[i]=<span class="number">2147483647</span>;</span><br><span class="line">&#125;</span><br><span class="line">ans[s]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> a,b,c;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">addedge(a,b,c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> pos=s;</span><br><span class="line"><span class="keyword">while</span>(vis[pos]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> minn=<span class="number">2147483647</span>;</span><br><span class="line">vis[pos]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[pos];i!=<span class="number">0</span>;i=edge[i].nextt)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!vis[edge[i].to]&amp;&amp;ans[edge[i].to]&gt;ans[pos]+edge[i].wei)</span><br><span class="line">&#123;</span><br><span class="line">ans[edge[i].to]=ans[pos]+edge[i].wei;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(ans[i]&lt;minn&amp;&amp;vis[i]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">minn=ans[i];</span><br><span class="line">pos=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans[i]&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是Dijkstra的基础介绍，上面的这份代码是不加优化的Dijkstra，能通过<br><a href="https://www.luogu.org/problemnew/show/P3371" target="_blank" rel="noopener">P3371单源最短路径（弱化版）</a><br>不过在这道题中会TLE。</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>在上面第五步中：<br><code>5. 列举所有访问过的的点，找到ans值最小的点</code></p><p>这一步由于每次都要遍历一遍所有点，复杂度为$O(n)$</p><p>不过可以用堆（STL：优先队列）进行优化，复杂度为$O(logn)$</p><h4 id="简单介绍优先队列"><a href="#简单介绍优先队列" class="headerlink" title="简单介绍优先队列"></a>简单介绍优先队列</h4><p>一种数据结构，支持找出数列中最大值，弹出最大值</p><p>重载运算符后还可以维护最小值</p><ul><li>代码：</li></ul><p>头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br></pre></td></tr></table></figure><p>定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; q;</span><br></pre></td></tr></table></figure><p>加入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q.push(a);</span><br></pre></td></tr></table></figure><p>弹出最大值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q.pop()</span><br></pre></td></tr></table></figure><p>查询最大值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q.top()</span><br></pre></td></tr></table></figure><p>详细的可看<a href="https://www.luogu.org/problemnew/show/P3378" target="_blank" rel="noopener">P3378 【模板】堆</a></p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>对以上代码加入堆优化：</p><p>由于每个点有两个值需要存储（$ans$值，点的编号）,所以要用结构体</p><p>由于要找最小的点，所以用优先队列时需要重载运算符：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ans;<span class="comment">//ans值</span></span><br><span class="line">    <span class="keyword">int</span> id;<span class="comment">//点编号</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> node &amp;x)<span class="keyword">const</span><span class="comment">//重载运算符</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x.ans&lt;ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> head[<span class="number">100000</span>],cnt;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans[<span class="number">1000000</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">1000000</span>];</span><br><span class="line"><span class="keyword">int</span> m,n,s;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> to;</span><br><span class="line"><span class="keyword">int</span> nextt;</span><br><span class="line"><span class="keyword">int</span> wei;</span><br><span class="line">&#125;edge[<span class="number">1000000</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">priority</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> priority &amp;x)<span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x.ans&lt;ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">edge[++cnt].to=y;</span><br><span class="line">edge[cnt].wei=z;</span><br><span class="line">edge[cnt].nextt=head[x];</span><br><span class="line">head[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;priority&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;m&gt;&gt;n&gt;&gt;s;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">ans[i]=<span class="number">2147483647</span>;</span><br><span class="line">&#125;</span><br><span class="line">ans[s]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> a,b,c;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">addedge(a,b,c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> u;</span><br><span class="line">q.push((priority)&#123;<span class="number">0</span>,s&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        priority temp=q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        u=temp.id;</span><br><span class="line">        <span class="keyword">if</span>(!vis[u])</span><br><span class="line">        &#123;</span><br><span class="line">        vis[u]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=edge[i].nextt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v=edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(ans[v]&gt;ans[u]+edge[i].wei)</span><br><span class="line">            &#123;</span><br><span class="line">                ans[v]=ans[u]+edge[i].wei;</span><br><span class="line">                <span class="keyword">if</span>(!vis[v])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push((priority)&#123;ans[v],v&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans[i]&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 最短路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最短路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客搭建</title>
      <link href="/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"/>
      <url>/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="搭建记录"><a href="#搭建记录" class="headerlink" title="搭建记录"></a>搭建记录</h1><h2 id="修改博客内容"><a href="#修改博客内容" class="headerlink" title="修改博客内容"></a>修改博客内容</h2><h3 id="首次使用"><a href="#首次使用" class="headerlink" title="首次使用"></a>首次使用</h3><p>1.打开安装包安装Git，Node</p><p>2.下载hexo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org</span><br><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure><p>3.安装hexo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>4.配置github</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email &quot;zfMMG9000@163.com&quot;</span><br><span class="line">git config --global user.name &quot;2018haha&quot;</span><br></pre></td></tr></table></figure><p>5.绑定github密匙</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure><p>并把路径中<code>id_rsa.pub</code>用记事本打开，复制到github的key上</p><h3 id="更改博客设置"><a href="#更改博客设置" class="headerlink" title="更改博客设置"></a>更改博客设置</h3><p>有两个位置：</p><p>hexo设置<code>\_config.yml</code></p><p>next主题设置<code>\themes\hexo-theme-next-6.7.0\_config.yml</code></p><p>详细请百度</p><h3 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h3><pre><code>hexo n &quot;文章名&quot;</code></pre><p>在<code>\source\_posts</code>中找到文件并编辑</p><p>开头几个参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: </span><br><span class="line">categories: 日志</span><br><span class="line">mathjax: true</span><br><span class="line">tags: [记录,笔记,日志]</span><br><span class="line">keywords: [1,2]</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h2 id="预览，发布"><a href="#预览，发布" class="headerlink" title="预览，发布"></a>预览，发布</h2><p>预览：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>发布：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
