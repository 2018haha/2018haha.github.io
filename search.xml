<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[单源最短路算法——Dijkstra]]></title>
    <url>%2F2019%2F11%2F23%2FDijkstra%2F</url>
    <content type="text"><![CDATA[提示：本文为作者早期时所写，部分内容可能描述不清，过于复杂，包含错误等。 # 前言$ \text{Dijkstra} $ 算法用于解决单源最短路问题的算法之一，是图论较为基础的部分。 实现方法：1.定义ans[100000]，ans[i]代表到达i点的最小花费 2.定义bool数组visit，代表是否来过这里 2.ans[起点]=0,其余的赋值为inf 3.定义一个curr变量，visit[current]=1（访问过），代表现在的位置，初始值为起点。 4.列举所有与curr相联通的的点，将这些点(i)的ans值更新： $ ans[i]=min(ans[i],ans[curr]+ ​$ 到这些点需要的花费 $)​$ 5. 列举所有访问过的的点，找到ans值最小的点，赋值给curr，visit[current]=1（访问过） 6 所有点都访问过（visit[i]都==1），程序结束。此时，ans[i]代表从起点到i的最短路径 伪代码123456789101112131415161718192021bool vis[1000000];//是否访问过int ans[1000000];int curr=起点;memset(ans,0x7fffffff,sizeof(ans))while(vis[curr]==0)&#123; vis[curr]=1; for(int i;列举所有curr连通的点） &#123; ans[i]=min(ans[i],ans[curr]+k)//k代表从curr点到i点的最短路 &#125; int minn=2147483647; for(int i=1;i&lt;=m;i++)//列举所有点 &#123; if(vis[i]==1&amp;&amp;ans[i]&lt;minn)//访问过且小 &#123; minn=ans[i];//更新最小值 curr=i;//更新下一个点 &#125; &#125;&#125; 存图方式链式前向星以下是关于链式前向星的介绍 ，会的可以跳过： 边的存储这种存图方式只需要开一个数组存储每个点引出的第一条边，然后存储每个点作为起点的每条边，这样就可以做到不重不漏。 在链式前向星存图中，我们需要定义一个结构体：12345struct EDGE &#123; int next; int to;&#125;edge[1000000]; 和一个数组：1int head[1000000]; 和一个变量：1int cnt=0;//指针 你会发现竟然没存起点！！其实起点是用$head$存的 举例： 如图：这样的一个有向图，输入是： 12341 21 31 42 3 逐步分析：1.输入1 2，代表1连向2。123cnt++;//作为结构体下标，没有意义head[1]=cnt;//结点1的第一个儿子存在了edge[cnt]里面edge[cnt].to=2;结点1的儿子是2 此时：$cnt=1$ $edge$ $cnt=1$ $cnt=2$ $ cnt=3$ $cnt=4$ $to $ $2$ $0$ $ 0$ $0$ $next$ $ 0 $ $0 $ $0$ $0$ $head $ 下标$=1 $ 下标$=2$ 下标$=3 $ 下标$=4 $ 值 $1 $ $ 0 $ $ 0 $ $ 0 $ 2.输入1 3，代表1连向3。12345678910cnt++;head[1]=cnt;edge[cnt].to=3;结点1的儿子是3//这时,3成为了结点1的儿子，不过2被挤了下去...//所以要引入结构体中next元素，记录：3还有个兄弟（next）是2//所以代码要换成：cnt++;edge[cnt].to=3;//结点1连向3edge[cnt].next=head[1];//3的兄弟是2head[1]=cnt;//更新head 此时：$cnt=2$ $edge$ $cnt=1$ $cnt=2$ $ cnt=3$ $cnt=4$ $to $ $2$ $3$ $ 0$ $0$ $next$ $ 0 $ $1 $ $0$ $0$ $head $ 下标$=1 $ 下标$=2$ 下标$=3 $ 下标$=4 $ 值 $2 $ $ 0 $ $ 0 $ $ 0 $ 3.输入1 4，代表1连向4。此时：$cnt=3$ $edge$ $cnt=1$ $cnt=2$ $ cnt=3$ $cnt=4$ $to $ $2$ $3$ $ 4$ $0$ $next$ $ 0 $ $1 $ $2$ $0$ $head $ 下标$=1 $ 下标$=2$ 下标$=3 $ 下标$=4 $ 值 $3 $ $ 0 $ $ 0 $ $ 0 $ 4.输入2 3，代表2连向3。此时：$cnt=4$ $edge$ $cnt=1$ $cnt=2$ $ cnt=3$ $cnt=4$ $to $ $2$ $3$ $ 4$ $3$ $next$ $ 0 $ $1 $ $2$ $0$ $head $ 下标$=1 $ 下标$=2$ 下标$=3 $ 下标$=4 $ 值 $3 $ $ 4 $ $ 0 $ $ 0 $ 注意：$edge[cnt].next$ 和$head[1]$存贮的都是结构体下标（即$cnt$的值）若要访问指向的边的编号，分别用$edge[edge[cnt].next].to$，$edge[head[1]].to$若需要记录权值，在结构体中加入一个元素即可代码：(带权值）123456789101112131415161718192021222324252627#include&lt;iostream&gt;using namespace std;struct edge &#123; int next; int to; int wei;&#125;edge[MAXM];int head[MAXN];//head[i]为i点的第一条边int cnt=0;void addedge(int u,int v,int w) //起点，终点，权值 &#123; edge[++cnt].next=head[u];//更新cnt edge[cnt].to=v; edge[cnt].w=w; head[u]=cnt;&#125;int main()&#123; int n; for(int i=1;i&lt;=n;i++) &#123; int a,b,wei; addedge(a,b,wei); //如果是无向图，还要addedge(b,a,wei); &#125;&#125; 注意： 这里的next指的是遍历时的下一条边，head指的是遍历时的第一条边，而存边时相当于反过来操作，所以next记录上一条边，而head记录最后一条边。 边的遍历在遍历以x为起点的所有边时，只需要这样就行 for(int i=head[x];i!=0;i=edge[i].next) 这个循环的结束条件是i等于0，因为最后一条边，也就是存边时第一条边，在把head值存进next时，head还没有更新过，也就是0。所以当next返回0时，就说明这些边遍历完毕了。 优势与特点既可以存图，也可以存树，比起邻接矩阵，链式前向星的空间复杂度是O（n），大大节省了存储空间，因为按边存储省掉了很多两点无边的空间。并且在遍历的时候，那些与起点无边相连的点也不需要进行处理，可以说时间和空间都占优势，这就是被OIer们广泛使用的原因。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;using namespace std;int head[100000],cnt;long long ans[1000000];bool vis[1000000];int m,n,s;struct edge&#123; int to; int nextt; int wei;&#125;edge[1000000];void addedge(int x,int y,int z)&#123; edge[++cnt].to=y; edge[cnt].wei=z; edge[cnt].nextt=head[x]; head[x]=cnt;&#125;int main()&#123; cin&gt;&gt;m&gt;&gt;n&gt;&gt;s; for(int i=1;i&lt;=n;i++) &#123; ans[i]=2147483647; &#125; ans[s]=0; for(int i=1;i&lt;=n;i++) &#123; int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; addedge(a,b,c); &#125; int pos=s; while(vis[pos]==0) &#123; long long minn=2147483647; vis[pos]=1; for(int i=head[pos];i!=0;i=edge[i].nextt) &#123; if(!vis[edge[i].to]&amp;&amp;ans[edge[i].to]&gt;ans[pos]+edge[i].wei) &#123; ans[edge[i].to]=ans[pos]+edge[i].wei; &#125; &#125; for(int i=1;i&lt;=m;i++) &#123; if(ans[i]&lt;minn&amp;&amp;vis[i]==0) &#123; minn=ans[i]; pos=i; &#125; &#125; &#125; for(int i=1;i&lt;=m;i++) &#123; cout&lt;&lt;ans[i]&lt;&lt;' '; &#125;&#125; 以上是Dijkstra的基础介绍，上面的这份代码是不加优化的Dijkstra，能通过P3371单源最短路径（弱化版）不过在这道题中会TLE。 优化在上面第五步中：5. 列举所有访问过的的点，找到ans值最小的点 这一步由于每次都要遍历一遍所有点，复杂度为$O(n)$ 不过可以用堆（STL：优先队列）进行优化，复杂度为$O(logn)$ 简单介绍优先队列一种数据结构，支持找出数列中最大值，弹出最大值 重载运算符后还可以维护最小值 代码： 头文件1#include&lt;queue&gt; 定义1priority_queue&lt;int&gt; q; 加入1q.push(a); 弹出最大值1q.pop() 查询最大值1q.top() 详细的可看P3378 【模板】堆 代码对以上代码加入堆优化： 由于每个点有两个值需要存储（$ans$值，点的编号）,所以要用结构体 由于要找最小的点，所以用优先队列时需要重载运算符：123456789struct node&#123; int ans;//ans值 int id;//点编号 bool operator &lt;(const node &amp;x)const//重载运算符 &#123; return x.ans&lt;ans; &#125;&#125;; 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;int head[100000],cnt;long long ans[1000000];bool vis[1000000];int m,n,s;struct edge&#123; int to; int nextt; int wei;&#125;edge[1000000];struct priority&#123; int ans; int id; bool operator &lt;(const priority &amp;x)const &#123; return x.ans&lt;ans; &#125;&#125;;void addedge(int x,int y,int z)&#123; edge[++cnt].to=y; edge[cnt].wei=z; edge[cnt].nextt=head[x]; head[x]=cnt;&#125;priority_queue&lt;priority&gt; q;int main()&#123; cin&gt;&gt;m&gt;&gt;n&gt;&gt;s; for(int i=1;i&lt;=n;i++) &#123; ans[i]=2147483647; &#125; ans[s]=0; for(int i=1;i&lt;=n;i++) &#123; int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; addedge(a,b,c); &#125; int u; q.push((priority)&#123;0,s&#125;); while(!q.empty()) &#123; priority temp=q.top(); q.pop(); u=temp.id; if(!vis[u]) &#123; vis[u]=1; for(int i=head[u];i;i=edge[i].nextt) &#123; int v=edge[i].to; if(ans[v]&gt;ans[u]+edge[i].wei) &#123; ans[v]=ans[u]+edge[i].wei; if(!vis[v]) &#123; q.push((priority)&#123;ans[v],v&#125;); &#125; &#125; &#125; &#125; &#125; for(int i=1;i&lt;=m;i++) &#123; cout&lt;&lt;ans[i]&lt;&lt;' '; &#125;&#125; ####]]></content>
      <categories>
        <category>算法</category>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础动态规划汇总]]></title>
    <url>%2F2019%2F11%2F23%2F%E5%9F%BA%E7%A1%80%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[前言动态规划是OI种经典的算法之一，用途较为广泛。 背包背包问题特点：每种物品都有一个价值val和体积wei. 你现在有一个背包容积为V,你想用一些物品装背包使得物品总价值最大. 0-1背包实现方法状态转移方程：$dp[i][j]=max(dp[i-1][j],dp[i-1][j-wei[i]]+val[i]);$$i$代表一共选几个物品，$j$代表背包剩余容量，$wei[i]$代表i占容量，$val[i]$代表i的价值 由于$dp[i][ ]$只与$dp[i-1][ ]$有关，可以用滚动数组压掉第一维 或者：只开一个数组，直接在原数组上修改 由于$dp[i][j]$只与$dp[i-1]m$有关，如果仍然从前向后枚举j，会更改前面的值，对后续决策产生影响，所以我们需要从后往前枚举$j$，更新$j$的值 代码：1234567for(int i=1;i&lt;=n;i++)//枚举装几个物品&#123; for(int j=v;j&gt;=wei[i];j--)//枚举体积 &#123; dp[j]=max(dp[j],dp[j-wei[i]]+w[i]); &#125;&#125; 典型题：P1048 采药1234567891011121314151617181920212223242526#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int wei[105], val[105];int dp[1005];int main()&#123; int t,m,res=-1; scanf("%d%d",&amp;t,&amp;m); for(int i=1;i&lt;=m;i++) &#123; scanf("%d%d",&amp;wei[i],&amp;val[i]); &#125; for(int i=1;i&lt;=m;i++) &#123; for(int j=t;j&gt;=0;j--) &#123; if(j&gt;=wei[i]) &#123; dp[j]=max(dp[j-wei[i]]+val[i], dp[j]); &#125; &#125; &#125; printf("%d",dp[t]); return 0;&#125; 完全背包特点：此类背包问题与01背包不同的是：我们的每种物品有无限多个,可重复选取。 实现方法01背包中，为了防止更新时对后续更新产生影响，$t$要从后往前枚举。而完全背包只需改为从前往后即可。 代码：1234567for(int i=1;i&lt;=n;i++)//枚举装几个物品&#123; for(int j=wei[i];j&lt;=v;j++)//枚举体积 &#123; dp[j]=max(dp[j],dp[j-wei[i]]+w[i]); &#125;&#125; 典型题：P1616 疯狂的采药1234567891011121314151617181920212223#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;long long f[1000001],v[1000001],h[1000001];long long max(long long a,long long b)&#123; if(a&gt;b) return a; else return b;&#125;int main()&#123; long long i,j,m,n; scanf("%ld %ld",&amp;m,&amp;n); for(i=1;i&lt;=n;i++) scanf("%ld %ld",&amp;h[i],&amp;v[i]); for(i=1;i&lt;=n;i++) for(j=h[i];j&lt;=m;j++) f[j]=max(f[j],f[j-h[i]]+v[i]); printf("%ld\n",f[m]); return 0;&#125; 多重背包线性动归线性动归特点： 只在一个数列上的dp。 实现方法用$dp[i]$代表到$i$为止最优策略。 典型题最长不下降子序列：给定一个数列，求出最长不下降子序列的长度。 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;using namespace std;int a[100000];int dp[1000000];int main()&#123; int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;a[i]; dp[i]=1; &#125; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;i;j++) &#123; if(a[i]&gt;=a[j])//可以更新 &#123; dp[i]=max(dp[i],dp[j]+1);//取所有可以更新的情况中，更新后的最优决策（即最大值） &#125; &#125; &#125; int ans=0; for(int i=1;i&lt;=n;i++) &#123; ans=max(ans,dp[i]); &#125; cout&lt;&lt;ans; return 0; &#125; 变形：P1091 合唱队形 1234567891011121314151617181920212223#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;int n,a[105],f[2][105],ans;int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; for(int i=1;i&lt;=n;i++) for(int j=0;j&lt;i;j++) if(a[i]&gt;a[j]) f[0][i]=max(f[0][i],f[0][j]+1); a[n+1]=0; for(int i=n;i;i--) for(int j=n+1;j&gt;i;j--) if(a[i]&gt;a[j]) f[1][i]=max(f[1][i],f[1][j]+1); for(int i=1;i&lt;=n;i++) ans=max(f[0][i]+f[1][i]-1,ans); printf("%d\n",n-ans); return 0;&#125; 导弹拦截 友好城市 区间动归区间动归特点： 实现方法用$dp[i][j]$代表区间$[i,j]$的最大值；或者表示区间$[i,i+j]$的最大值。 典型题：P1880 [NOI1995]石子合并 树形动归树形动归特点： 在一棵树上的动态规划 实现方法类比P1216 [USACO1.5]数字三角形 Number Triangles，这题的思路是从三角形底部一层层合并到最顶部，便可得到答案 数字三角形代码：1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;using namespace std;int a[10000][10000];int main()&#123; int n; cin&gt;&gt;n; int num=0; for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;=i;j++) &#123; cin&gt;&gt;a[i][j]; &#125; &#125; int j=0; for(int i=n-2;i&gt;=0;i--) &#123; for(int j=0;j&lt;=i;j++) &#123; if(a[i+1][j]&gt;=a[i+1][j+1]) &#123; a[i][j]+=a[i+1][j]; &#125; else &#123; a[i][j]+=a[i+1][j+1]; &#125; &#125; &#125; cout&lt;&lt;a[0][0];&#125; 树形动归与这个类似，应该从树的底部开始，向上处理 程序实现如何存树：利用链式前向星把树存成无向图代码：1234567int head[1666],pre[3666],to[3666],cnt=0;void add_edge(int a,int b)&#123; to[++cnt]=b; pre[cnt]=head[a]; head[a]=cnt;&#125; 详细解释：链式前向星 如何从底部向上动归：递归实现代码：123456789101112void treedp(int pos)//pos是现在的位置 &#123; vis[pos]=1;//标记已访问过 for(int i=head[pos];i!=-1;i=pre[i])//链式前向星的遍历 &#123; if(!vis[to[i]])//第一次到达（防止在返回过程中再次递归下去，形成死循环） &#123; treedp(to[i]);//递归到下一层 ···//状态转移方程 &#125; &#125;&#125; 典型题 P1352 没有上司的舞会 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;int f[5][6000];int n,b,a,root;int cun[12000],zhi[12000],geshu[12000];bool vis[100000];void dp(int x)&#123; vis[x]=1; for(int i=zhi[x];i;i=cun[i]) &#123; if(vis[i]==0) &#123; dp(i); f[1][x]=max(max(f[1][x],f[0][i]+f[1][x]),f[0][i]); f[0][x]=max(max(f[0][x],f[1][i]+f[0][x]),max(f[1][i],f[0][i])); &#125; &#125;&#125;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;f[1][i]); for(int i=1;i&lt;=n;i++) &#123; scanf("%d%d",&amp;a,&amp;b); geshu[a]++; cun[a]=zhi[b]; zhi[b]=a; &#125; for(int i=1;i&lt;=n;i++) if(geshu[i]==0) &#123; root=i; break; &#125; dp(root); printf("%d",max(f[1][root],f[0][root])); return 0;&#125; P2016 战略游戏此题技巧：用$dp[0][i]$代表i这点不放的最优值，$dp[1][i]$代表i这点放的最优值 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int n,a,b,c,cnt,head[1666],f[1666][2];struct edge&#123; int to; int next;&#125;edge[3333];void add_edge(int x,int y)&#123; ++cnt; edge[cnt].to=y; edge[cnt].next=head[x]; head[x]=cnt;&#125;void tree(int x,int from)&#123; f[x][1]=1; f[x][0]=0; if(head[x]==0) &#123; f[x][0]=10000000; &#125; for(int i=head[x];i;i=edge[i].next) &#123; if(edge[i].to!=from) &#123; tree(edge[i].to,x); f[x][1]+=min(f[edge[i].to][1],f[edge[i].to][0]); f[x][0]+=f[edge[i].to][1]; &#125; &#125; &#125;int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;a&gt;&gt;b; a++; for(int j=1;j&lt;=b;j++) &#123; cin&gt;&gt;c; c++; add_edge(a,c); add_edge(c,a); &#125; &#125; tree(1,0); int ans=min(f[1][1],f[1][0]); printf("%d",ans);&#125; 状压动归状压动归特点：一般在矩阵上进行动归，不过由于情况过多，不可以开inf维数组进行解决，就需要使用状态压缩动归。在这类动态规划中，每个点的状态往往只用0或1来表示（复杂一些的可能需要用0,1,2），每一行每个点上的数字可以连成一个01串，如果我们把它看成一个二进制数，即可用一个十进制数来表示复杂的状态，即状态压缩。 实现方法 用十进制数表示一个状态，对每一个合法的状态（十进制数字）进行处理（通过位运算） 由于限制了摆放k个，所以需要统计当前状态摆放了几个（二进制中1的个数） 先进行预处理，将可能方案（用一个十进制数表示）存入数组，将这个方案中1的个数存入数组，顺便简要删除一些不可行的方案，降低复杂度，然后在剩余方案上进行动归。 典型题 P1896 [SCOI2005]互不侵犯 题意分析 一个$nn$的矩阵，有多少种方式，不重叠地摆放k个$33$的方块，要求输出方案数。 处理方块中心点位置，看中心点放在某个位置是否合法（它的上下左…八个方向有没有其他方块） 根据两个方块中心点一定不相邻，删掉一些方案预处理123456789101112131415161718192021void prepare()//预处理可用情况 &#123; int k; s0=0; ans=0; memset(f,0,sizeof(f)); for(int i=0;i&lt;(1&lt;&lt;n);i++)//十进制数从0枚举到 1&lt;&lt;n，即可把所有状态处理全 &#123; if(i&amp;(i&lt;&lt;1))continue;//如果这个方案中有两个相邻，一定不满足条件，略过 k=0;//计数器 for(int j=0;j&lt;n;j++)//------ &#123;// 统 if(i&amp;(1&lt;&lt;j))// 计 &#123;// 1的 k++;// 个 &#125;// 数 &#125;// ------ s[++s0]=i; num[s0]=k; &#125;&#125; 斜率优化]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>背包</tag>
        <tag>树形动态规划</tag>
        <tag>区间动态规划</tag>
        <tag>状态压缩动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[各种Tarjan算法详解]]></title>
    <url>%2F2019%2F11%2F23%2Ftarjan%2F</url>
    <content type="text"><![CDATA[注意：本文对强连通分量的介绍已经完成，而其他部分尚未完成。 前言$\text{Tarjan}​$算法是图论中实用/常用的算法之一，能解决强连通分量，双连通分量，割点和桥，求$\text{LCA}​$等问题，本文将对以上用途一一介绍 强连通分量定义一个强连通分量是指一个有向图中的最大强联通子图。 强联通子图：任意两点可以互相到达的有向图。 如下图，就有3个强联通分量：{1,2,3}，{4}，{5}。 做法（一）如何找强联通分量。进行$\text{Dfs}​$遍历，在$\text{Dfs}​$树上操作。如果在$\text{Dfs}​$时发现遍历到了一个访问过的的点（如下图的$1​$号节点），那么说明从这个点出发，可以回到自己，即这条路径构成了一个环，环上的点是强联通的。 但根据强联通分量的定义，这只能说明他们在同一个强联通分量内，不能保证他们就是一个强连通分量，还要接着处理。 （二）找完整的强联通分量。考虑什么情况下才能保证上述的环构成一个强连通分量。上述的环都是由一个节点$S$和它在Dfs树中的子树构成的，那么只要保证子树内没有节点连向$S$的祖先，即可保证这是一个强连通分量。 原因比较好理解：若该点子树中有点连向了他的祖先，那么他的祖先便属于这个强连通分量，显然可以构成一个更大的强联通图。 可以参见下图辅助理解。图中$2​$号节点的子树中，$4​$号节点连向了$2​$的父亲——$1​$号点，那么环{2,3,4}就属于强联通分量{1,2,3,4}，而不能单独构成强联通分量。 （三）找准确的强连通分量。以上的算法貌似还有一个问题：我们能通过第二条（二）找完整的强联通分量。找到强联通分量所在的子树，但是我们并不知道子树中哪些节点属于，哪些节点不属于。 解决办法： 就像$\text{Dfs}$找环一样，用一个栈记录即可。 $u​$之后的所有点在u被回溯到时$u​$和栈中所有在它之后的点都构成强连通分量。具体见代码实现。 然后各位神仙们就可以脑补代码实现了，本次就到这里，感谢阅读！ 程序实现定义一些数组：1234int dfn[N];//表示在Dfs时是第几个被搜到的int low[N];//表示这个点的子树节点及他们连向的点的最小$dfn$值。为了实现上面的第二步int sta[N&#125;;//int vis[N];//记录点是否在栈中 实现过程1.最外层框架是对树的$\text{Dfs}$。 2.每遍历到一个节点$u​$: (1)初始化dfn[u]=low[u]=++cnt(cnt是计数器）。 根据数组含义可以理解，在处理前，子树中dfn最小的就是dfn[u],所以把low[u]初始化为dfn[u] (2)把$u$入栈，标记vis[u]=1 (3)接着遍历它所能到达的节点$v$，判断$v$是否访问过（方法：看dfn值是否等于0）。 a.未访问过：接着递归Dfs(v)，并用$v$的$low$值更新$u$:low[u]=min(low[u],low[v])因为子树中的节点可能连向$u$的祖先节点，所以按照$dfn$的含义更新它。 b.访问过： 如果$v$在栈中，说明$u$,$v$在一个强连通分量，那么更新low[u]:low[u]=min(low[u],low[v]) 如果不在栈中，说明$u$不能到达$v$,二者没有关联，不进行处理。 (4) 处理完$u$的子树后： 此时dfn[u]和low[u]都已经确定好。若dfn[u]==low[u]，根据数组含义，表明$u$是子树中所有点能到达的dfn最小的点，这也就满足了上文中的（二）找完整的强联通分量。（还记得吗），即满足了：u点与它的子孙节点构成了一个最大的强连通图,即强连通分量。 这时我们只需把栈中$u$后面的点和$u$一并弹出（别忘更新$\text{vis}$），弹出的这些点就是一个强连通分量了。 代码Tarjan建议参照上文对比阅读代码。1234567891011121314151617181920212223242526272829303132int dfn[N],low[N],t;//数组定义同上面的解释int sta[N],top;int vis[N];int col[N],tot;//用于标记答案，col相同的点在一个强连通分量中void Tarjan(int u)&#123; low[u]=dfn[u]=++t; sta[++top]=u; vis[u]=1; for(int i=head[u];i;i=next[i]) &#123; int v=to[i]; if(!dfn[v]) &#123; Tarjan(v); low[u]=min(low[u],low[v]); &#125; else if(vis[v]) low[u]=min(low[u],dfn[v]); &#125; if(dfn[u]==low[u]) &#123; int v; tot++; do&#123; v=sta[top]; top--; vis[v]=0; col[v]=tot; &#125;while(u!=v); &#125;&#125; 主函数注意：由于图可能不连通，从一个点开始Dfs可能不会遍历所有点，所以要这样写：12for(int i=1;i&lt;=n;i++)//遍历所有点 if(!dfn[i]) Tarjan(i); 时间复杂度每个点只被入栈，出栈一次，时间复杂度为$O(n)$ 双连通分量、割点和桥概念双联通分量与强联通分量类似，是一个无向图中的最大双连通子图。它分为两类：点双连通分量，边双连通分量（简称点双，边双）。 点双连通分量、割点定义点双连通分量：是指一个无向图中的最大点双连通子图。 点双连通图：一个去掉任意一节点都不会改变它的连通性的无向图。 例如，下面这个图中，{1,2,3,4,5}就是一个点双连通分量 割点：若一个图中，有一点$A$,删掉该点会使图不连通，那么称点$A$为割点。 性质根据定义可以看出，任意两点间都有至少两条点不重复的路径。 点双连通分量之间以割点连接，且两个点双连通分量之间有且只有一个割点。 割点求法首先类似于强连通分量，Tarjan求割点也是在Dfs基础上运行的，所以先获得一个Dfs树。 对于根节点：比较好判断。统计一下根节点的子树个数，若 子树个数$\geq 2$，那么割掉根节点，两个子树便不再联通，即可说明根节点是割点。 对于非根节点：根据割点的定义和Dfs树，可以知道，割点被割掉后，图一定是被分成了割点的子树A和除子树节点外所有的点B两部分。简单点说，割掉割点相当于把子树剪掉了。经过分析，只要割掉一个点后，A和B不连通，即可保证该点是割点。也就是说，当A中的所有点，都只是通过这个点连接着B，而没有其它边连接A和B，即可说明 参考资料https://www.cnblogs.com/stxy-ferryman/p/7779347.html https://www.cnblogs.com/ljk123-de-bo-ke/p/10888905.html https://www.luogu.org/blog/shiboao/post-ti-gao-ge-dian]]></content>
      <categories>
        <category>算法</category>
        <category>tarjan</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>tarjan</tag>
        <tag>强连通分量</tag>
        <tag>双连通分量</tag>
        <tag>割点</tag>
        <tag>桥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++STL-Map的使用]]></title>
    <url>%2F2019%2F11%2F23%2Fc%2B%2BSTL-Map%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言$\text{map,unordered_map}​$是$\text{c++STL}​$ 中的一种数据结构，能够实现映射操作，在某些题目中可起到不可替代的作用，本文介绍它们的使用方法。 Map用途Map可用于将一种类型的变量映射到另一种类型的变量。所以，它应该保护两个关键字，从一个映射到另一个。其实，数组就是一种int到其他类型的映射。例如：$\text{int}$类型的数组a，a[x]=y也就是把$x$映射到$y​$。 有了数组，要map干什么？ 数组只是数字到其他类型的映射，但是假如我们要字符串到数字的映射怎么办？比如，将字符串abc映射到数字$5​$，对于数组，a[&quot;abc&quot;]=5显然会CE，但是有了map就不一样了。有$map​$，你甚至可以这样：a[10000000000000000000]++;。 使用方法头文件1#include&lt;map&gt; 定义1234map&lt;int,int&gt; a;map&lt;string,char&gt; a;map&lt;string,int&gt; a;... 其中尖括号内，左面是第一关键字，右面是第二关键字。 插入、修改、访问以map&lt;string,int&gt; a为例 下标访问即可a[&quot;abc&quot;]=2; 遍历方法一循环遍历，下标访问,想数组一样。12for(int i=1;i&lt;=100;i++) cout&lt;&lt;a[i]; 如果储存值域过大，这种方式会导致TLE。 方法二利用迭代器，可以只遍历存在的映射，跳过空位。 1234for(map&lt;int,int&gt;::iterator i=a.begin();i!=a.end();i++)&#123; printf("%d %d\n",i-&gt;first,i-&gt;second);&#125; 如果不会指针或迭代器，背下来即可，无需理解。这种方式遍历的顺序是 第一关键字由小至大。 时间复杂度 内部实现是一颗平衡树，每次操作复杂度为$log$级别的。 Unordered_mapUnordered_map与Map的区别不大，这里不再重复介绍相同点。以下对其不同之处进行介绍。 遍历遍历的方式是一样的，不过值得注意的是，用迭代器遍历时，遍历的元素顺序是乱的。 时间复杂度由于内部实现是哈希表 ，插入和查询的复杂度均为$\theta(n)$]]></content>
      <categories>
        <category>STL</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>Map</tag>
        <tag>Unordered_map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最小费用最大流]]></title>
    <url>%2F2019%2F07%2F06%2F%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81%2F</url>
    <content type="text"><![CDATA[前言本文发表于： 个人博客：链接 洛谷博客：链接 网络流是OI中比较常出现的算法，而最小费用最大流是其最常用的算法之一，阅读本文前，请确保掌握了网络最大流的Dinic的求法，详见网络最大流 最小费用最大流算法简介最小费用最大流（以下简称费用流），是在网络最大流的基础上，给每个边增加了另一个值——费用，代表每流过一个单位的流量，就会耗费这些费用。而费用流算法，就是在求最大流的同时，找出所花费用最小的方案，并求出这个最小费用。 实现方法首先，对于同一个图，它的最大流是一个固定的值，但是有很多方案，而求费用最小的走法，便可以利用最短路算法，以费用为最短路的边权。 思考一下，Dinic中的反边思想实际上是让程序可以沿着反边跑回去，达到反悔目的。所以费用流中，反边的费用需要设置成正边的相反数，保证在返回时费用也会还回来。 由于反边有负边权，所以要用已死的SPFA 把$Dinic$中的$Bfs$改为$SPFA$即可,每次找残量图中$S-T$的最短路径（费用作为边权），并按照$Dinic$的方式增广这条路径。 $Dinic$增广时需要把残量图中流量更改，所以要用能记录路径的$SPFA$ 建图12345678910int head[N],to[N],next[N],f[N],c[N];//f是容量，c是费用int cnt=1;void Add(int x,int y,int z,int cost)&#123; to[++cnt]=y; f[cnt]=z; c[cnt]=cost; next[cnt]=head[x]; head[x]=cnt;&#125; SPFA1234567891011121314151617181920212223242526272829303132333435363738int dis[N];/*spfa的距离数组*/int flow[N];/*源点到此处流量*/int vis[N];int pre[N];//每个点的前驱 int last[N];bool Spfa() &#123; memset(dis,0x7f,sizeof(dis)); memset(flow,0x7f,sizeof(flow)); memset(vis,0,sizeof(vis)); queue&lt;int&gt; q; q.push(S); vis[S]=1,dis[S]=0; pre[T]=-1; while(!q.empty()) &#123; int u=q.front(); q.pop(); vis[u]=0; for(int i=head[u];i;i=next[i]) &#123; int v=to[i]; if(f[i]&gt;0 &amp;&amp; dis[v]&gt;dis[u]+c[i])//有残量，能松弛 &#123; dis[v]=dis[u]+c[i];//更新距离 pre[v]=u;//SPFA记录前驱 last[v]=i;//记录边的编号，便于增广时更改边权 flow[v]=min(flow[u],f[i]); if(!vis[v]) &#123; vis[v]=1; q.push(v); &#125; &#125; &#125; &#125; return ~pre[T];&#125; 主函数 12345678910111213141516int Flow,Cost;void Mcmf()&#123; while(Spfa()) &#123; int u=T; Flow+=flow[T]; Cost+=flow[T]*dis[T]; while(u!=S)//遍历这次的增广路（最短路） &#123; f[last[u]]-=flow[T];//更新边权 f[last[u]^1]+=flow[T]; u=pre[u]; &#125; &#125;&#125; 总结这种费用流算法实际上就是在增广时优先考虑费用（用最短路$\text{SPFA}$实现），保证费用最小（反正由于反边的存在，$\text{Dinic}$怎么流到最后都能流出最大流 ）。 完整代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#define next adjagagusing namespace std; const int N=1000010;int head[N],to[N],next[N],f[N],c[N];int cnt=1;int n,m,S,T;void Add(int x,int y,int z,int cost)&#123; to[++cnt]=y; f[cnt]=z; c[cnt]=cost; next[cnt]=head[x]; head[x]=cnt;&#125;int dis[N];int flow[N];int vis[N];int pre[N];int last[N];bool Spfa() &#123; memset(dis,0x7f,sizeof(dis)); memset(flow,0x7f,sizeof(flow)); memset(vis,0,sizeof(vis)); queue&lt;int&gt; q; q.push(S); vis[S]=1,dis[S]=0; pre[T]=-1; while(!q.empty()) &#123; int u=q.front(); q.pop(); vis[u]=0; for(int i=head[u];i;i=next[i]) &#123; int v=to[i]; if(f[i]&gt;0 &amp;&amp; dis[v]&gt;dis[u]+c[i]) &#123; dis[v]=dis[u]+c[i]; pre[v]=u; last[v]=i; flow[v]=min(flow[u],f[i]); if(!vis[v]) &#123; vis[v]=1; q.push(v); &#125; &#125; &#125; &#125; return ~pre[T];&#125;int Flow,Cost;void Mcmf()&#123; while(Spfa()) &#123; int u=T; Flow+=flow[T]; Cost+=flow[T]*dis[T]; while(u!=S) &#123; f[last[u]]-=flow[T]; f[last[u]^1]+=flow[T]; u=pre[u]; &#125; &#125;&#125;int main()&#123; scanf("%d %d %d %d",&amp;n,&amp;m,&amp;S,&amp;T); for(int i=1;i&lt;=m;i++) &#123; int x,y,z,c; scanf("%d %d %d %d",&amp;x,&amp;y,&amp;z,&amp;c); Add(x,y,z,c); Add(y,x,0,-c); &#125; Mcmf(); printf("%d %d\n",Flow,Cost); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>网络流</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络最大流]]></title>
    <url>%2F2019%2F06%2F27%2F%E7%BD%91%E7%BB%9C%E6%9C%80%E5%A4%A7%E6%B5%81%2F</url>
    <content type="text"><![CDATA[前言本文发表于： 个人博客：传送门 洛谷博客：传送门 网络最大流算法能在信息学竞赛中处理很多问题，而且往往是不可被其它算法替代的。而最大流算法则是处理问题的方法之一。本文将介绍网络最大流的算法及其优化。 关于本文代码 存图方式：数组链式前项星。 网络最大流算法-Dinic前置知识几个概念 源点（$S$)：网络流流出的点 汇点（$T$)：网络流流入的点 流量：一条边上流过流的多少 容量：一条边最大流量 残量：一条边上剩余流量，即容量$-​$流量 朴素的算法由于网络流算法都是基于增广这一思路的，接下来对增广进行介绍。 要想求出网络最大流，思路大体上就是不停地寻找增广路，直到没有增广路，即可保证求到了最大流。 增广：1.找到一条从源点通向到汇点的路径，并且这条路径上，每条边都有残量（这代表这条路并没有流满，完全可以增加一些流量），这条路叫做增广路。 2.取这条增广路上残量最小值，代表这条增广路上可以增加这么多流量（取最小值的原因显然）。 3.将增广路上每条边残量减去增加的流量，加入答案； 4.直到找不到增广路。 HACK如果仔细思考，以上算法仍然存在缺陷： 如下图： 此时找到的最大流是$10$，而实际上是$15$，因此，我们要进行改进。 改进这里是解决网络流问题的关键步骤： 引入反向边 即每次在找到增广路，更新残量时，同时将其反向边的残量相应增加： 具体过程如下图： 这样求出的最大流是15，正确。 实际上，引入了反向边，让程序可以进行一次$S-3-4-1-2-T​$这样的增广。 第一次增广不一定能寻得恰当的路线，而反向边可以让程序有反悔的机会，便是对的。 效率这样多次进行增广，会导致程序效率便得非常低。例如下图： 会增广很多次。于是我们引入Dinic算法。 Dinic$\text{Dinic}$在原有算法基础上，增加了分层图，即根据距离源点的距离，将每个点进行深度标号，每次找增广路时都保证深度递增地寻找。 分层（BFS）以下是分层部分的代码： 12345678910111213141516171819202122bool Bfs()//返回是否分层成功，即是否有最短路&#123; queue&lt;int&gt; q; memset(dep,0,sizeof(dep));//一定不要忘了清空 dep[S]=1; q.push(S); while(!q.empty()) &#123; int u=q.front(); q.pop(); for(int i=head[u];i;i=next[i]) &#123; int v=to[i]; if(w[i] &amp;&amp; !dep[v])//有残量，而且通往的点还没有访问过（标记过深度） &#123; dep[v]=dep[u]+1; q.push(v); &#125; &#125; &#125; return dep[T];&#125; 增广（DFS）以下是找增广路部分的代码： 12345678910111213141516171819int Dfs(int u,int dis)//当前节点，到目前为止可增加流量，返回可增加流量&#123; if(u==T || (!dis)) return dis;//到达汇点||已无残量 int sum=0; for(int i=head[u];i;i=next[i]) &#123; int v=to[i]; if(dep[v]==dep[u]+1 &amp;&amp; w[i])//通向的边在下一层且有残量 &#123; int di=Dfs(v,min(dis,w[i])); if(di&gt;0) &#123; w[i]-=di,w[i^1]+=di; return di;//传递; &#125; &#125; &#125; return 0;//无增广路&#125; 调用部分123456789int Dinic()&#123; int ans=0; while(Bfs())//能分层 &#123; ans+=Dfs(S,10000000); &#125; return ans;&#125; 主函数需要注意的是，为了实现增加反边，在建图时就需要提前建好容量为$0​$的反边。 补充 在链式前向星建图中，$cnt$初始值设成$1$,这样对于编号为$i$的边，它的反边编号就是$i$^$1$ 1234567891011121314int main()&#123; cnt=1; scanf("%d %d %d %d",&amp;n,&amp;m,&amp;S,&amp;T); for(int i=1;i&lt;=m;i++) &#123; int x,y,z; scanf("%d %d %d",&amp;x,&amp;y,&amp;z); Add(x,y,z); Add(y,x,0); &#125; printf("%d\n",Dinic()); return 0;&#125; Dinic的优化以上的$\text{Dinic}$算法是优化前的，一下对它的$3$种优化进行一一介绍： 当前弧优化在每次增广后，某个节点引出的几条边的残量会被更新成$0$，在原有算法中，残量为$0$的边仍会被扫一遍，而当前弧优化即是对上次停下的位置进行记录，下次直接从上次结束的位置开始。 实现方法就是用一个数组记录每个点处理到了第几条边，在代码中只需要加入几行即可，如下： 增广（DFS）12345678910111213141516171819int cur[N];int Dfs(int u,int dis)&#123; if(u==T || (!dis)) return dis; for(int &amp;i=cur[u];i;i=next[i])//注意这里的&amp; 和cur，在i增加的同时，cur[i]的值也会相应增加，达到了记录的目的 &#123; int v=to[i]; if(dep[v]==dep[u]+1 &amp;&amp; w[i]) &#123; int di=Dfs(v,min(dis,w[i])); if(di&gt;0) &#123; w[i]-=di,w[i^1]+=di; return di;//传递; &#125; &#125; &#125; return 0;//无增广路&#125; 调用部分12345678910int Dinic()&#123; int ans=0; while(Bfs())//能分层 &#123; memcpy(cur,head,sizeof(head));//重新更改回第一条边 ans+=Dfs(S,10000000); &#125; return ans;&#125; 多路增广每次不只是找一条增广路，而是只要可以就都递归下去，这样增广出来的不只是一条链，而是一个网，可以加快运行速度（降低常数） 增广部分12345678910111213141516171819int Dfs(int u,int dis)&#123; if(u==T || (!dis)) return dis; int flow=0; for(int i=cur[u];i;i=next[i]) &#123; cur[u]=i; int v=to[i]; if(dep[v]==dep[u]+1) &#123; int di=Dfs(v,min(dis,w[i]));//注意这个一定要放到if里面，否则会导致图不分层，导致TLE/MLE flow+=di;//这里不急着return，而是记录一下这条链上能增广的流量，再接着找下一条链 dis-=di;//把从u开始能增广的容量相应减去 w[i]-=di,w[i^1]+=di;//更新边权 if(!dis) break;//没容量了 &#125; &#125; return flow;&#125; 炸点当一个点连的边的残量都为$0$时，这个点已经没有用了，之后就不要再进入这个点了，这就是“炸点”。 具体实现可以把这个点的深度设置成$-1$，保证不会再次访问这个点。 123456789101112131415161718192021int Dfs(int u,int dis)&#123; if(u==T || (!dis)) return dis; int flow=0; for(int i=cur[u];i;i=next[i]) &#123; cur[u]=i; int v=to[i]; if(dep[v]==dep[u]+1) &#123; int di=Dfs(v,min(dis,w[i])); flow+=di; dis-=di; w[i]-=di,w[i^1]+=di; if(!dis) break; &#125; &#125; if(!flow)//这个点甚至没有增广出一点流量 dep[u]=-1;//炸掉它 return flow;&#125; 总结Dinic算法是较为高效的网络流算法，建议使用时加入以上$3$条优化。 下面给出完整代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#define next adjagagusing namespace std; const int N=1000010;int head[N],to[N],next[N],w[N];int cnt=1;int n,m,S,T;void Add(int x,int y,int z)&#123; to[++cnt]=y; w[cnt]=z; next[cnt]=head[x]; head[x]=cnt;&#125;int dep[N];bool Bfs()&#123; queue&lt;int&gt; q; memset(dep,0,sizeof(dep)); dep[S]=1; q.push(S); while(!q.empty()) &#123; int u=q.front(); q.pop(); for(int i=head[u];i;i=next[i]) &#123; int v=to[i]; if(w[i] &amp;&amp; !dep[v]) &#123; dep[v]=dep[u]+1; q.push(v); &#125; &#125; &#125; return dep[T];&#125;int cur[N];int Dfs(int u,int dis)&#123; if(u==T || (!dis)) return dis; int flow=0; for(int i=cur[u];i;i=next[i]) &#123; cur[u]=i; int v=to[i]; if(dep[v]==dep[u]+1) &#123; int di=Dfs(v,min(dis,w[i])); flow+=di; dis-=di; w[i]-=di,w[i^1]+=di; if(!dis) break; &#125; &#125; if(!flow) dep[u]=-1; return flow;&#125;int Dinic()&#123; int ans=0; while(Bfs()) &#123; memcpy(cur,head,sizeof(head)); ans+=Dfs(S,10000000); &#125; return ans;&#125;int main()&#123; cnt=1; scanf("%d %d %d %d",&amp;n,&amp;m,&amp;S,&amp;T); for(int i=1;i&lt;=m;i++) &#123; int x,y,z; scanf("%d %d %d",&amp;x,&amp;y,&amp;z); Add(x,y,z); Add(y,x,0); &#125; printf("%d\n",Dinic()); return 0;&#125; 参考资料https://www.cnblogs.com/SYCstudio/p/7260613.html]]></content>
      <categories>
        <category>算法</category>
        <category>网络流</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>最大流</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F05%2F23%2FDijkstra%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F05%2F23%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[链式前向星]]></title>
    <url>%2F2019%2F04%2F11%2F%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F%2F</url>
    <content type="text"><![CDATA[前言链式前向星是类似于邻接表的存图方式，具有空间复杂度小，便于遍历等优点，不过无法快速判断两点间是否有边 储存实现原理这种存图方式只需要开一个数组存储每个点引出的第一条边，然后存储每个点作为起点的每条边，这样就可以做到不重不漏。 在链式前向星存图中，我们需要定义一个结构体：12345struct EDGE &#123; int next; int to;&#125;edge[1000000]; 和一个数组：1int head[1000000]; 和一个变量：1int cnt=0;//指针 你会发现竟然没存起点！！其实起点是用$head$存的 实例： 如图：这样的一个有向图，输入是： 12341 21 31 42 3 逐步分析：1.输入1 2，代表1连向2。123cnt++;//作为结构体下标，没有意义head[1]=cnt;//结点1的第一个儿子存在了edge[cnt]里面edge[cnt].to=2;结点1的儿子是2 此时：$cnt=1$ $edge$ $cnt=1$ $cnt=2$ $ cnt=3$ $cnt=4$ $to $ $2$ $0$ $ 0$ $0$ $next$ $ 0 $ $0 $ $0$ $0$ $head $ 下标$=1 $ 下标$=2$ 下标$=3 $ 下标$=4 $ 值 $1 $ $ 0 $ $ 0 $ $ 0 $ 2.输入1 3，代表1连向3。12345678910cnt++;head[1]=cnt;edge[cnt].to=3;结点1的儿子是3//这时,3成为了结点1的儿子，不过2被挤了下去...//所以要引入结构体中next元素，记录：3还有个兄弟（next）是2//所以代码要换成：cnt++;edge[cnt].to=3;//结点1连向3edge[cnt].next=head[1];//3的兄弟是2head[1]=cnt;//更新head 此时：$cnt=2$ $edge$ $cnt=1$ $cnt=2$ $ cnt=3$ $cnt=4$ $to $ $2$ $3$ $ 0$ $0$ $next$ $ 0 $ $1 $ $0$ $0$ $head $ 下标$=1 $ 下标$=2$ 下标$=3 $ 下标$=4 $ 值 $2 $ $ 0 $ $ 0 $ $ 0 $ 3.输入1 4，代表1连向4。此时：$cnt=3$ $edge$ $cnt=1$ $cnt=2$ $ cnt=3$ $cnt=4$ $to $ $2$ $3$ $ 4$ $0$ $next$ $ 0 $ $1 $ $2$ $0$ $head $ 下标$=1 $ 下标$=2$ 下标$=3 $ 下标$=4 $ 值 $3 $ $ 0 $ $ 0 $ $ 0 $ 4.输入2 3，代表2连向3。此时：$cnt=4$ $edge$ $cnt=1$ $cnt=2$ $ cnt=3$ $cnt=4$ $to $ $2$ $3$ $ 4$ $3$ $next$ $ 0 $ $1 $ $2$ $0$ $head $ 下标$=1 $ 下标$=2$ 下标$=3 $ 下标$=4 $ 值 $3 $ $ 4 $ $ 0 $ $ 0 $ 注意：$edge[cnt].next$ 和$head[1]$存贮的都是结构体下标（即$cnt$的值）若要访问指向的边的编号，分别用$edge[edge[cnt].next].to$，$edge[head[1]].to$ 若需要记录权值，在结构体中加入一个元素即可 代码：带权值： 123456789101112131415161718192021222324252627#include&lt;iostream&gt;using namespace std;struct edge &#123; int next; int to; int wei;&#125;edge[MAXM];int head[MAXN];//head[i]为i点的第一条边int cnt=0;void addedge(int u,int v,int w) //起点，终点，权值 &#123; edge[++cnt].next=head[u];//更新cnt edge[cnt].to=v; edge[cnt].w=w; head[u]=cnt;&#125;int main()&#123; int n; for(int i=1;i&lt;=n;i++) &#123; int a,b,wei; addedge(a,b,wei); //如果是无向图，还要addedge(b,a,wei); &#125;&#125; 注意： 这里的$next$指的是遍历时的下一条边，$head$指的是遍历时的第一条边，而存边时相当于反过来操作，所以$next$记录上一条边，而$head$记录最后一条边。 边的遍历在遍历以x为起点的所有边时，只需要这样就行 1for(int i=head[x];i;i=edge[i].next) 这个循环的结束条件是$i$等于$0$，因为最后一条边，也就是存边时第一条边，在把$head$值存进$next$时，$head$还没有更新过，也就是$0$。所以当$next$返回$0$时，就说明这些边遍历完毕了。 优势与特点既可以存图，也可以存树，比起邻接矩阵，链式前向星的空间复杂度是$O(n)$,大大节省了存储空间，因为按边存储省掉了很多两点无边的空间。并且在遍历的时候，那些与起点无边相连的点也不需要进行处理，可以说时间和空间都占优势，这就是被OIer们广泛使用的原因。 补充+技巧 （$2019/1/15 update​$） 1234567void addedge(int u,int v,int w) //起点，终点，权值 &#123; edge[++cnt].next=head[u];//更新cnt edge[cnt].to=v; edge[cnt].w=w; head[u]=cnt;&#125; 这个代码中，$cnt$代表边的编号。 如果$cnt​$初始值赋为$1​$,存的是无向图，那么： 边$cnt$的反向边是$cnt$^$1$]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>存图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后缀数组]]></title>
    <url>%2F2019%2F04%2F10%2F%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[什么是后缀数组：看几条定义(应该没啥用)： 子串 在字符串$s$中，取任意$i&lt;=j$，那么在$s$中截取从$i$到$j$的这一段就叫做$s$的一个子串后缀 后缀 就是从字符串的某个位置i到字符串末尾的子串，我们定义以$s$的第$i$个字符为第一个元素的后缀为$suff(i)$ 后缀数组 把$s$的每个后缀按照字典序排序， 后缀数组$sa[i]$就表示排名为i的后缀的起始位置的下标 而它的映射数组$rk[i]$就表示起始位置的下标为i的后缀的排名 即：$sa$表示排名为$i$的是啥，$rk$表示第$i$个的排名是啥 后缀数组的思想先说最暴力的情况，对每个后缀排序$(nlogn)%，但是这是一个字符串，所以比较任意两个后缀的复杂度其实是%O(n)%，复杂度$O(n^2logn)$的，肯定会$T$,接下来需要把优化。 优化优化1：倍增——对排序的优化我们不是把每一个后缀字符串列举出来，当做没有联系的字符串进行排序，而是把每一个后缀都放在原串中考虑。 1.先根据单个字符排序，(即先按照每个后缀的第一个字符排序）。对于每个字符，我们按照字典序给一个排名(当然可以并列)，这里称作关键字。 2.接下来我们再把相邻的两个关键字合并到一起(即先按照每个后缀的前两个字符排序）。这样就是以第一个字符(也就是自己本身)的排名为第一关键字，以第二个字符的排名为第二关键字，把组成的新数排完序之后再次标号。(没有第二关键字的补零) 3.接下来就要倍增了：我们对于一个在第$i$位上的关键字，它的第二关键字就是第$i+2$位置上的，联想一下，因为现在第i位上的关键字是$suff(i)$的前两个字符的排名，第$i+2$位置上的关键字是$suff(i+2)$的前两个字符的排名，这两个一合并，不就是$suff(i)$的前四个字符的排名吗？方法同上，排序之后重新标号，没有第二关键字的补零。同理我们可以证明，下一次我们要合并的是第$i$位和第$i+4$位，以此类推即可 ··· 当所有的排名都不同的时候我们直接退出就可以了，因为已经排好了。 这样排序的速度稳定在$(logn)$ 优化2——基数排序如果我们用快排的话，复杂度就是$(nlog^2n)$ 还是太大。 这里我们用一波基数排序优化一下。在这里我们可以注意到，每一次排序都是排两位数，所以基数排序可以将它优化到$O(n)$级别，总复杂度就是$(nlogn)$。 介绍一下什么是基数排序，这里就拿两位数举例 我们要建两个桶，一个装个位，一个装十位，我们先把数加到个位桶里面，再加到十位桶里面，这样就能保证对于每个十位桶，桶内的顺序肯定是按个位升序的。 最长公共前缀——后缀数组的辅助工具什么是LCP？我们定义$LCP(i,j)$为$suff(sa[i])$与$suff(sa[j])$的最长公共前缀 为什么要求LCP？后缀数组这个东西，不可能只让你排个序就完事了……大多数情况下我们都需要用到这个辅助工具LCP来做题的关于LCP的几条性质显而易见的 LCP(i,j)=LCP(j,i); LCP(i,i)=len(sa[i])=n-sa[i]+1; 对于$i&gt;j$的情况，我们可以把它转化成$i&lt;j$，对于$i==j$的情况，我们可以直接算长度，所以我们直接讨论$i&lt;j$的情况就可以了。 我们每次依次比较字符肯定是不行的，单次复杂度为$O(n)$，太高了，所以我们要做一定的预处理才行。 几个性质LCP(i,k)=min(LCP(i,j),LCP(j,k)) LCP(i,k)=min(LCP(j,j-1)) 对于任意1&lt;i&lt;=j&lt;=k&lt;=n 怎么求LCP？我们设$height[i]$为$LCP(i,i-1)$，$1&lt;i&lt;=n$，显然$height[1]=0;$ 由上面的几个性质可得，$LCP(i,k)=min(height[j]) i+1&lt;=j&lt;=k$ 那么$height$怎么求，我们要利用这些后缀之间的联系 设$h[i]=height[rk[i]]$，同样的，$height[i]=h[sa[i]]$; 那么现在来证明最关键的一条定理： $h[i]&gt;=h[i-1]-1;$ 首先我们设第$i-1$个字符串按排名来的前面的那个字符串是第k个字符串，注意$k$不一定是$i-2$，因为第$k$个字符串是按字典序排名来的$i-1$前面那个，并不是指在原字符串中位置在$i-1$前面的那个第$i-2$个字符串。 这时，依据$height[]$的定义，第k个字符串和第i-1个字符串的公共前缀自然是$height[rk[i-1]]$，现在先讨论一下第$k+1$个字符串和第$i$个字符串的关系。 第一种情况，第$k$个字符串和第$i-1$个字符串的首字符不同，那么第k+1个字符串的排名既可能在$i$的前面，也可能在i的后面，但没有关系，因为$height[rk[i-1]]$就是$0$了呀，那么无论$height[rk[i]]$是多少都会有$height[rk[i]]&gt;=height[rk[i-1]]-1$，也就是$h[i]&gt;=h[i-1]-1$。 第二种情况，第$k$个字符串和第$i-1$个字符串的首字符相同，那么由于第$k+1$个字符串就是第k个字符串去掉首字符得到的，第$i$个字符串也是第$i-1$个字符串去掉首字符得到的，那么显然第$k+1$个字符串要排在第$i$个字符串前面。同时，第$k$个字符串和第$i-1$个字符串的最长公共前缀是$height[rk[i-1]]$， 那么自然第k+1个字符串和第i个字符串的最长公共前缀就是$height[rk[i-1]]-1$。 到此为止，第二种情况的证明还没有完，我们可以试想一下，对于比第$i$个字符串的排名更靠前的那些字符串，谁和第i个字符串的相似度最高（这里说的相似度是指最长公共前缀的长度）？显然是排名紧邻第$i$个字符串的那个字符串了呀，即4sa[rank[i]-1]4。但是我们前面求得，有一个排在i前面的字符串$k+1$，$LCP(rk[i],rk[k+1])=height[rk[i-1]]-1;$ 又因为$height[rk[i]]=LCP(i,i-1)&gt;=LCP(i,k+1)$ 所以$height[rk[i]]&gt;=height[rk[i-1]]-1$，也即$h[i]&gt;=h[i-1]-1$.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;cstdio&gt;#include&lt;cstring&gt;#define rint register int#define inv inline void#define ini inline int#define maxn 1000050using namespace std;char s[maxn];int y[maxn],x[maxn],c[maxn],sa[maxn],rk[maxn],height[maxn],wt[30];int n,m;inv putout(int x)&#123; if(!x) &#123;putchar(48);return;&#125; rint l=0; while(x) wt[++l]=x%10,x/=10; while(l) putchar(wt[l--]+48);&#125;inv get_SA()&#123; for (rint i=1;i&lt;=n;++i) ++c[x[i]=s[i]]; //c数组是桶 //x[i]是第i个元素的第一关键字 for (rint i=2;i&lt;=m;++i) c[i]+=c[i-1]; //做c的前缀和，我们就可以得出每个关键字最多是在第几名 for (rint i=n;i&gt;=1;--i) sa[c[x[i]]--]=i; for (rint k=1;k&lt;=n;k&lt;&lt;=1) &#123; rint num=0; for (rint i=n-k+1;i&lt;=n;++i) y[++num]=i; //y[i]表示第二关键字排名为i的数，第一关键字的位置 //第n-k+1到第n位是没有第二关键字的 所以排名在最前面 for (rint i=1;i&lt;=n;++i) if (sa[i]&gt;k) y[++num]=sa[i]-k; //排名为i的数 在数组中是否在第k位以后 //如果满足(sa[i]&gt;k) 那么它可以作为别人的第二关键字，就把它的第一关键字的位置添加进y就行了 //所以i枚举的是第二关键字的排名，第二关键字靠前的先入队 for (rint i=1;i&lt;=m;++i) c[i]=0; //初始化c桶 for (rint i=1;i&lt;=n;++i) ++c[x[i]]; //因为上一次循环已经算出了这次的第一关键字 所以直接加就行了 for (rint i=2;i&lt;=m;++i) c[i]+=c[i-1];//第一关键字排名为1~i的数有多少个 for (rint i=n;i&gt;=1;--i) sa[c[x[y[i]]]--]=y[i],y[i]=0; //因为y的顺序是按照第二关键字的顺序来排的 //第二关键字靠后的，在同一个第一关键字桶中排名越靠后 //基数排序 swap(x,y); //这里不用想太多，因为要生成新的x时要用到旧的，就把旧的复制下来，没别的意思 x[sa[1]]=1;num=1; for (rint i=2;i&lt;=n;++i) x[sa[i]]=(y[sa[i]]==y[sa[i-1]] &amp;&amp; y[sa[i]+k]==y[sa[i-1]+k]) ? num : ++num; //因为sa[i]已经排好序了，所以可以按排名枚举，生成下一次的第一关键字 if (num==n) break; m=num; //这里就不用那个122了，因为都有新的编号了 &#125; for (rint i=1;i&lt;=n;++i) putout(sa[i]),putchar(&apos; &apos;);&#125;inv get_height()&#123; rint k=0; for (rint i=1;i&lt;=n;++i) rk[sa[i]]=i; for (rint i=1;i&lt;=n;++i) &#123; if (rk[i]==1) continue;//第一名height为0 if (k) --k;//h[i]&gt;=h[i-1]+1; rint j=sa[rk[i]-1]; while (j+k&lt;=n &amp;&amp; i+k&lt;=n &amp;&amp; s[i+k]==s[j+k]) ++k; height[rk[i]]=k;//h[i]=height[rk[i]]; &#125; putchar(10);for (rint i=1;i&lt;=n;++i) putout(height[i]),putchar(&apos; &apos;);&#125;int main()&#123; gets(s+1); n=strlen(s+1);m=122; //因为这个题不读入n和m所以要自己设 //n表示原字符串长度，m表示字符个数，ascll(&apos;z&apos;)=122 //我们第一次读入字符直接不用转化，按原来的ascll码来就可以了 //因为转化数字和大小写字母还得分类讨论，怪麻烦的 get_SA(); //get_height();&#125; &lt;img src=&quot;https://img-blog.csdn.net/20151129213701642&quot; width=256 height=256 /&gt;]]></content>
      <categories>
        <category>算法</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客搭建]]></title>
    <url>%2F2019%2F03%2F23%2FHexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[搭建记录修改博客内容首次使用1.打开安装包安装Git，Node 2.下载hexo 12npm config set registry https://registry.npm.taobao.orgnpm install -g hexo 3.安装hexo 1hexo init 4.配置github 12git config --global user.email "zfMMG9000@163.com"git config --global user.name "2018haha" 5.绑定github密匙1ssh-keygen 并把路径中id_rsa.pub用记事本打开，复制到github的key上 更改博客设置有两个位置： hexo设置\_config.yml next主题设置\themes\hexo-theme-next-6.7.0\_config.yml 详细请百度 写文章hexo n &quot;文章名&quot; 在\source\_posts中找到文件并编辑 开头几个参数： 1234567---title: categories: 日志mathjax: truetags: [记录,笔记,日志]keywords: [1,2]--- 预览，发布预览：1hexo s 发布：123hexo cleanhexo ghexo d]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
</search>
