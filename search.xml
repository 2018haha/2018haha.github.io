<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[后缀数组]]></title>
    <url>%2F2019%2F04%2F10%2F%E7%BC%80%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[什么是后缀数组：看几条定义(应该没啥用)： 子串 在字符串$s$中，取任意$i&lt;=j$，那么在$s$中截取从$i$到$j$的这一段就叫做$s$的一个子串后缀 后缀 就是从字符串的某个位置i到字符串末尾的子串，我们定义以$s$的第$i$个字符为第一个元素的后缀为$suff(i)$ 后缀数组 把$s$的每个后缀按照字典序排序， 后缀数组$sa[i]$就表示排名为i的后缀的起始位置的下标 而它的映射数组$rk[i]$就表示起始位置的下标为i的后缀的排名 即：$sa$表示排名为$i$的是啥，$rk$表示第$i$个的排名是啥 后缀数组的思想先说最暴力的情况，对每个后缀排序$(nlogn)%，但是这是一个字符串，所以比较任意两个后缀的复杂度其实是%O(n)%，复杂度$O(n^2logn)$的，肯定会$T$,接下来需要把优化。 优化优化1：倍增——对排序的优化我们不是把每一个后缀字符串列举出来，当做没有联系的字符串进行排序，而是把每一个后缀都放在原串中考虑。 先根据单个字符排序，(即先按照每个后缀的第一个字符排序）。对于每个字符，我们按照字典序给一个排名(当然可以并列)，这里称作关键字。 接下来我们再把相邻的两个关键字合并到一起(即先按照每个后缀的前两个字符排序）。这样就是以第一个字符(也就是自己本身)的排名为第一关键字，以第二个字符的排名为第二关键字，把组成的新数排完序之后再次标号。(没有第二关键字的补零) 接下来就要倍增了：我们对于一个在第$i$位上的关键字，它的第二关键字就是第$i+2$位置上的，联想一下，因为现在第i位上的关键字是$suff(i)$的前两个字符的排名，第$i+2$位置上的关键字是$suff(i+2)$的前两个字符的排名，这两个一合并，不就是$suff(i)$的前四个字符的排名吗？方法同上，排序之后重新标号，没有第二关键字的补零。同理我们可以证明，下一次我们要合并的是第$i$位和第$i+4$位，以此类推即可 ··· 当所有的排名都不同的时候我们直接退出就可以了，因为已经排好了。 这样排序的速度稳定在$(logn)$ 优化2——基数排序如果我们用快排的话，复杂度就是$(nlog^2n)$ 还是太大。 这里我们用一波基数排序优化一下。在这里我们可以注意到，每一次排序都是排两位数，所以基数排序可以将它优化到$O(n)$级别，总复杂度就是$(nlogn)$。 介绍一下什么是基数排序，这里就拿两位数举例 我们要建两个桶，一个装个位，一个装十位，我们先把数加到个位桶里面，再加到十位桶里面，这样就能保证对于每个十位桶，桶内的顺序肯定是按个位升序的。 最长公共前缀——后缀数组的辅助工具什么是LCP？我们定义$LCP(i,j)$为$suff(sa[i])$与$suff(sa[j])$的最长公共前缀 为什么要求LCP？后缀数组这个东西，不可能只让你排个序就完事了……大多数情况下我们都需要用到这个辅助工具LCP来做题的关于LCP的几条性质显而易见的 LCP(i,j)=LCP(j,i); LCP(i,i)=len(sa[i])=n-sa[i]+1; 对于$i&gt;j$的情况，我们可以把它转化成$i&lt;j$，对于$i==j$的情况，我们可以直接算长度，所以我们直接讨论$i&lt;j$的情况就可以了。 我们每次依次比较字符肯定是不行的，单次复杂度为$O(n)$，太高了，所以我们要做一定的预处理才行。 几个性质LCP(i,k)=min(LCP(i,j),LCP(j,k)) LCP(i,k)=min(LCP(j,j-1)) 对于任意1&lt;i&lt;=j&lt;=k&lt;=n 怎么求LCP？我们设$height[i]$为$LCP(i,i-1)$，$1&lt;i&lt;=n$，显然$height[1]=0;$ 由上面的几个性质可得，$LCP(i,k)=min(height[j]) i+1&lt;=j&lt;=k$ 那么$height$怎么求，我们要利用这些后缀之间的联系 设$h[i]=height[rk[i]]$，同样的，$height[i]=h[sa[i]]$; 那么现在来证明最关键的一条定理： $h[i]&gt;=h[i-1]-1;$ 首先我们设第$i-1$个字符串按排名来的前面的那个字符串是第k个字符串，注意$k$不一定是$i-2$，因为第$k$个字符串是按字典序排名来的$i-1$前面那个，并不是指在原字符串中位置在$i-1$前面的那个第$i-2$个字符串。 这时，依据$height[]$的定义，第k个字符串和第i-1个字符串的公共前缀自然是$height[rk[i-1]]$，现在先讨论一下第$k+1$个字符串和第$i$个字符串的关系。 第一种情况，第$k$个字符串和第$i-1$个字符串的首字符不同，那么第k+1个字符串的排名既可能在$i$的前面，也可能在i的后面，但没有关系，因为$height[rk[i-1]]$就是$0$了呀，那么无论$height[rk[i]]$是多少都会有$height[rk[i]]&gt;=height[rk[i-1]]-1$，也就是$h[i]&gt;=h[i-1]-1$。 第二种情况，第$k$个字符串和第$i-1$个字符串的首字符相同，那么由于第$k+1$个字符串就是第k个字符串去掉首字符得到的，第$i$个字符串也是第$i-1$个字符串去掉首字符得到的，那么显然第$k+1$个字符串要排在第$i$个字符串前面。同时，第$k$个字符串和第$i-1$个字符串的最长公共前缀是$height[rk[i-1]]$， 那么自然第k+1个字符串和第i个字符串的最长公共前缀就是$height[rk[i-1]]-1$。 到此为止，第二种情况的证明还没有完，我们可以试想一下，对于比第$i$个字符串的排名更靠前的那些字符串，谁和第i个字符串的相似度最高（这里说的相似度是指最长公共前缀的长度）？显然是排名紧邻第$i$个字符串的那个字符串了呀，即4sa[rank[i]-1]4。但是我们前面求得，有一个排在i前面的字符串$k+1$，$LCP(rk[i],rk[k+1])=height[rk[i-1]]-1;$ 又因为$height[rk[i]]=LCP(i,i-1)&gt;=LCP(i,k+1)$ 所以$height[rk[i]]&gt;=height[rk[i-1]]-1$，也即$h[i]&gt;=h[i-1]-1$.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;cstdio&gt;#include&lt;cstring&gt;#define rint register int#define inv inline void#define ini inline int#define maxn 1000050using namespace std;char s[maxn];int y[maxn],x[maxn],c[maxn],sa[maxn],rk[maxn],height[maxn],wt[30];int n,m;inv putout(int x)&#123; if(!x) &#123;putchar(48);return;&#125; rint l=0; while(x) wt[++l]=x%10,x/=10; while(l) putchar(wt[l--]+48);&#125;inv get_SA()&#123; for (rint i=1;i&lt;=n;++i) ++c[x[i]=s[i]]; //c数组是桶 //x[i]是第i个元素的第一关键字 for (rint i=2;i&lt;=m;++i) c[i]+=c[i-1]; //做c的前缀和，我们就可以得出每个关键字最多是在第几名 for (rint i=n;i&gt;=1;--i) sa[c[x[i]]--]=i; for (rint k=1;k&lt;=n;k&lt;&lt;=1) &#123; rint num=0; for (rint i=n-k+1;i&lt;=n;++i) y[++num]=i; //y[i]表示第二关键字排名为i的数，第一关键字的位置 //第n-k+1到第n位是没有第二关键字的 所以排名在最前面 for (rint i=1;i&lt;=n;++i) if (sa[i]&gt;k) y[++num]=sa[i]-k; //排名为i的数 在数组中是否在第k位以后 //如果满足(sa[i]&gt;k) 那么它可以作为别人的第二关键字，就把它的第一关键字的位置添加进y就行了 //所以i枚举的是第二关键字的排名，第二关键字靠前的先入队 for (rint i=1;i&lt;=m;++i) c[i]=0; //初始化c桶 for (rint i=1;i&lt;=n;++i) ++c[x[i]]; //因为上一次循环已经算出了这次的第一关键字 所以直接加就行了 for (rint i=2;i&lt;=m;++i) c[i]+=c[i-1];//第一关键字排名为1~i的数有多少个 for (rint i=n;i&gt;=1;--i) sa[c[x[y[i]]]--]=y[i],y[i]=0; //因为y的顺序是按照第二关键字的顺序来排的 //第二关键字靠后的，在同一个第一关键字桶中排名越靠后 //基数排序 swap(x,y); //这里不用想太多，因为要生成新的x时要用到旧的，就把旧的复制下来，没别的意思 x[sa[1]]=1;num=1; for (rint i=2;i&lt;=n;++i) x[sa[i]]=(y[sa[i]]==y[sa[i-1]] &amp;&amp; y[sa[i]+k]==y[sa[i-1]+k]) ? num : ++num; //因为sa[i]已经排好序了，所以可以按排名枚举，生成下一次的第一关键字 if (num==n) break; m=num; //这里就不用那个122了，因为都有新的编号了 &#125; for (rint i=1;i&lt;=n;++i) putout(sa[i]),putchar(&apos; &apos;);&#125;inv get_height()&#123; rint k=0; for (rint i=1;i&lt;=n;++i) rk[sa[i]]=i; for (rint i=1;i&lt;=n;++i) &#123; if (rk[i]==1) continue;//第一名height为0 if (k) --k;//h[i]&gt;=h[i-1]+1; rint j=sa[rk[i]-1]; while (j+k&lt;=n &amp;&amp; i+k&lt;=n &amp;&amp; s[i+k]==s[j+k]) ++k; height[rk[i]]=k;//h[i]=height[rk[i]]; &#125; putchar(10);for (rint i=1;i&lt;=n;++i) putout(height[i]),putchar(&apos; &apos;);&#125;int main()&#123; gets(s+1); n=strlen(s+1);m=122; //因为这个题不读入n和m所以要自己设 //n表示原字符串长度，m表示字符个数，ascll(&apos;z&apos;)=122 //我们第一次读入字符直接不用转化，按原来的ascll码来就可以了 //因为转化数字和大小写字母还得分类讨论，怪麻烦的 get_SA(); //get_height();&#125; &lt;img src=&quot;https://img-blog.csdn.net/20151129213701642&quot; width=256 height=256 /&gt;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英才计划开题报告]]></title>
    <url>%2F2019%2F03%2F28%2F%E8%8B%B1%E6%89%8D%E5%BC%80%E9%A2%98%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[背景· 动态规划（Dynamic Programming）算法是一种在数学、计算机科学和经济学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。二十世纪五十年代,美国数学家理查德贝尔根据一类多阶段决策优化问题的特点,提出了最优化原理，最为动态规划的基础，可以有效地解决一类多阶段决策优化问题。 目的与意义· 动态规划算法能在较低的时间复杂度以内，计算出很多复杂问题的最优解/最优策略，可以大大降低时间、空间复杂度，代替时间复杂度为指数级别的搜索算法。只要在程序设计中灵活地应用此算法，可以达到其他算法不可比拟的效果； · 动态规划算法已在计算机学家数年的研究中日益成熟，动态规划算法的类别也逐渐增都，能解决的问题也越来越广； · 此算法的应用前景十分广阔。目前凭借着高效、实用的性能，已经应用在工农业生产，军事，经济，工程技术等多方面并展现出其宽广的前景。它可以解决例如最短路径、资产的投资决策、字符串匹配、设备更新、地图导航、水资源的调度分配等许多问题。因此在理论上和实践上对动态规划算法的研究都具有重要的意义。 研究内容· 动态规划的适用条件； · 对动态规划算法的各个类别依次进行研究，包括：递推、背包、统计方案数、区间动态规划、树形动态规划、数位动态规划、状态压缩动态规划、概率动态规划、动态规划算法的优化等方面； · 动态规划算法程序设计上的技巧，包括：dp数组的设置、状态转移方程的设计、优化的依据等； · 动态规划的实际应用。 技术路线利用动态规划算法求解最优决策问题时，一般分为以下几个步骤： 定义数组：定义一个数组（根据需要可以开多维数组），设计好数组下标及对应的元素值是如何表示动态规划的状态的； 设计状态转移方程：利用该问题的特点，设计出满足题意的状态转移方式，写出转移方程； 分析当前算法的时间复杂度，空间复杂度，验证动态规划算法在时间效率上的优化，并考虑能否进行进一步优化； 程序实现。 预期结果· 学会利用动态规划算法解决实际应用中的问题]]></content>
      <categories>
        <category>英才计划</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客搭建]]></title>
    <url>%2F2019%2F03%2F23%2FHexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[搭建记录修改博客内容首次使用1.打开安装包安装Git，Node 2.下载hexo 12npm config set registry https://registry.npm.taobao.orgnpm install -g hexo 3.安装hexo 1hexo init 4.配置github 12git config --global user.email "zfMMG9000@163.com"git config --global user.name "2018haha" 5.绑定github密匙1ssh-keygen 并把路径中id_rsa.pub用记事本打开，复制到github的key上 更改博客设置有两个位置： hexo设置\_config.yml next主题设置\themes\hexo-theme-next-6.7.0\_config.yml 详细请百度 写文章hexo n &quot;文章名&quot; 在\source\_posts中找到文件并编辑 开头几个参数： 1234567---title: categories: 日志mathjax: truetags: [记录,笔记,日志]keywords: [1,2]--- 预览，发布预览：1hexo s 发布：123hexo cleanhexo ghexo d]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dijkstra]]></title>
    <url>%2F2019%2F03%2F22%2F%E9%A2%98%E8%A7%A3-P4779-%E3%80%90%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%EF%BC%88%E6%A0%87%E5%87%86%E7%89%88%EF%BC%89%E3%80%91%2F</url>
    <content type="text"><![CDATA[单源最短路算法——Dijkstra 实现方法：1.定义ans[100000]，ans[i]代表到达i点的最小花费 2.定义bool数组visit，代表是否来过这里 2.ans[起点]=0,其余的赋值为inf 3.定义一个curr变量，visit[current]=1（访问过），代表现在的位置，初始值为起点。 4.列举所有与curr相联通的的点，将这些点(i)的ans值更新： $ ans[i]=min(ans[i],ans[curr]+ $ 到这些点需要的花费 $)$ 5. 列举所有访问过的的点，找到ans值最小的点，赋值给curr，visit[current]=1（访问过） 6 所有点都访问过（visit[i]都==1），程序结束。此时，ans[i]代表从起点到i的最短路径 伪代码123456789101112131415161718192021bool vis[1000000];//是否访问过int ans[1000000];int curr=起点;memset(ans,0x7fffffff,sizeof(ans))while(vis[curr]==0)&#123; vis[curr]=1; for(int i;列举所有curr连通的点） &#123; ans[i]=min(ans[i],ans[curr]+k)//k代表从curr点到i点的最短路 &#125; int minn=2147483647; for(int i=1;i&lt;=m;i++)//列举所有点 &#123; if(vis[i]==1&amp;&amp;ans[i]&lt;minn)//访问过且小 &#123; minn=ans[i];//更新最小值 curr=i;//更新下一个点 &#125; &#125;&#125; 存图方式链式前向星以下是关于链式前向星的介绍 ，会的可以跳过： 边的存储这种存图方式只需要开一个数组存储每个点引出的第一条边，然后存储每个点作为起点的每条边，这样就可以做到不重不漏。 在链式前向星存图中，我们需要定义一个结构体：12345struct EDGE &#123; int next; int to;&#125;edge[1000000]; 和一个数组：1int head[1000000]; 和一个变量：1int cnt=0;//指针 你会发现竟然没存起点！！其实起点是用$head$存的 举例： 如图：这样的一个有向图，输入是： 12341 21 31 42 3 逐步分析：1.输入1 2，代表1连向2。123cnt++;//作为结构体下标，没有意义head[1]=cnt;//结点1的第一个儿子存在了edge[cnt]里面edge[cnt].to=2;结点1的儿子是2 此时：$cnt=1$ $edge$ $cnt=1$ $cnt=2$ $ cnt=3$ $cnt=4$ $to $ $2$ $0$ $ 0$ $0$ $next$ $ 0 $ $0 $ $0$ $0$ $head $ 下标$=1 $ 下标$=2$ 下标$=3 $ 下标$=4 $ 值 $1 $ $ 0 $ $ 0 $ $ 0 $ 2.输入1 3，代表1连向3。12345678910cnt++;head[1]=cnt;edge[cnt].to=3;结点1的儿子是3//这时,3成为了结点1的儿子，不过2被挤了下去...//所以要引入结构体中next元素，记录：3还有个兄弟（next）是2//所以代码要换成：cnt++;edge[cnt].to=3;//结点1连向3edge[cnt].next=head[1];//3的兄弟是2head[1]=cnt;//更新head 此时：$cnt=2$ $edge$ $cnt=1$ $cnt=2$ $ cnt=3$ $cnt=4$ $to $ $2$ $3$ $ 0$ $0$ $next$ $ 0 $ $1 $ $0$ $0$ $head $ 下标$=1 $ 下标$=2$ 下标$=3 $ 下标$=4 $ 值 $2 $ $ 0 $ $ 0 $ $ 0 $ 3.输入1 4，代表1连向4。此时：$cnt=3$ $edge$ $cnt=1$ $cnt=2$ $ cnt=3$ $cnt=4$ $to $ $2$ $3$ $ 4$ $0$ $next$ $ 0 $ $1 $ $2$ $0$ $head $ 下标$=1 $ 下标$=2$ 下标$=3 $ 下标$=4 $ 值 $3 $ $ 0 $ $ 0 $ $ 0 $ 4.输入2 3，代表2连向3。此时：$cnt=4$ $edge$ $cnt=1$ $cnt=2$ $ cnt=3$ $cnt=4$ $to $ $2$ $3$ $ 4$ $3$ $next$ $ 0 $ $1 $ $2$ $0$ $head $ 下标$=1 $ 下标$=2$ 下标$=3 $ 下标$=4 $ 值 $3 $ $ 4 $ $ 0 $ $ 0 $ 注意：$edge[cnt].next$ 和$head[1]$存贮的都是结构体下标（即$cnt$的值）若要访问指向的边的编号，分别用$edge[edge[cnt].next].to$，$edge[head[1]].to$若需要记录权值，在结构体中加入一个元素即可代码：(带权值）123456789101112131415161718192021222324252627#include&lt;iostream&gt;using namespace std;struct edge &#123; int next; int to; int wei;&#125;edge[MAXM];int head[MAXN];//head[i]为i点的第一条边int cnt=0;void addedge(int u,int v,int w) //起点，终点，权值 &#123; edge[++cnt].next=head[u];//更新cnt edge[cnt].to=v; edge[cnt].w=w; head[u]=cnt;&#125;int main()&#123; int n; for(int i=1;i&lt;=n;i++) &#123; int a,b,wei; addedge(a,b,wei); //如果是无向图，还要addedge(b,a,wei); &#125;&#125; 注意： 这里的next指的是遍历时的下一条边，head指的是遍历时的第一条边，而存边时相当于反过来操作，所以next记录上一条边，而head记录最后一条边。 边的遍历在遍历以x为起点的所有边时，只需要这样就行 for(int i=head[x];i!=0;i=edge[i].next) 这个循环的结束条件是i等于0，因为最后一条边，也就是存边时第一条边，在把head值存进next时，head还没有更新过，也就是0。所以当next返回0时，就说明这些边遍历完毕了。 优势与特点既可以存图，也可以存树，比起邻接矩阵，链式前向星的空间复杂度是O（n），大大节省了存储空间，因为按边存储省掉了很多两点无边的空间。并且在遍历的时候，那些与起点无边相连的点也不需要进行处理，可以说时间和空间都占优势，这就是被OIer们广泛使用的原因。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;using namespace std;int head[100000],cnt;long long ans[1000000];bool vis[1000000];int m,n,s;struct edge&#123; int to; int nextt; int wei;&#125;edge[1000000];void addedge(int x,int y,int z)&#123; edge[++cnt].to=y; edge[cnt].wei=z; edge[cnt].nextt=head[x]; head[x]=cnt;&#125;int main()&#123; cin&gt;&gt;m&gt;&gt;n&gt;&gt;s; for(int i=1;i&lt;=n;i++) &#123; ans[i]=2147483647; &#125; ans[s]=0; for(int i=1;i&lt;=n;i++) &#123; int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; addedge(a,b,c); &#125; int pos=s; while(vis[pos]==0) &#123; long long minn=2147483647; vis[pos]=1; for(int i=head[pos];i!=0;i=edge[i].nextt) &#123; if(!vis[edge[i].to]&amp;&amp;ans[edge[i].to]&gt;ans[pos]+edge[i].wei) &#123; ans[edge[i].to]=ans[pos]+edge[i].wei; &#125; &#125; for(int i=1;i&lt;=m;i++) &#123; if(ans[i]&lt;minn&amp;&amp;vis[i]==0) &#123; minn=ans[i]; pos=i; &#125; &#125; &#125; for(int i=1;i&lt;=m;i++) &#123; cout&lt;&lt;ans[i]&lt;&lt;' '; &#125;&#125; 以上是Dijkstra的基础介绍，上面的这份代码是不加优化的Dijkstra，能通过P3371单源最短路径（弱化版）不过在这道题中会TLE。 优化在上面第五步中：5. 列举所有访问过的的点，找到ans值最小的点 这一步由于每次都要遍历一遍所有点，复杂度为$O(n)$ 不过可以用堆（STL：优先队列）进行优化，复杂度为$O(logn)$ 简单介绍优先队列一种数据结构，支持找出数列中最大值，弹出最大值 重载运算符后还可以维护最小值 代码： 头文件1#include&lt;queue&gt; 定义1priority_queue&lt;int&gt; q; 加入1q.push(a); 弹出最大值1q.pop() 查询最大值1q.top() 详细的可看P3378 【模板】堆 代码对以上代码加入堆优化： 由于每个点有两个值需要存储（$ans$值，点的编号）,所以要用结构体 由于要找最小的点，所以用优先队列时需要重载运算符：123456789struct node&#123; int ans;//ans值 int id;//点编号 bool operator &lt;(const node &amp;x)const//重载运算符 &#123; return x.ans&lt;ans; &#125;&#125;; 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;int head[100000],cnt;long long ans[1000000];bool vis[1000000];int m,n,s;struct edge&#123; int to; int nextt; int wei;&#125;edge[1000000];struct priority&#123; int ans; int id; bool operator &lt;(const priority &amp;x)const &#123; return x.ans&lt;ans; &#125;&#125;;void addedge(int x,int y,int z)&#123; edge[++cnt].to=y; edge[cnt].wei=z; edge[cnt].nextt=head[x]; head[x]=cnt;&#125;priority_queue&lt;priority&gt; q;int main()&#123; cin&gt;&gt;m&gt;&gt;n&gt;&gt;s; for(int i=1;i&lt;=n;i++) &#123; ans[i]=2147483647; &#125; ans[s]=0; for(int i=1;i&lt;=n;i++) &#123; int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; addedge(a,b,c); &#125; int u; q.push((priority)&#123;0,s&#125;); while(!q.empty()) &#123; priority temp=q.top(); q.pop(); u=temp.id; if(!vis[u]) &#123; vis[u]=1; for(int i=head[u];i;i=edge[i].nextt) &#123; int v=edge[i].to; if(ans[v]&gt;ans[u]+edge[i].wei) &#123; ans[v]=ans[u]+edge[i].wei; if(!vis[v]) &#123; q.push((priority)&#123;ans[v],v&#125;); &#125; &#125; &#125; &#125; &#125; for(int i=1;i&lt;=m;i++) &#123; cout&lt;&lt;ans[i]&lt;&lt;' '; &#125;&#125; 感谢收看..]]></content>
      <categories>
        <category>算法</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F03%2F22%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
