<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[加密文章]]></title>
    <url>%2F2019%2F03%2F25%2F%E5%8A%A0%E5%AF%86%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[请输入密码 Incorrect Password! No content to display! U2FsdGVkX1+deiZ0XypMlTeLm3zBNzhrb6udYcc78r40PFdTlaES0Wm3MCH+Fn6tLv0tXgPqr2b2S+vICTjFLBLCVmZEshd/p/lO9w4TmNeY8kATQGrBqN2oBd7TD05QWWg37SfmjBat+B+fR6OzQ2N+Jsjidxmeq69pET4ytGbc+UKhw7cNtmtBz9COVJGlz6n7LlWnSSubI7yzKEWZ9QB6TlNETsNIs3TD5IQ8B0HVbr0ip4ccXIArS2i/uyNvz0WNOPUIr9PWzD5KVIx7kHxVzGzRkF3G3YMyJUq+nrh9gCHTUOLRUoVHDNsk7PEZ6BqXVyFVa5nF6kw7AOWmt+MCFc2PgifXWftJMk9gsFjbT5pOi4n9K2xZys3RIxFN9esP6cuV9B4lxix2ZarpwtrO8YS2t49G2odplJvhRF9mWuAGJTp0021+lrGxF1mA]]></content>
      <categories>
        <category>加密</category>
      </categories>
      <tags>
        <tag>1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客搭建记录]]></title>
    <url>%2F2019%2F03%2F23%2FHexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[2019-3-22 博客搭建在2018haha.github.io上 2019-3-25 博客基本配置完毕 2019-3-25 博客增加了评论功能 搭建记录修改博客内容首次使用1.打开安装包安装Git，Node 2.下载hexo 12npm config set registry https://registry.npm.taobao.orgnpm install -g hexo 3.安装hexo 1hexo init 4.配置github 12git config --global user.email "zfMMG9000@163.com"git config --global user.name "2018haha" 5.绑定github密匙1ssh-keygen 并把路径中id_rsa.pub用记事本打开，复制到github的key上 更改博客设置有两个位置： hexo设置\_config.yml next主题设置\themes\hexo-theme-next-6.7.0\_config.yml 详细请百度 写文章hexo n &quot;文章名&quot; 在\source\_posts中找到文件并编辑 开头几个参数： 1234567---title: categories: 日志mathjax: truetags: [记录,笔记,日志]keywords: [1,2]--- 预览，发布预览：1hexo s 发布：12hexo ghexo d]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>记录</tag>
        <tag>笔记</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dijkstra]]></title>
    <url>%2F2019%2F03%2F22%2F%E9%A2%98%E8%A7%A3-P4779-%E3%80%90%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%EF%BC%88%E6%A0%87%E5%87%86%E7%89%88%EF%BC%89%E3%80%91%2F</url>
    <content type="text"><![CDATA[单源最短路算法——Dijkstra 实现方法：1.定义ans[100000]，ans[i]代表到达i点的最小花费 2.定义bool数组visit，代表是否来过这里 2.ans[起点]=0,其余的赋值为inf 3.定义一个curr变量，visit[current]=1（访问过），代表现在的位置，初始值为起点。 4.列举所有与curr相联通的的点，将这些点(i)的ans值更新： $ ans[i]=min(ans[i],ans[curr]+ $ 到这些点需要的花费 $)$ 5. 列举所有访问过的的点，找到ans值最小的点，赋值给curr，visit[current]=1（访问过） 6 所有点都访问过（visit[i]都==1），程序结束。此时，ans[i]代表从起点到i的最短路径 伪代码123456789101112131415161718192021bool vis[1000000];//是否访问过int ans[1000000];int curr=起点;memset(ans,0x7fffffff,sizeof(ans))while(vis[curr]==0)&#123; vis[curr]=1; for(int i;列举所有curr连通的点） &#123; ans[i]=min(ans[i],ans[curr]+k)//k代表从curr点到i点的最短路 &#125; int minn=2147483647; for(int i=1;i&lt;=m;i++)//列举所有点 &#123; if(vis[i]==1&amp;&amp;ans[i]&lt;minn)//访问过且小 &#123; minn=ans[i];//更新最小值 curr=i;//更新下一个点 &#125; &#125;&#125; 存图方式链式前向星以下是关于链式前向星的介绍 ，会的可以跳过： 边的存储这种存图方式只需要开一个数组存储每个点引出的第一条边，然后存储每个点作为起点的每条边，这样就可以做到不重不漏。 在链式前向星存图中，我们需要定义一个结构体：12345struct EDGE &#123; int next; int to;&#125;edge[1000000]; 和一个数组：1int head[1000000]; 和一个变量：1int cnt=0;//指针 你会发现竟然没存起点！！其实起点是用$head$存的 举例： 如图：这样的一个有向图，输入是： 12341 21 31 42 3 逐步分析：1.输入1 2，代表1连向2。123cnt++;//作为结构体下标，没有意义head[1]=cnt;//结点1的第一个儿子存在了edge[cnt]里面edge[cnt].to=2;结点1的儿子是2 此时：$cnt=1$ $edge$ $cnt=1$ $cnt=2$ $ cnt=3$ $cnt=4$ $to $ $2$ $0$ $ 0$ $0$ $next$ $ 0 $ $0 $ $0$ $0$ $head $ 下标$=1 $ 下标$=2$ 下标$=3 $ 下标$=4 $ 值 $1 $ $ 0 $ $ 0 $ $ 0 $ 2.输入1 3，代表1连向3。12345678910cnt++;head[1]=cnt;edge[cnt].to=3;结点1的儿子是3//这时,3成为了结点1的儿子，不过2被挤了下去...//所以要引入结构体中next元素，记录：3还有个兄弟（next）是2//所以代码要换成：cnt++;edge[cnt].to=3;//结点1连向3edge[cnt].next=head[1];//3的兄弟是2head[1]=cnt;//更新head 此时：$cnt=2$ $edge$ $cnt=1$ $cnt=2$ $ cnt=3$ $cnt=4$ $to $ $2$ $3$ $ 0$ $0$ $next$ $ 0 $ $1 $ $0$ $0$ $head $ 下标$=1 $ 下标$=2$ 下标$=3 $ 下标$=4 $ 值 $2 $ $ 0 $ $ 0 $ $ 0 $ 3.输入1 4，代表1连向4。此时：$cnt=3$ $edge$ $cnt=1$ $cnt=2$ $ cnt=3$ $cnt=4$ $to $ $2$ $3$ $ 4$ $0$ $next$ $ 0 $ $1 $ $2$ $0$ $head $ 下标$=1 $ 下标$=2$ 下标$=3 $ 下标$=4 $ 值 $3 $ $ 0 $ $ 0 $ $ 0 $ 4.输入2 3，代表2连向3。此时：$cnt=4$ $edge$ $cnt=1$ $cnt=2$ $ cnt=3$ $cnt=4$ $to $ $2$ $3$ $ 4$ $3$ $next$ $ 0 $ $1 $ $2$ $0$ $head $ 下标$=1 $ 下标$=2$ 下标$=3 $ 下标$=4 $ 值 $3 $ $ 4 $ $ 0 $ $ 0 $ 注意：$edge[cnt].next$ 和$head[1]$存贮的都是结构体下标（即$cnt$的值）若要访问指向的边的编号，分别用$edge[edge[cnt].next].to$，$edge[head[1]].to$若需要记录权值，在结构体中加入一个元素即可代码：(带权值）123456789101112131415161718192021222324252627#include&lt;iostream&gt;using namespace std;struct edge &#123; int next; int to; int wei;&#125;edge[MAXM];int head[MAXN];//head[i]为i点的第一条边int cnt=0;void addedge(int u,int v,int w) //起点，终点，权值 &#123; edge[++cnt].next=head[u];//更新cnt edge[cnt].to=v; edge[cnt].w=w; head[u]=cnt;&#125;int main()&#123; int n; for(int i=1;i&lt;=n;i++) &#123; int a,b,wei; addedge(a,b,wei); //如果是无向图，还要addedge(b,a,wei); &#125;&#125; 注意： 这里的next指的是遍历时的下一条边，head指的是遍历时的第一条边，而存边时相当于反过来操作，所以next记录上一条边，而head记录最后一条边。 边的遍历在遍历以x为起点的所有边时，只需要这样就行 for(int i=head[x];i!=0;i=edge[i].next) 这个循环的结束条件是i等于0，因为最后一条边，也就是存边时第一条边，在把head值存进next时，head还没有更新过，也就是0。所以当next返回0时，就说明这些边遍历完毕了。 优势与特点既可以存图，也可以存树，比起邻接矩阵，链式前向星的空间复杂度是O（n），大大节省了存储空间，因为按边存储省掉了很多两点无边的空间。并且在遍历的时候，那些与起点无边相连的点也不需要进行处理，可以说时间和空间都占优势，这就是被OIer们广泛使用的原因。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;using namespace std;int head[100000],cnt;long long ans[1000000];bool vis[1000000];int m,n,s;struct edge&#123; int to; int nextt; int wei;&#125;edge[1000000];void addedge(int x,int y,int z)&#123; edge[++cnt].to=y; edge[cnt].wei=z; edge[cnt].nextt=head[x]; head[x]=cnt;&#125;int main()&#123; cin&gt;&gt;m&gt;&gt;n&gt;&gt;s; for(int i=1;i&lt;=n;i++) &#123; ans[i]=2147483647; &#125; ans[s]=0; for(int i=1;i&lt;=n;i++) &#123; int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; addedge(a,b,c); &#125; int pos=s; while(vis[pos]==0) &#123; long long minn=2147483647; vis[pos]=1; for(int i=head[pos];i!=0;i=edge[i].nextt) &#123; if(!vis[edge[i].to]&amp;&amp;ans[edge[i].to]&gt;ans[pos]+edge[i].wei) &#123; ans[edge[i].to]=ans[pos]+edge[i].wei; &#125; &#125; for(int i=1;i&lt;=m;i++) &#123; if(ans[i]&lt;minn&amp;&amp;vis[i]==0) &#123; minn=ans[i]; pos=i; &#125; &#125; &#125; for(int i=1;i&lt;=m;i++) &#123; cout&lt;&lt;ans[i]&lt;&lt;' '; &#125;&#125; 以上是Dijkstra的基础介绍，上面的这份代码是不加优化的Dijkstra，能通过P3371单源最短路径（弱化版）不过在这道题中会TLE。 优化在上面第五步中：5. 列举所有访问过的的点，找到ans值最小的点 这一步由于每次都要遍历一遍所有点，复杂度为$O(n)$ 不过可以用堆（STL：优先队列）进行优化，复杂度为$O(logn)$ 简单介绍优先队列一种数据结构，支持找出数列中最大值，弹出最大值 重载运算符后还可以维护最小值 代码： 头文件1#include&lt;queue&gt; 定义1priority_queue&lt;int&gt; q; 加入1q.push(a); 弹出最大值1q.pop() 查询最大值1q.top() 详细的可看P3378 【模板】堆 代码对以上代码加入堆优化： 由于每个点有两个值需要存储（$ans$值，点的编号）,所以要用结构体 由于要找最小的点，所以用优先队列时需要重载运算符：123456789struct node&#123; int ans;//ans值 int id;//点编号 bool operator &lt;(const node &amp;x)const//重载运算符 &#123; return x.ans&lt;ans; &#125;&#125;; 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;int head[100000],cnt;long long ans[1000000];bool vis[1000000];int m,n,s;struct edge&#123; int to; int nextt; int wei;&#125;edge[1000000];struct priority&#123; int ans; int id; bool operator &lt;(const priority &amp;x)const &#123; return x.ans&lt;ans; &#125;&#125;;void addedge(int x,int y,int z)&#123; edge[++cnt].to=y; edge[cnt].wei=z; edge[cnt].nextt=head[x]; head[x]=cnt;&#125;priority_queue&lt;priority&gt; q;int main()&#123; cin&gt;&gt;m&gt;&gt;n&gt;&gt;s; for(int i=1;i&lt;=n;i++) &#123; ans[i]=2147483647; &#125; ans[s]=0; for(int i=1;i&lt;=n;i++) &#123; int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; addedge(a,b,c); &#125; int u; q.push((priority)&#123;0,s&#125;); while(!q.empty()) &#123; priority temp=q.top(); q.pop(); u=temp.id; if(!vis[u]) &#123; vis[u]=1; for(int i=head[u];i;i=edge[i].nextt) &#123; int v=edge[i].to; if(ans[v]&gt;ans[u]+edge[i].wei) &#123; ans[v]=ans[u]+edge[i].wei; if(!vis[v]) &#123; q.push((priority)&#123;ans[v],v&#125;); &#125; &#125; &#125; &#125; &#125; for(int i=1;i&lt;=m;i++) &#123; cout&lt;&lt;ans[i]&lt;&lt;' '; &#125;&#125; 感谢收看..]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>模板</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F03%2F22%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
