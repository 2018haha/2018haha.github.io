{"meta":{"title":"2018haha's Blog","subtitle":"It just happens and we should live with it.","description":"An OIer From Hrb3z","author":"2018haha","url":"http://yoursite.com","root":"/"},"pages":[{"title":"404","date":"2019-03-25T04:35:15.000Z","updated":"2019-03-25T04:35:16.000Z","comments":true,"path":"404/index.html","permalink":"http://yoursite.com/404/index.html","excerpt":"","text":""},{"title":"关于本站","date":"2019-04-10T08:54:35.000Z","updated":"2020-01-07T14:31:38.000Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"About Me创建者：2018haha:就读于哈三中的高二学生，黑龙江省的蒟蒻OIer. 2019 CSP 后接近退役。 About This Blog本博客主要记录一些我所学习的算法,亦或是一些学习经验。希望本博客能帮助到你。如果你在阅读过程中发现错误发现错误，欢迎尽快向我指出！ Development 2019-3-22 博客搭建在2018haha.github.io上 2019-3-25 博客基本配置完毕 2019-3-25 博客增加了评论功能 2019-3-27 博客 关于 界面写好 2019-4-10 通过Hexo-Admin实现了后台功能 2019-4-11 博客加载速度优化 2019-7-19 复制加入版权信息 2019-7-21 重新编辑关于页面 2020-1-5 开始着手将博客主题更换为material-X AcknowledgementUsmireko神仙帮助我搭建好了本站 Rights** 知识共享 署名-非商业性使用-禁止演绎 4.0 国际 协议（CC BY-NC-ND 4.0）** 以下是一份易于阅读与理解的总结性许可证文本（而非法律性质的授权条款的替代内容）。 你可以自由地：分享 - 在任何媒介或格式下复制并分发本素材。只要遵守下述条款的规定，授权人将不能撤回你使用本创作的自由。 只须遵循以以下条件： 署名 - 你必须予以明确说明，并提供指向本许可证的链接，同时明确说明相较于原始版本创作是否经过修改。你可以采用恰当的形式表述相关信息，但不得以任何方式暗示授权人已为你的使用行为背书。 非商业性使用 - 你不得将本素材用于商业用途。 禁止演绎 - 如果你对本素材进行了重混、转换，或依据本素材进行再创作，则你不能分发经过修改的素材。 不得增加额外限制 - 你不能增设任何法律限制或是技术限制，来限制他人进行本许可证已经允许的行为。 声明： 当你使用本创作中属于公众领域的元素，或当法律有额外或限制条款允许你的使用行为时，不需要遵守本授权协议。 不提供保证。本许可证并不能完全提供你预期需要的所有许可，例如：公共形象权，隐私权，著作人身权等其他权利，这些权利的法律限制可能会限制你对本创作的使用。 ContactQQ:1163291343(请注明省份 &amp;&amp; OIer)"},{"title":"分类","date":"2017-07-19T14:56:27.000Z","updated":"2020-01-05T15:16:02.000Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2076-11-29T08:54:34.955Z","updated":"2019-03-22T05:48:50.000Z","comments":true,"path":"lib/bookmark/index.js","permalink":"http://yoursite.com/lib/bookmark/index.js","excerpt":"","text":"(function (global) { 'use strict'; var storage = global.localStorage; if (storage == null) { // if the localStorage is not exists storage = { // eslint-disable-next-line getItem: function () { return null }, setItem: function () { }, removeItem: function () { }, clear: function () { }, }; } // get the saved bookmark object var getBookmark = function () { var mark = storage.getItem('bookmark'); if (mark == null) { return null; } try { return JSON.parse(mark); } catch (e) { // invalid object saved in the storage // console.warn('Invalid bookmark object.'); return null; } }; var link; // register everything var init = function () { // bookmark-link style var style = global.document.createElement('style'); style.type = 'text/css'; var text = '.book-mark-link{' + 'border-bottom:none;' + 'display:block;' + 'position:fixed;' + 'color:#222;' + 'font-size:26px !important;' + 'top:-10px;left:20px;' + 'transition:.3s;' + '}' + '.book-mark-link:hover,.book-mark-link-fixed{top:-2px}' // do not show when the width is not enough + '@media(max-width:1090px){.book-mark-link{display:none}}'; text = global.document.createTextNode(text); style.appendChild(text); global.document.head.appendChild(style); // create a link element // eslint-disable-next-line max-len link = $(''); $(global.document.body).append(link); var currentTop = 0; // scroll event $(global).on('scroll.bookmark', function () { var top = global.document.documentElement.scrollTop; if (top > 0) { if (currentTop === 0) { link.removeClass('book-mark-link-fixed'); currentTop = top; } } else { if (currentTop > 0) { !link.hasClass('book-mark-link-fixed') && link.addClass('book-mark-link-fixed'); currentTop = 0; } } }); }; var loadBookmark = function () { var mark = getBookmark(); if (mark == null) { return; } // found the bookmark $(function () { init(); link.attr('href', mark.lastUri + '#book:mark'); }); }; var doScroll = function (top) { if (!isNaN(top)) { $(function () { // eslint-disable-next-line max-len $(global.document.documentElement).animate({ 'scrollTop': top }, 'fast'); }); } }; var doSaveScroll = function (path, mark) { if (mark == null) { mark = {}; } var top = global.document.documentElement.scrollTop; mark.lastUri = path; mark[path] = top; storage.setItem('bookmark', JSON.stringify(mark)); link.animate({ top: -26 }, 'fast', function () { setTimeout(function () { link.css('top', ''); }, 400); }); return mark; }; var scrollToMark = function (trigger, hash) { var path = global.location.pathname; var mark = getBookmark(); $(function () { init(); // save the position by clicking the icon link.click(function () { mark = doSaveScroll(path, mark); return false; }); // register beforeunload event when the trigger is auto if (trigger === 'auto') { // register beforeunload event global.addEventListener('beforeunload', function () { doSaveScroll(path, mark); }); } // auto scroll to the position if (mark == null) { return; } // and if the page opens with a specific hash, just jump out var skips = [hash, '#comments']; // eslint-disable-next-line if (skips.filter(function (h) { return h === global.location.hash }).length > 0) { return; } doScroll(mark[path]); }); }; global.bookmark = { loadBookmark: loadBookmark, scrollToMark: scrollToMark, }; })(window);"},{"title":"","date":"2076-11-29T08:54:34.955Z","updated":"2019-03-22T05:48:50.000Z","comments":true,"path":"lib/bookmark/bookmark.min.js","permalink":"http://yoursite.com/lib/bookmark/bookmark.min.js","excerpt":"","text":"!function(o){\"use strict\";var n=o.localStorage;null==n&&(n={getItem:function(){return null},setItem:function(){},removeItem:function(){},clear:function(){}});var t,e=function(){var o=n.getItem(\"bookmark\");if(null==o)return null;try{return JSON.parse(o)}catch(o){return null}},a=function(){var n=o.document.createElement(\"style\");n.type=\"text/css\";var e=\".book-mark-link{border-bottom:none;display:block;position:fixed;color:#222;font-size:26px !important;top:-10px;left:20px;transition:.3s;}.book-mark-link:hover,.book-mark-link-fixed{top:-2px}@media(max-width:1090px){.book-mark-link{display:none}}\";e=o.document.createTextNode(e),n.appendChild(e),o.document.head.appendChild(n),t=$(''),$(o.document.body).append(t);var a=0;$(o).on(\"scroll.bookmark\",function(){var n=o.document.documentElement.scrollTop;n>0?0===a&&(t.removeClass(\"book-mark-link-fixed\"),a=n):a>0&&(!t.hasClass(\"book-mark-link-fixed\")&&t.addClass(\"book-mark-link-fixed\"),a=0)})},r=function(e,a){null==a&&(a={});var r=o.document.documentElement.scrollTop;return a.lastUri=e,a[e]=r,n.setItem(\"bookmark\",JSON.stringify(a)),t.animate({top:-26},\"fast\",function(){setTimeout(function(){t.css(\"top\",\"\")},400)}),a};o.bookmark={loadBookmark:function(){var o=e();null!=o&&$(function(){a(),t.attr(\"href\",o.lastUri+\"#book:mark\")})},scrollToMark:function(n,l){var i=o.location.pathname,c=e();$(function(){var e;a(),t.click(function(){return c=r(i,c),!1}),\"auto\"===n&&o.addEventListener(\"beforeunload\",function(){r(i,c)}),null!=c&&([l,\"#comments\"].filter(function(n){return n===o.location.hash}).length>0||(e=c[i],isNaN(e)||$(function(){$(o.document.documentElement).animate({scrollTop:e},\"fast\")})))})}}}(window);"},{"title":"","date":"2076-11-29T08:54:34.955Z","updated":"2019-03-22T05:48:50.000Z","comments":true,"path":"lib/bookmark/package.json","permalink":"http://yoursite.com/lib/bookmark/package.json","excerpt":"","text":"{\"name\":\"theme-next-bookmark\",\"version\":\"1.0.2\",\"description\":\"A plugin of local-bookmarks for NexT theme.\",\"main\":\"index.js\",\"scripts\":{\"test\":\"eslint index.js\",\"dist\":\"eslint index.js && uglifyjs --compress --mangle -o bookmark.min.js -- index.js\"},\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/theme-next/theme-next-bookmark.git\"},\"keywords\":[\"hexo\",\"theme-next\",\"plugin\",\"bookmark\"],\"author\":\"Tsanie Lily\",\"license\":\"MIT\",\"bugs\":{\"url\":\"https://github.com/theme-next/theme-next-bookmark/issues\"},\"homepage\":\"https://github.com/theme-next/theme-next-bookmark#readme\",\"devDependencies\":{\"eslint\":\"^4.17.0\",\"eslint-config-google\":\"^0.9.1\",\"uglify-js\":\"^3.3.10\"}}"},{"title":"","date":"2076-11-29T08:54:34.955Z","updated":"2019-03-22T05:48:50.000Z","comments":true,"path":"lib/bookmark/README.html","permalink":"http://yoursite.com/lib/bookmark/README.html","excerpt":"","text":"Bookmark for NexT Introduce Bookmark is a plugin that allow the users save their reading position. The users could just click the bookmark icon (like 🔖) in left-top of the page to save the position. And when they visit your blog in the next time, they can continue the last reading position by clicking the bookmark icon from the home page. Installation If you want to use the CDN instead of clone this repo, please jump to the Step 3. Step 1 &rarr; Go to NexT dir Change dir to NexT directory. There must be layout, source, languages and other directories: 123$ cd themes/next$ lsbower.json _config.yml docs gulpfile.coffee languages layout LICENSE.md package.json README.md scripts source test Step 2 &rarr; Get module Install module to source/lib directory: 1$ git clone https://github.com/theme-next/theme-next-bookmark.git source/lib/bookmark Step 3 &rarr; Set it up Enable module in NexT _config.yml file: 1bookmark: true And, if you wants to use the CDN, then need to set: 123vendors: ... bookmark: https://cdn.jsdelivr.net/gh/theme-next/theme-next-bookmark@latest/bookmark.min.js Update 12$ cd themes/next/source/lib/bookmark$ git pull"},{"title":"标签","date":"2019-03-22T05:49:05.000Z","updated":"2020-01-05T15:16:46.000Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"申请友链","date":"2019-04-11T06:29:16.000Z","updated":"2019-04-11T06:29:24.000Z","comments":true,"path":"申请友链/index.html","permalink":"http://yoursite.com/%E7%94%B3%E8%AF%B7%E5%8F%8B%E9%93%BE/index.html","excerpt":"","text":"本站友情链接位于主页左下角 请先将本站加入友链 本站信息： 123本站标题：2018haha' Blog本站链接：https://2018haha.github.io/本站Logo：待定 联系方式：在下面留言或QQ(1163291343）联系我"},{"title":"files","date":"2019-08-31T05:51:31.000Z","updated":"2019-08-31T05:51:32.000Z","comments":true,"path":"files/index.html","permalink":"http://yoursite.com/files/index.html","excerpt":"","text":""},{"title":"图床","date":"2019-07-06T05:09:47.000Z","updated":"2019-08-16T23:50:46.000Z","comments":true,"path":"picture/index.html","permalink":"http://yoursite.com/picture/index.html","excerpt":"","text":""},{"title":"署名-非商业性使用-禁止演绎 3.0 中国大陆(CC BY-NC-ND 3.0 CN)","date":"2019-07-21T03:40:34.000Z","updated":"2019-07-21T03:45:08.000Z","comments":true,"path":"Rights/index.html","permalink":"http://yoursite.com/Rights/index.html","excerpt":"","text":"协议文本本作品（定义如下）的提供是以适用“知识共享公共许可协议”（ 简称“CCPL”或 “许可”）为前提的。本作品受《中华人民共和国著作权法》以及其他可适用法律的保护。对本作品的使用不得超越本许可协议授权的范围。 如您行使本许可授予的使用本作品的权利，就表明您接受并同意遵守本许可协议的所有条款。鉴于本许可为合同，在您接受这些条款和规定的前提下，许可人授予您本许可所包括的权利。 第一条 定义 本作品：指根据本许可协议提供的以任何方式和形式（包括以数字形式）表达之文学、艺术和科学领域的作品，例如：书籍、手册等文字作品；讲课、演讲、讲道及其他同类性质的作品；戏剧或音乐戏剧作品；曲艺作品；舞蹈作品及哑剧作品；配词或不配词的音乐作品；电影作品和以类似摄制电影的方法创作的作品；素描、绘画、书法、建筑、雕塑、雕刻或版画等作品；摄影作品以及以类似摄影的方法创作的作品；杂技艺术作品；实用艺术作品；与地理、地形、建筑或科学有关的插图、地图、设计图、草图及立体的造型作品；以及法律、行政法规规定的其他文学艺术作品。为本许可协议之目的，本协议有关“本作品”的规定适用于表演、录音制品及广播电视节目。 原始作者：就文学或艺术作品而言，指创作本作品的自然人或依法视为本作品作者的法人或其他组织。为本许可之目的，下述情形下的自然人、法人或其他组织适用本许可有关“原始作者”的规定：（1）就表演而言，指演员、歌唱家、音乐家、舞蹈家和其他表演、演唱、演说、朗诵、演奏、表现或者以其它方式表演文学、艺术作品或民间文学艺术的人员；（2）就录音制品而言，指首次将表演的声音或其他声音录制下来的自然人、法人或其他组织；（3）就广播电视节目而言，指传播广播电视节目的组织；（4）作者身份不明的，指行使作品著作权（除署名权外）的作品原件所有人（比如出版社）。 演绎作品：指基于本作品，或基于本作品与其他已存在的作品而创作的作品，例如翻译、改编、编曲或对文学、艺术和科学作品的其他变更，包括以摄制电影的方法对作品的改编，或其他任何对本作品进行改造、转换、或改编后的形式，包含任何可确认为源自原始作品的修改形式。在本许可定义之下构成汇编作品的作品不视为演绎作品。为避免疑义，并为本许可之目的，当演绎对象为音乐作品时，将其依时间序列关系与动态影像配合一致而形成的结果，视为演绎作品。 汇编作品：指由于对内容的选择和编排具有独创性而构成智力创作的文学、艺术或科学作品的集合，其中本作品以完整且未经修改的形式和另外一部或多部作品组成集合的整体，而各组成作品本身是分开且独立的，例如百科全书、文选、数据汇编作品，以及本条第1项所列作品之外的作品或者标的。在本许可定义之下构成汇编作品的作品不视为演绎作品（定义如上）。 许可人：指根据本许可提供本作品的自然人、法人或者其他组织。 您：指以前就本作品没有违反过本许可协议、或曾违反过协议但已获得许可人明示同意、依据本许可行使权利的自然人、法人或者其他组织。 发行：指以出售或者其他权利移转方式向公众提供本作品的原件或者复制件。 公开传播：指公开朗诵本作品以及以任何方式或程序，包括以有线、无线的方式或通过信息网络公开传播本作品的公开朗诵；或向公众提供本作品，使公众可以在自己选定的地点获得本作品；或以任何方式或程序公开表演本作品或向公众传播本作品的表演，包括通过信息网络传播本作品的表演；或以任何方式，包括符号、声音或图像，广播或转播本作品。上述定义包括相关法律规定的“展览”、“表演”、“放映”、“广播”或通过信息网络向公众传播作品等传播方式。 复制：指以印刷、复印、拓印、录音、录像、翻录、翻拍等方式制作本作品的复制件。 人身权：指相关法律赋予作者对本作品所享有的发表权、署名权、修改权以及保护作品完整权。 第二条 合理使用 本许可无意削减、限制或约束您基于《中华人民共和国著作权法》或其他相关法律有关著作权保护的限制或例外的规定对本作品的合理使用。 第三条 授权 根据本许可的条款和条件，许可人在此授予您全球性、免版税、非独占并且在本作品的著作权存续期间内均有效的许可，就本作品行使以下权利： 复制本作品或将本作品收入一个或多个汇编作品中，以及复制汇编作品中收录的本作品； 发行、公开传播本作品（包括汇编作品中收录的本作品）。 以上权利可在任何现有的或者以后出现的并为可适用的法律认可的媒体和形式上行使。上述权利包括为在其他媒体和形式上行使权利而必须进行技术性修改的权利，但除此之外，您不得对本作品进行任何修改。许可人在此保留所有未明示授予的权利，包括但不限于第四条第4项所规定的权利。 第四条 限制 第三条的授权须受以下规定的限制： 您在发行或公开传播本作品时，必须遵守本许可协议。在您发行或公开传播的本作品的每一份复制件中，您必须附上一份本许可协议的复制件或本许可协议的网址（Uniform Resource Identifier）。您不得就本作品提出或增加任何条款，从而限制本许可协议或者限制获得本作品的第三方行使本许可协议所赋予的权利。您不得对本作品进行再许可。您必须在您发行或公开传播的每份作品复制件中完整保留所有与本许可协议及免责条款相关的声明。 在发行或公开传播本作品时，您不得对本作品施加任何技术措施，从而限制从您处获得本作品的第三方行使本许可协议授予的权利。本项（第四条第1项）规定同样适用于收录在汇编作品中的本作品，但并不要求汇编作品中除本作品外的其他作品受本许可协议的约束。在创作汇编作品时，若接到任一许可人的通知，您必须按照其要求，在可行范围内删除汇编作品中根据本协议第四条第3项的要求所作的有关原始作者的身份及其他有关原始作品相关信息的标注。 您不得以任何形式行使本协议第三条授予您的权利去谋取或获得商业利益或私人金钱报酬。若交换过程中未涉及任何商业利益或私人金钱报酬，通过数字文件共享方式或其他方式用本作品去交换其他受著作权保护的作品，将不被视为谋取或获得商业利益或私人金钱报酬。 在发行或公开传播本作品或任何汇编作品时，除非有依据第四条第1项之要求，否则您必须完整保留所有关于本作品的著作权声明，并以适于所使用的媒介或方法的形式提供下述信息：（1）在原始作者的姓名（或笔名）已被提供的情况下，给出该姓名或笔名，或者在原始作者或许可人以许可人的著作权声明或其他合理的方式，指定可以在作品上署名的他方当事人姓名的情况下，指明该他方当事人的名称（“署名人”）；（2）在本作品标题已被提供的情况下，给出本作品的标题；（3）在合理可行的范围内，标明许可人指定需与本作品同时出现的网址，除非该网址没有涉及到本作品的著作权声明或者关于本作品的许可信息。本项（第四条第3项）要求的对作者姓名和作品名称的指明可采取任何合理方式，但在汇编作品中，如果已经指明了汇编作品中所有内含作品的作者，那么对本作品名称和作者姓名的指明须同时出现在任何其他作者姓名出现的地方，并至少与对其他作者的指明一样显著。为避免疑义，本条有关标示作者姓名和作品名称之规定，仅适用于前述署名的用途；除非您事先另行取得原始作者、许可人或署名人的书面同意，否则您不得以明示或者默示的方式主张或暗示，您本人或您对作品的使用与原始作者、许可人或署名人有关联或者已获得上述人士的赞助或者支持。 为避免疑义，针对不同司法管辖区的著作权许可体系作出如下约定： 权利不能放弃的强制许可体系。 在那些许可人不能放弃通过任何法定的或强制的许可方案收取许可使用费的权利的司法管辖区，许可人保留因您行使本许可协议授予的权利而向您收取许可使用费的专有权； 权利可以放弃的强制许可体系。 在那些许可人可以放弃通过任何法定的或强制的许可方案收取许可使用费的权利的司法管辖区，许可人放弃因您行使本许可协议授予的权利而向您收取许可使用费的专有权；但若您行使本许可协议授予的权利时未遵守本许可协议第四条第2项有关非商业性使用的规定，则许可人保留向您收取本作品许可使用费的权利； 自愿许可体系。 在实行著作权自愿许可的司法管辖区，若您行使本许可协议授予的权利时未遵守本许可协议第四条第2项有关非商业性使用的规定，则许可人保留向您收取本作品许可使用费的权利，许可人可以自行或者通过所参加的著作权集体管理组织向您收取本作品的许可使用费。 除非其他法律法规另有规定，您在复制、发行或者公开表演本作品，或者复制、发行或者公开表演作为任何汇编作品一部分的本作品时，不得歪曲、损害或者以其他方式损害本作品，导致原始作者的名誉或者荣誉受损。 第五条 声明、保证和免责 除非本许可的当事人相互以书面的方式做出相反约定，且在相关法律所允许的最大范围内，否则许可人按其现状提供本作品，对本作品不作任何明示或者默示、依照法律或者其他规定的陈述或担保，包括但是不限于任何有关可否商业性使用、是否符合特定的目的、不具有潜在的或者其他缺陷、准确性或者不存在不论能否被发现的错误的担保。有些司法管辖区不允许排除前述默示保证，因此这些排除性规定并不一定适用于您。 第六条 责任限制 除非属于相关法律所要求的范围，许可人在任何情况下都不对您因本许可或因使用本作品而产生的任何直接损失、间接损失或惩罚性赔偿负责，即使许可人已被告知发生此类损害的可能性。 第七条 许可终止 在您违反本许可协议任何条款时，本许可及其所授予的权利将自动终止。然而，根据本许可从您处获取汇编作品的自然人、法人或者其他组织，如果他们仍完全遵守相关条款，则对他们的许可不会随之终止。即使本许可被终止，第一条、第二条、第五条、第六条、第七条以及第八条仍然有效。 在上述条款及条件的前提下，此处授予的许可在法定著作权保护期限内有效。即便如此，许可人保留依其他许可条款发行本作品及在任何时候停止发行本作品的权利；但是，许可人的上述权利不能被用于撤销本许可或任何其他在本许可条款下授予的或必须授予的许可，除本条第1项指明的终止外，本许可将保持其完全效力。 第八条 其他事项 当您发行、公开传播本作品或其汇编作品时，许可人给获得作品的第三方提供本作品的许可，其条款和条件与您所获得的许可相同。 如因相关法律，本许可的某一条款无效或不能履行，本许可其余条款的有效性和可履行性不受影响。如本许可的当事人未采取进一步措施，此类无效条款应在必要范围内进行最低限度的修改以使其有效和可履行。 除非当事人书面同意并签字放弃某条款和允许某违约行为，本许可的任何条款或规定都不应被视为已被放弃，或被视为允许此违约行为。 本许可构成相关当事人与本授权作品相关的全部协议。除已在此处确认的之外，并不存在任何与本作品相关的谅解备忘录、协议或声明。许可人不受您提出的任何附加规定的约束。未经许可人和您双方书面同意，本许可不得更改。"},{"title":"","date":"2076-11-29T08:54:34.955Z","updated":"2019-12-28T07:08:08.000Z","comments":true,"path":"files/2019vedio/index.html","permalink":"http://yoursite.com/files/2019vedio/index.html","excerpt":"","text":"jQuery+CSS3仿星球大战3D字幕引导特效 Your browser does not support the audio element. Episode II 3059 A.D. A black box is found somewhere on the earth，which records a history thousands of years ago. It is regarded as one of the warmest memories in 21st century by historians. 2018 A.D. A group of people gather together. Getting through countless difficulties, they are writing one after another glorious history together with their efforts. 2019 A.D. After an intense battle lasted for a year, 41 fighters are renuited, preparing for a new journey in this sacred place. What challenges will they meet? Let's see together..."},{"title":"","date":"2076-11-29T08:54:34.955Z","updated":"2019-12-27T10:07:26.000Z","comments":true,"path":"files/2019vedio/css/starwar.css","permalink":"http://yoursite.com/files/2019vedio/css/starwar.css","excerpt":"","text":"/* * ALL CREDIT GOES TO * ChristianSwift * http://www.dingnaiwen.xyz/ * * Follow GPL */ * { padding: 0; margin: 0; } body, html { width: 100%; height: 100%; font-family: \"Droid Sans\", arial, verdana, sans-serif; font-weight: 700; color: #FFC803; /*background-color: #000;*/ overflow: hidden; } p#start { position: relative; width: 16em; font-size: 200%; font-weight: 400; margin: 20% auto; color: #4ee; opacity: 0; z-index: 1; -webkit-animation: intro 2s ease-out; -moz-animation: intro 2s ease-out; -ms-animation: intro 2s ease-out; -o-animation: intro 2s ease-out; animation: intro 2s ease-out; } @-webkit-keyframes intro { 0% { opacity: 1; } 90% { opacity: 1; } 100% { opacity: 0; } } @-moz-keyframes intro { 0% { opacity: 1; } 90% { opacity: 1; } 100% { opacity: 0; } } @-ms-keyframes intro { 0% { opacity: 1; } 90% { opacity: 1; } 100% { opacity: 0; } } @-o-keyframes intro { 0% { opacity: 1; } 90% { opacity: 1; } 100% { opacity: 0; } } @keyframes intro { 0% { opacity: 1; } 90% { opacity: 1; } 100% { opacity: 0; } } h1 { position: absolute; width: 2.6em; left: 50%; top: 25%; font-size: 50em; text-align: justify; margin-left: -1.3em; line-height: 0.8em; letter-spacing: -0.05em; color: #000; text-shadow: -2px -2px 0 #FFC803, 2px -2px 0 #FFC803, -2px 2px 0 #FFC803, 2px 2px 0 #FFC803; opacity: 0; z-index: 1; -webkit-animation: logo 5s ease-out 2.5s; -moz-animation: logo 5s ease-out 2.5s; -ms-animation: logo 5s ease-out 2.5s; -o-animation: logo 5s ease-out 2.5s; animation: logo 5s ease-out 2.5s; } h1 sub { display: block; font-size: 0.3em; letter-spacing: 0; line-height: 0.8em; } @-webkit-keyframes logo { 0% { -webkit-transform: scale(1); opacity: 1; } 50% { opacity: 1; } 100% { -webkit-transform: scale(0.1); opacity: 0; } } @-moz-keyframes logo { 0% { -moz-transform: scale(1); opacity: 1; } 50% { opacity: 1; } 100% { -moz-transform: scale(0.1); opacity: 0; } } @-ms-keyframes logo { 0% { -ms-transform: scale(1); opacity: 1; } 50% { opacity: 1; } 100% { -ms-transform: scale(0.1); opacity: 0; } } @-o-keyframes logo { 0% { -o-transform: scale(1); opacity: 1; } 50% { opacity: 1; } 100% { -o-transform: scale(0.1); opacity: 0; } } @keyframes logo { 0% { transform: scale(1); opacity: 1; } 50% { opacity: 1; } 100% { transform: scale(0.1); opacity: 0; } } /* the interesting 3D scrolling stuff */ #titles { position: absolute; width: 14em; height: 50em; bottom: 0; left: 50%; margin-left: -7em; font-size: 850%; text-align: justify; overflow: hidden; -webkit-transform-origin: 50% 100%; -moz-transform-origin: 50% 100%; -ms-transform-origin: 50% 100%; -o-transform-origin: 50% 100%; transform-origin: 50% 100%; -webkit-transform: perspective(300px) rotateX(25deg); -moz-transform: perspective(300px) rotateX(25deg); -ms-transform: perspective(300px) rotateX(25deg); -o-transform: perspective(300px) rotateX(25deg); transform: perspective(300px) rotateX(25deg); } #titles:after { position: absolute; content: ' '; left: 0; right: 0; top: 0; bottom: 60%; background-image: -webkit-linear-gradient(top, rgba(0, 0, 0, 1) 0%, transparent 100%); background-image: -moz-linear-gradient(top, rgba(0, 0, 0, 1) 0%, transparent 100%); background-image: -ms-linear-gradient(top, rgba(0, 0, 0, 1) 0%, transparent 100%); background-image: -o-linear-gradient(top, rgba(0, 0, 0, 1) 0%, transparent 100%); background-image: linear-gradient(top, rgba(0, 0, 0, 1) 0%, transparent 100%); pointer-events: none; } #titles p { text-align: justify; margin: 0.8em 0; } #titles p.center { text-align: center; } #titles a { color: #FFC803; text-decoration: underline; } #titlecontent { position: absolute; top: 100%; -webkit-animation: scroll 270s linear 4s infinite; -moz-animation: scroll 270s linear 4s infinite; -ms-animation: scroll 270s linear 4s infinite; -o-animation: scroll 270s linear 4s infinite; animation: scroll 270s linear 4s infinite; } /* animation */ @-webkit-keyframes scroll { 0% { top: 100%; } 100% { top: -170%; } } @-moz-keyframes scroll { 0% { top: 100%; } 100% { top: -170%; } } @-ms-keyframes scroll { 0% { top: 100%; } 100% { top: -170%; } } @-o-keyframes scroll { 0% { top: 100%; } 100% { top: -170%; } } @keyframes scroll { 0% { top: 100%; } 100% { top: -170%; } }"},{"title":"","date":"2076-11-29T08:54:34.955Z","updated":"2019-08-31T03:42:10.000Z","comments":true,"path":"files/20190831/result.html","permalink":"http://yoursite.com/files/20190831/result.html","excerpt":"","text":"th, td {padding-left: 1em; padding-right: 1em;}比赛结果排名表排名名称balldivtreecard总分1h3z智旭生1001001001004001hsdfz徐朝睿1001001001004001hsdfz王羽婷1001001001004001hsdfz郭青硕1001001001004001std1001001001004006hsdfz田泽宇100401001003407h3z佟祥正10010010053057h3z周大福10010050553057hsdfz敖之远100100505530510h3z武帅丞90100100029011h3z朱峰7010090026011hsdfz孟祥瑞10010006026013hsdfz张琢悦9040010023014hsdfz张昊洋9020100021015h3z王星博0100901020016ssy柏一航3010100014017hsdfz张中天0404008018ssy余文博020002018ssy史博辰020002020ssy关天阳001001021ssy刘可一0000021ssy寇启瑞0000021ssy张鑫0000021ssy段苏航0000021ssy罗经纬00000选手：h3z佟祥正试题 ball&nbsp;&nbsp;源程序：ball.cpp测试点输入文件测试结果运行用时内存消耗得分#1ball1.in答案正确0.015 s1.410 MB10#2ball2.in答案正确0.000 s1.211 MB10#3ball3.in答案正确0.000 s1.207 MB10#4ball4.in答案正确0.000 s1.211 MB10#5ball5.in答案正确0.000 s1.586 MB10#6ball6.in答案正确0.015 s1.664 MB10#7ball7.in答案正确0.000 s1.426 MB10#8ball8.in答案正确0.015 s1.328 MB10#9ball9.in答案正确0.000 s1.613 MB10#10ball10.in答案正确0.000 s1.605 MB10试题 div&nbsp;&nbsp;源程序：div.cpp测试点输入文件测试结果运行用时内存消耗得分#1div1.in答案正确0.000 s1.188 MB10#2div2.in答案正确0.000 s1.188 MB10#3div3.in答案正确0.000 s1.188 MB10#4div4.in答案正确0.000 s1.188 MB10#5div5.in答案正确0.000 s1.188 MB10#6div6.in答案正确0.000 s1.188 MB10#7div7.in答案正确0.000 s1.188 MB10#8div8.in答案正确0.000 s1.188 MB10#9div9.in答案正确0.000 s1.188 MB10#10div10.in答案正确0.000 s1.188 MB10试题 tree&nbsp;&nbsp;源程序：tree.cpp测试点输入文件测试结果运行用时内存消耗得分#1tree1.in答案正确0.015 s2.660 MB10#2tree2.in答案正确0.000 s1.289 MB10#3tree3.in答案正确0.000 s1.301 MB10#4tree4.in答案正确0.000 s1.285 MB10#5tree5.in答案正确0.000 s1.293 MB10#6tree6.in答案正确0.015 s1.914 MB10#7tree7.in答案正确0.000 s1.902 MB10#8tree8.in答案正确0.015 s1.898 MB10#9tree9.in答案正确0.015 s2.008 MB10#10tree10.in答案正确0.000 s1.918 MB10试题 card&nbsp;&nbsp;源程序：card.cpp测试点输入文件测试结果运行用时内存消耗得分#1card1.in答案正确0.000 s1.312 MB5#2card2.in答案错误 (...)0.000 s1.309 MB0#3card3.in答案错误 (...)0.000 s1.312 MB0#4card4.in答案错误 (...)0.000 s1.316 MB0#5card5.in答案错误 (...)0.000 s1.316 MB0#6card6.in答案错误 (...)0.000 s1.316 MB0#7card7.in答案错误 (...)0.218 s5.082 MB0#8card8.in答案错误 (...)0.234 s5.082 MB0#9card9.in答案错误 (...)0.234 s5.078 MB0#10card10.in答案错误 (...)0.218 s5.082 MB0#11card11.in答案错误 (...)0.218 s5.082 MB0#12card12.in答案错误 (...)0.234 s5.078 MB0#13card13.in答案错误 (...)0.234 s5.082 MB0#14card14.in答案错误 (...)0.218 s5.078 MB0#15card15.in答案错误 (...)0.234 s5.082 MB0#16card16.in答案错误 (...)0.218 s5.082 MB0#17card17.in答案错误 (...)0.202 s5.082 MB0#18card18.in答案错误 (...)0.234 s5.082 MB0#19card19.in答案错误 (...)0.218 s5.082 MB0#20card20.in答案错误 (...)0.234 s5.082 MB0返回顶部选手：h3z周大福试题 ball&nbsp;&nbsp;源程序：ball.cpp测试点输入文件测试结果运行用时内存消耗得分#1ball1.in答案正确0.000 s1.477 MB10#2ball2.in答案正确0.000 s1.438 MB10#3ball3.in答案正确0.000 s1.438 MB10#4ball4.in答案正确0.000 s1.438 MB10#5ball5.in答案正确0.015 s2.125 MB10#6ball6.in答案正确0.015 s2.270 MB10#7ball7.in答案正确0.015 s1.840 MB10#8ball8.in答案正确0.031 s1.660 MB10#9ball9.in答案正确0.015 s2.160 MB10#10ball10.in答案正确0.015 s2.160 MB10试题 div&nbsp;&nbsp;源程序：div.cpp测试点输入文件测试结果运行用时内存消耗得分#1div1.in答案正确0.000 s1.438 MB10#2div2.in答案正确0.000 s1.434 MB10#3div3.in答案正确0.000 s1.434 MB10#4div4.in答案正确0.015 s1.438 MB10#5div5.in答案正确0.000 s1.438 MB10#6div6.in答案正确0.000 s1.434 MB10#7div7.in答案正确0.000 s1.434 MB10#8div8.in答案正确0.000 s1.438 MB10#9div9.in答案正确0.000 s1.434 MB10#10div10.in答案正确0.000 s1.434 MB10试题 tree&nbsp;&nbsp;源程序：tree.cpp测试点输入文件测试结果运行用时内存消耗得分#1tree1.in运行时错误不可用不可用0#2tree2.in答案正确0.000 s1.473 MB10#3tree3.in答案正确0.000 s1.484 MB10#4tree4.in答案错误 (...)0.000 s1.473 MB0#5tree5.in答案错误 (...)0.000 s1.480 MB0#6tree6.in答案正确0.046 s2.230 MB10#7tree7.in答案错误 (...)0.046 s2.211 MB0#8tree8.in答案正确0.015 s2.207 MB10#9tree9.in答案正确0.062 s2.340 MB10#10tree10.in答案错误 (...)0.062 s2.234 MB0试题 card&nbsp;&nbsp;源程序：card.cpp测试点输入文件测试结果运行用时内存消耗得分#1card1.in答案正确0.000 s1.488 MB5#2card2.in答案错误 (...)0.000 s1.492 MB0#3card3.in答案正确0.015 s1.492 MB5#4card4.in答案错误 (...)0.015 s1.488 MB0#5card5.in答案错误 (...)0.000 s1.492 MB0#6card6.in答案错误 (...)0.000 s1.484 MB0#7card7.in答案正确0.702 s4.504 MB5#8card8.in答案错误 (...)0.780 s4.500 MB0#9card9.in答案错误 (...)0.795 s4.500 MB0#10card10.in答案正确0.748 s4.504 MB5#11card11.in答案错误 (...)0.717 s4.500 MB0#12card12.in答案正确0.717 s4.504 MB5#13card13.in答案正确0.811 s4.504 MB5#14card14.in答案正确0.748 s4.500 MB5#15card15.in运行超时不可用不可用0#16card16.in运行超时不可用不可用0#17card17.in答案正确0.733 s4.500 MB5#18card18.in答案正确0.780 s4.504 MB5#19card19.in答案正确0.702 s4.500 MB5#20card20.in答案正确0.780 s4.500 MB5返回顶部选手：h3z智旭生试题 ball&nbsp;&nbsp;源程序：ball.cpp测试点输入文件测试结果运行用时内存消耗得分#1ball1.in答案正确0.015 s2.113 MB10#2ball2.in答案正确0.000 s1.441 MB10#3ball3.in答案正确0.000 s1.441 MB10#4ball4.in答案正确0.000 s1.438 MB10#5ball5.in答案正确0.015 s2.723 MB10#6ball6.in答案正确0.000 s3.004 MB10#7ball7.in答案正确0.015 s2.191 MB10#8ball8.in答案正确0.015 s1.855 MB10#9ball9.in答案正确0.015 s2.820 MB10#10ball10.in答案正确0.015 s2.801 MB10试题 div&nbsp;&nbsp;源程序：div.cpp测试点输入文件测试结果运行用时内存消耗得分#1div1.in答案正确0.000 s1.406 MB10#2div2.in答案正确0.000 s1.406 MB10#3div3.in答案正确0.000 s1.410 MB10#4div4.in答案正确0.000 s1.406 MB10#5div5.in答案正确0.000 s1.406 MB10#6div6.in答案正确0.000 s1.402 MB10#7div7.in答案正确0.000 s1.406 MB10#8div8.in答案正确0.000 s1.402 MB10#9div9.in答案正确0.000 s1.402 MB10#10div10.in答案正确0.000 s1.402 MB10试题 tree&nbsp;&nbsp;源程序：tree.cpp测试点输入文件测试结果运行用时内存消耗得分#1tree1.in答案正确0.015 s2.992 MB10#2tree2.in答案正确0.015 s1.500 MB10#3tree3.in答案正确0.015 s1.508 MB10#4tree4.in答案正确0.000 s1.504 MB10#5tree5.in答案正确0.000 s1.504 MB10#6tree6.in答案正确0.015 s2.254 MB10#7tree7.in答案正确0.015 s2.242 MB10#8tree8.in答案正确0.000 s2.242 MB10#9tree9.in答案正确0.000 s2.375 MB10#10tree10.in答案正确0.015 s2.258 MB10试题 card&nbsp;&nbsp;源程序：card.cpp测试点输入文件测试结果运行用时内存消耗得分#1card1.in答案正确0.000 s1.449 MB5#2card2.in答案正确0.000 s1.453 MB5#3card3.in答案正确0.000 s1.453 MB5#4card4.in答案正确0.000 s1.453 MB5#5card5.in答案正确0.000 s1.449 MB5#6card6.in答案正确0.000 s1.449 MB5#7card7.in答案正确0.156 s5.215 MB5#8card8.in答案正确0.187 s5.215 MB5#9card9.in答案正确0.187 s5.215 MB5#10card10.in答案正确0.187 s5.215 MB5#11card11.in答案正确0.187 s5.215 MB5#12card12.in答案正确0.202 s5.211 MB5#13card13.in答案正确0.171 s5.219 MB5#14card14.in答案正确0.156 s5.215 MB5#15card15.in答案正确0.156 s5.219 MB5#16card16.in答案正确0.187 s5.215 MB5#17card17.in答案正确0.156 s5.215 MB5#18card18.in答案正确0.156 s5.215 MB5#19card19.in答案正确0.171 s5.215 MB5#20card20.in答案正确0.171 s5.219 MB5返回顶部选手：h3z朱峰试题 ball&nbsp;&nbsp;源程序：ball.cpp测试点输入文件测试结果运行用时内存消耗得分#1ball1.in答案正确0.265 s1.457 MB10#2ball2.in答案正确0.000 s1.422 MB10#3ball3.in答案正确0.000 s1.422 MB10#4ball4.in答案正确0.015 s1.418 MB10#5ball5.in答案正确0.920 s2.406 MB10#6ball6.in运行超时不可用不可用0#7ball7.in答案正确0.327 s1.992 MB10#8ball8.in答案正确0.109 s1.742 MB10#9ball9.in运行超时1.045 s2.469 MB0#10ball10.in运行超时1.107 s2.465 MB0试题 div&nbsp;&nbsp;源程序：div.cpp测试点输入文件测试结果运行用时内存消耗得分#1div1.in答案正确0.000 s1.379 MB10#2div2.in答案正确0.000 s1.379 MB10#3div3.in答案正确0.000 s1.375 MB10#4div4.in答案正确0.000 s1.383 MB10#5div5.in答案正确0.000 s1.375 MB10#6div6.in答案正确0.000 s1.379 MB10#7div7.in答案正确0.000 s1.375 MB10#8div8.in答案正确0.000 s1.379 MB10#9div9.in答案正确0.000 s1.375 MB10#10div10.in答案正确0.000 s1.379 MB10试题 tree&nbsp;&nbsp;源程序：tree.cpp测试点输入文件测试结果运行用时内存消耗得分#1tree1.in运行时错误不可用不可用0#2tree2.in答案正确0.000 s1.477 MB10#3tree3.in答案正确0.000 s1.492 MB10#4tree4.in答案正确0.000 s1.477 MB10#5tree5.in答案正确0.000 s1.484 MB10#6tree6.in答案正确0.015 s2.363 MB10#7tree7.in答案正确0.000 s2.344 MB10#8tree8.in答案正确0.000 s2.336 MB10#9tree9.in答案正确0.015 s2.500 MB10#10tree10.in答案正确0.015 s2.367 MB10试题 card&nbsp;&nbsp;未找到源程序返回顶部选手：h3z武帅丞试题 ball&nbsp;&nbsp;源程序：ball.cpp测试点输入文件测试结果运行用时内存消耗得分#1ball1.in答案错误 (...)0.000 s1.410 MB0#2ball2.in答案正确0.000 s1.215 MB10#3ball3.in答案正确0.000 s1.215 MB10#4ball4.in答案正确0.015 s1.215 MB10#5ball5.in答案正确0.000 s1.891 MB10#6ball6.in答案正确0.015 s2.039 MB10#7ball7.in答案正确0.015 s1.609 MB10#8ball8.in答案正确0.000 s1.438 MB10#9ball9.in答案正确0.015 s1.941 MB10#10ball10.in答案正确0.015 s1.938 MB10试题 div&nbsp;&nbsp;源程序：div.cpp测试点输入文件测试结果运行用时内存消耗得分#1div1.in答案正确0.000 s1.176 MB10#2div2.in答案正确0.000 s1.176 MB10#3div3.in答案正确0.000 s1.180 MB10#4div4.in答案正确0.000 s1.180 MB10#5div5.in答案正确0.000 s1.176 MB10#6div6.in答案正确0.000 s1.176 MB10#7div7.in答案正确0.000 s1.180 MB10#8div8.in答案正确0.000 s1.176 MB10#9div9.in答案正确0.000 s1.176 MB10#10div10.in答案正确0.000 s1.176 MB10试题 tree&nbsp;&nbsp;源程序：tree.cpp测试点输入文件测试结果运行用时内存消耗得分#1tree1.in答案正确0.015 s2.906 MB10#2tree2.in答案正确0.000 s1.289 MB10#3tree3.in答案正确0.000 s1.297 MB10#4tree4.in答案正确0.000 s1.289 MB10#5tree5.in答案正确0.000 s1.293 MB10#6tree6.in答案正确0.000 s1.918 MB10#7tree7.in答案正确0.015 s1.906 MB10#8tree8.in答案正确0.015 s1.898 MB10#9tree9.in答案正确0.000 s2.008 MB10#10tree10.in答案正确0.000 s1.922 MB10试题 card&nbsp;&nbsp;源程序：card.cpp测试点输入文件测试结果运行用时内存消耗得分#1card1.in答案错误 (...)0.000 s1.977 MB0#2card2.in答案错误 (...)0.000 s1.977 MB0#3card3.in答案错误 (...)0.000 s1.977 MB0#4card4.in答案错误 (...)0.000 s1.977 MB0#5card5.in答案错误 (...)0.000 s1.980 MB0#6card6.in答案错误 (...)0.000 s1.980 MB0#7card7.in答案错误 (...)0.109 s3.477 MB0#8card8.in答案错误 (...)0.109 s3.480 MB0#9card9.in答案错误 (...)0.109 s3.477 MB0#10card10.in答案错误 (...)0.109 s3.477 MB0#11card11.in答案错误 (...)0.093 s3.480 MB0#12card12.in答案错误 (...)0.093 s3.477 MB0#13card13.in答案错误 (...)0.093 s3.477 MB0#14card14.in答案错误 (...)0.093 s3.480 MB0#15card15.in答案错误 (...)0.124 s3.477 MB0#16card16.in答案错误 (...)0.109 s3.477 MB0#17card17.in答案错误 (...)0.124 s3.477 MB0#18card18.in答案错误 (...)0.109 s3.480 MB0#19card19.in答案错误 (...)0.093 s3.477 MB0#20card20.in答案错误 (...)0.109 s3.477 MB0返回顶部选手：h3z王星博试题 ball&nbsp;&nbsp;源程序：ball.cpp测试点输入文件测试结果运行用时内存消耗得分#1ball1.in答案错误 (...)0.000 s1.242 MB0#2ball2.in答案错误 (...)0.000 s1.207 MB0#3ball3.in答案错误 (...)0.000 s1.207 MB0#4ball4.in答案错误 (...)0.000 s1.207 MB0#5ball5.in答案错误 (...)0.000 s1.285 MB0#6ball6.in答案错误 (...)0.015 s1.297 MB0#7ball7.in答案错误 (...)0.000 s1.254 MB0#8ball8.in答案错误 (...)0.000 s1.230 MB0#9ball9.in答案错误 (...)0.000 s1.297 MB0#10ball10.in答案错误 (...)0.000 s1.293 MB0试题 div&nbsp;&nbsp;源程序：div.cpp测试点输入文件测试结果运行用时内存消耗得分#1div1.in答案正确0.000 s1.242 MB10#2div2.in答案正确0.015 s1.246 MB10#3div3.in答案正确0.000 s1.246 MB10#4div4.in答案正确0.000 s1.242 MB10#5div5.in答案正确0.000 s1.246 MB10#6div6.in答案正确0.015 s1.242 MB10#7div7.in答案正确0.000 s1.242 MB10#8div8.in答案正确0.000 s1.242 MB10#9div9.in答案正确0.000 s1.246 MB10#10div10.in答案正确0.000 s1.242 MB10试题 tree&nbsp;&nbsp;源程序：tree.cpp测试点输入文件测试结果运行用时内存消耗得分#1tree1.in运行时错误不可用不可用0#2tree2.in答案正确0.000 s1.273 MB10#3tree3.in答案正确0.000 s1.289 MB10#4tree4.in答案正确0.000 s1.270 MB10#5tree5.in答案正确0.000 s1.277 MB10#6tree6.in答案正确0.015 s1.840 MB10#7tree7.in答案正确0.015 s1.832 MB10#8tree8.in答案正确0.000 s1.824 MB10#9tree9.in答案正确0.000 s1.918 MB10#10tree10.in答案正确0.015 s1.844 MB10试题 card&nbsp;&nbsp;源程序：card.cpp测试点输入文件测试结果运行用时内存消耗得分#1card1.in答案正确0.000 s1.266 MB5#2card2.in答案错误 (...)0.000 s1.266 MB0#3card3.in答案正确0.000 s1.266 MB5#4card4.in答案错误 (...)0.000 s1.266 MB0#5card5.in答案错误 (...)0.015 s1.266 MB0#6card6.in答案错误 (...)0.015 s1.266 MB0#7card7.in运行时错误不可用不可用0#8card8.in运行时错误不可用不可用0#9card9.in运行时错误不可用不可用0#10card10.in运行时错误不可用不可用0#11card11.in运行时错误不可用不可用0#12card12.in运行时错误不可用不可用0#13card13.in运行时错误不可用不可用0#14card14.in运行时错误不可用不可用0#15card15.in运行时错误不可用不可用0#16card16.in运行时错误不可用不可用0#17card17.in运行时错误不可用不可用0#18card18.in运行时错误不可用不可用0#19card19.in运行时错误不可用不可用0#20card20.in运行时错误不可用不可用0返回顶部选手：hsdfz孟祥瑞试题 ball&nbsp;&nbsp;源程序：ball.cpp测试点输入文件测试结果运行用时内存消耗得分#1ball1.in答案正确0.000 s1.641 MB10#2ball2.in答案正确0.000 s1.441 MB10#3ball3.in答案正确0.000 s1.441 MB10#4ball4.in答案正确0.000 s1.445 MB10#5ball5.in答案正确0.015 s2.875 MB10#6ball6.in答案正确0.000 s3.188 MB10#7ball7.in答案正确0.000 s2.281 MB10#8ball8.in答案正确0.000 s1.906 MB10#9ball9.in答案正确0.000 s2.977 MB10#10ball10.in答案正确0.015 s2.961 MB10试题 div&nbsp;&nbsp;源程序：div.cpp测试点输入文件测试结果运行用时内存消耗得分#1div1.in答案正确0.000 s1.422 MB10#2div2.in答案正确0.000 s1.422 MB10#3div3.in答案正确0.000 s1.426 MB10#4div4.in答案正确0.000 s1.422 MB10#5div5.in答案正确0.000 s1.422 MB10#6div6.in答案正确0.000 s1.426 MB10#7div7.in答案正确0.000 s1.422 MB10#8div8.in答案正确0.000 s1.422 MB10#9div9.in答案正确0.000 s1.426 MB10#10div10.in答案正确0.000 s1.422 MB10试题 tree&nbsp;&nbsp;源程序：tree.cpp测试点输入文件测试结果运行用时内存消耗得分#1tree1.in答案错误 (...)0.015 s3.137 MB0#2tree2.in答案错误 (...)0.000 s1.453 MB0#3tree3.in答案错误 (...)0.000 s1.465 MB0#4tree4.in答案错误 (...)0.000 s1.449 MB0#5tree5.in答案错误 (...)0.000 s1.461 MB0#6tree6.in运行超时不可用不可用0#7tree7.in运行超时不可用不可用0#8tree8.in运行超时不可用不可用0#9tree9.in运行超时不可用不可用0#10tree10.in运行超时不可用不可用0试题 card&nbsp;&nbsp;源程序：card.cpp测试点输入文件测试结果运行用时内存消耗得分#1card1.in答案正确0.000 s1.441 MB5#2card2.in答案正确0.015 s1.441 MB5#3card3.in答案正确0.000 s1.441 MB5#4card4.in答案正确0.000 s1.441 MB5#5card5.in答案正确0.000 s1.441 MB5#6card6.in答案正确0.000 s1.445 MB5#7card7.in答案正确0.093 s3.703 MB5#8card8.in答案正确0.078 s3.699 MB5#9card9.in答案错误 (...)0.062 s3.703 MB0#10card10.in答案错误 (...)0.078 s3.699 MB0#11card11.in答案正确0.046 s3.703 MB5#12card12.in答案错误 (...)0.078 s3.699 MB0#13card13.in答案错误 (...)0.062 s3.699 MB0#14card14.in答案正确0.078 s3.703 MB5#15card15.in答案错误 (...)0.078 s3.699 MB0#16card16.in答案正确0.046 s3.699 MB5#17card17.in答案正确0.078 s3.699 MB5#18card18.in答案错误 (...)0.078 s3.703 MB0#19card19.in答案错误 (...)0.078 s3.703 MB0#20card20.in答案错误 (...)0.093 s3.703 MB0返回顶部选手：hsdfz张中天试题 ball&nbsp;&nbsp;源程序：ball.cpp测试点输入文件测试结果运行用时内存消耗得分#1ball1.in答案错误 (...)0.000 s1.461 MB0#2ball2.in答案错误 (...)0.000 s1.422 MB0#3ball3.in答案错误 (...)0.000 s1.418 MB0#4ball4.in答案错误 (...)0.000 s1.418 MB0#5ball5.in答案错误 (...)0.000 s1.492 MB0#6ball6.in答案错误 (...)0.000 s1.512 MB0#7ball7.in答案错误 (...)0.000 s1.465 MB0#8ball8.in答案错误 (...)0.000 s1.441 MB0#9ball9.in答案错误 (...)0.000 s1.500 MB0#10ball10.in答案错误 (...)0.000 s1.500 MB0试题 div&nbsp;&nbsp;源程序：div.cpp测试点输入文件测试结果运行用时内存消耗得分#1div1.in答案正确0.000 s1.387 MB10#2div2.in答案正确0.000 s1.391 MB10#3div3.in答案正确0.000 s1.391 MB10#4div4.in答案正确0.000 s1.391 MB10#5div5.in答案错误 (...)0.000 s1.391 MB0#6div6.in答案错误 (...)0.000 s1.387 MB0#7div7.in答案错误 (...)0.000 s1.395 MB0#8div8.in答案错误 (...)0.000 s1.387 MB0#9div9.in答案错误 (...)0.000 s1.387 MB0#10div10.in答案错误 (...)0.000 s1.391 MB0试题 tree&nbsp;&nbsp;源程序：tree.cpp测试点输入文件测试结果运行用时内存消耗得分#1tree1.in运行超时不可用不可用0#2tree2.in答案正确0.078 s1.500 MB10#3tree3.in答案正确0.171 s1.539 MB10#4tree4.in答案正确0.062 s1.504 MB10#5tree5.in答案正确0.109 s1.512 MB10#6tree6.in运行超时不可用不可用0#7tree7.in运行超时不可用不可用0#8tree8.in运行超时不可用不可用0#9tree9.in运行超时不可用不可用0#10tree10.in运行超时不可用不可用0试题 card&nbsp;&nbsp;源程序：card.cpp测试点输入文件测试结果运行用时内存消耗得分#1card1.in答案错误 (...)0.000 s1.430 MB0#2card2.in答案错误 (...)0.000 s1.426 MB0#3card3.in答案错误 (...)0.000 s1.430 MB0#4card4.in答案错误 (...)0.000 s1.426 MB0#5card5.in答案错误 (...)0.000 s1.430 MB0#6card6.in答案错误 (...)0.000 s1.426 MB0#7card7.in答案错误 (...)0.156 s3.312 MB0#8card8.in答案错误 (...)0.124 s3.309 MB0#9card9.in答案错误 (...)0.171 s3.312 MB0#10card10.in答案错误 (...)0.171 s3.309 MB0#11card11.in答案错误 (...)0.109 s3.309 MB0#12card12.in答案错误 (...)0.093 s3.309 MB0#13card13.in答案错误 (...)0.124 s3.309 MB0#14card14.in答案错误 (...)0.062 s3.309 MB0#15card15.in答案错误 (...)0.218 s3.309 MB0#16card16.in答案错误 (...)0.093 s3.309 MB0#17card17.in答案错误 (...)0.140 s3.309 MB0#18card18.in答案错误 (...)0.171 s3.312 MB0#19card19.in答案错误 (...)0.187 s3.309 MB0#20card20.in答案错误 (...)0.234 s3.312 MB0返回顶部选手：hsdfz张昊洋试题 ball&nbsp;&nbsp;源程序：ball.cpp测试点输入文件测试结果运行用时内存消耗得分#1ball1.in答案错误 (...)0.015 s1.430 MB0#2ball2.in答案正确0.000 s1.395 MB10#3ball3.in答案正确0.000 s1.391 MB10#4ball4.in答案正确0.000 s1.395 MB10#5ball5.in答案正确0.000 s1.625 MB10#6ball6.in答案正确0.000 s1.664 MB10#7ball7.in答案正确0.000 s1.527 MB10#8ball8.in答案正确0.000 s1.469 MB10#9ball9.in答案正确0.015 s1.633 MB10#10ball10.in答案正确0.015 s1.633 MB10试题 div&nbsp;&nbsp;源程序：div.cpp测试点输入文件测试结果运行用时内存消耗得分#1div1.in答案错误 (...)0.000 s1.457 MB0#2div2.in答案错误 (...)0.000 s1.461 MB0#3div3.in答案错误 (...)0.000 s1.453 MB0#4div4.in答案正确0.000 s1.449 MB10#5div5.in答案错误 (...)0.000 s1.449 MB0#6div6.in答案错误 (...)0.000 s1.453 MB0#7div7.in答案正确0.000 s1.445 MB10#8div8.in答案错误 (...)0.015 s1.453 MB0#9div9.in答案错误 (...)0.000 s1.457 MB0#10div10.in答案错误 (...)0.000 s1.449 MB0试题 tree&nbsp;&nbsp;源程序：tree.cpp测试点输入文件测试结果运行用时内存消耗得分#1tree1.in答案正确0.015 s2.832 MB10#2tree2.in答案正确0.000 s1.398 MB10#3tree3.in答案正确0.000 s1.410 MB10#4tree4.in答案正确0.000 s1.402 MB10#5tree5.in答案正确0.000 s1.406 MB10#6tree6.in答案正确0.015 s2.094 MB10#7tree7.in答案正确0.015 s2.082 MB10#8tree8.in答案正确0.015 s2.074 MB10#9tree9.in答案正确0.000 s2.203 MB10#10tree10.in答案正确0.031 s2.098 MB10试题 card&nbsp;&nbsp;源程序：card.cpp测试点输入文件测试结果运行用时内存消耗得分#1card1.in答案错误 (...)0.000 s2.164 MB0#2card2.in答案错误 (...)0.000 s2.168 MB0#3card3.in答案错误 (...)0.000 s2.168 MB0#4card4.in答案错误 (...)0.000 s2.168 MB0#5card5.in答案错误 (...)0.000 s2.164 MB0#6card6.in答案错误 (...)0.031 s2.164 MB0#7card7.in答案错误 (...)0.124 s3.668 MB0#8card8.in答案错误 (...)0.140 s3.668 MB0#9card9.in答案错误 (...)0.124 s3.672 MB0#10card10.in答案错误 (...)0.109 s3.668 MB0#11card11.in答案错误 (...)0.109 s3.672 MB0#12card12.in答案错误 (...)0.124 s3.668 MB0#13card13.in答案错误 (...)0.093 s3.672 MB0#14card14.in答案错误 (...)0.109 s3.668 MB0#15card15.in答案错误 (...)0.109 s3.668 MB0#16card16.in答案错误 (...)0.140 s3.668 MB0#17card17.in答案错误 (...)0.140 s3.668 MB0#18card18.in答案错误 (...)0.124 s3.672 MB0#19card19.in答案错误 (...)0.109 s3.668 MB0#20card20.in答案错误 (...)0.124 s3.672 MB0返回顶部选手：hsdfz张琢悦试题 ball&nbsp;&nbsp;源程序：ball.cpp测试点输入文件测试结果运行用时内存消耗得分#1ball1.in答案错误 (...)0.000 s2.086 MB0#2ball2.in答案正确0.000 s1.414 MB10#3ball3.in答案正确0.000 s1.418 MB10#4ball4.in答案正确0.000 s1.414 MB10#5ball5.in答案正确0.000 s2.691 MB10#6ball6.in答案正确0.000 s2.973 MB10#7ball7.in答案正确0.000 s2.160 MB10#8ball8.in答案正确0.000 s1.828 MB10#9ball9.in答案正确0.015 s2.789 MB10#10ball10.in答案正确0.015 s2.773 MB10试题 div&nbsp;&nbsp;源程序：div.cpp测试点输入文件测试结果运行用时内存消耗得分#1div1.in答案正确0.000 s1.395 MB10#2div2.in答案正确0.000 s1.391 MB10#3div3.in答案正确0.000 s1.395 MB10#4div4.in答案正确0.000 s1.391 MB10#5div5.in答案错误 (...)0.000 s1.457 MB0#6div6.in答案错误 (...)0.000 s1.453 MB0#7div7.in答案错误 (...)0.000 s1.453 MB0#8div8.in答案错误 (...)0.000 s1.703 MB0#9div9.in答案错误 (...)0.000 s1.703 MB0#10div10.in答案错误 (...)0.000 s1.699 MB0试题 tree&nbsp;&nbsp;未找到源程序试题 card&nbsp;&nbsp;源程序：card.cpp测试点输入文件测试结果运行用时内存消耗得分#1card1.in答案正确0.000 s1.414 MB5#2card2.in答案正确0.015 s1.414 MB5#3card3.in答案正确0.000 s1.418 MB5#4card4.in答案正确0.015 s1.414 MB5#5card5.in答案正确0.015 s1.414 MB5#6card6.in答案正确0.000 s1.414 MB5#7card7.in答案正确0.109 s3.293 MB5#8card8.in答案正确0.109 s3.293 MB5#9card9.in答案正确0.109 s3.293 MB5#10card10.in答案正确0.124 s3.297 MB5#11card11.in答案正确0.124 s3.293 MB5#12card12.in答案正确0.109 s3.293 MB5#13card13.in答案正确0.124 s3.293 MB5#14card14.in答案正确0.093 s3.293 MB5#15card15.in答案正确0.109 s3.293 MB5#16card16.in答案正确0.093 s3.297 MB5#17card17.in答案正确0.140 s3.293 MB5#18card18.in答案正确0.109 s3.293 MB5#19card19.in答案正确0.124 s3.293 MB5#20card20.in答案正确0.109 s3.297 MB5返回顶部选手：hsdfz徐朝睿试题 ball&nbsp;&nbsp;源程序：ball.cpp测试点输入文件测试结果运行用时内存消耗得分#1ball1.in答案正确0.000 s1.434 MB10#2ball2.in答案正确0.000 s1.398 MB10#3ball3.in答案正确0.000 s1.395 MB10#4ball4.in答案正确0.000 s1.398 MB10#5ball5.in答案正确0.015 s1.625 MB10#6ball6.in答案正确0.015 s1.672 MB10#7ball7.in答案正确0.015 s1.531 MB10#8ball8.in答案正确0.015 s1.469 MB10#9ball9.in答案正确0.000 s1.637 MB10#10ball10.in答案正确0.000 s1.637 MB10试题 div&nbsp;&nbsp;源程序：div.cpp测试点输入文件测试结果运行用时内存消耗得分#1div1.in答案正确0.000 s1.422 MB10#2div2.in答案正确0.000 s1.418 MB10#3div3.in答案正确0.000 s1.422 MB10#4div4.in答案正确0.000 s1.422 MB10#5div5.in答案正确0.000 s1.418 MB10#6div6.in答案正确0.000 s1.422 MB10#7div7.in答案正确0.000 s1.426 MB10#8div8.in答案正确0.000 s1.422 MB10#9div9.in答案正确0.000 s1.422 MB10#10div10.in答案正确0.000 s1.422 MB10试题 tree&nbsp;&nbsp;源程序：tree.cpp测试点输入文件测试结果运行用时内存消耗得分#1tree1.in答案正确0.031 s3.562 MB10#2tree2.in答案正确0.015 s1.945 MB10#3tree3.in答案正确0.000 s1.965 MB10#4tree4.in答案正确0.015 s1.941 MB10#5tree5.in答案正确0.000 s1.945 MB10#6tree6.in答案正确0.031 s2.891 MB10#7tree7.in答案正确0.015 s2.883 MB10#8tree8.in答案正确0.000 s2.859 MB10#9tree9.in答案正确0.031 s3.047 MB10#10tree10.in答案正确0.015 s2.887 MB10试题 card&nbsp;&nbsp;源程序：card.cpp测试点输入文件测试结果运行用时内存消耗得分#1card1.in答案正确0.000 s1.453 MB5#2card2.in答案正确0.015 s1.449 MB5#3card3.in答案正确0.000 s1.449 MB5#4card4.in答案正确0.000 s1.449 MB5#5card5.in答案正确0.000 s1.453 MB5#6card6.in答案正确0.000 s1.449 MB5#7card7.in答案正确0.109 s3.711 MB5#8card8.in答案正确0.109 s3.707 MB5#9card9.in答案正确0.093 s3.707 MB5#10card10.in答案正确0.124 s3.707 MB5#11card11.in答案正确0.093 s3.707 MB5#12card12.in答案正确0.124 s3.711 MB5#13card13.in答案正确0.124 s3.707 MB5#14card14.in答案正确0.124 s3.711 MB5#15card15.in答案正确0.109 s3.707 MB5#16card16.in答案正确0.093 s3.707 MB5#17card17.in答案正确0.093 s3.707 MB5#18card18.in答案正确0.124 s3.707 MB5#19card19.in答案正确0.124 s3.711 MB5#20card20.in答案正确0.124 s3.711 MB5返回顶部选手：hsdfz敖之远试题 ball&nbsp;&nbsp;源程序：ball.cpp测试点输入文件测试结果运行用时内存消耗得分#1ball1.in答案正确0.015 s1.441 MB10#2ball2.in答案正确0.000 s1.402 MB10#3ball3.in答案正确0.000 s1.402 MB10#4ball4.in答案正确0.000 s1.402 MB10#5ball5.in答案正确0.000 s1.777 MB10#6ball6.in答案正确0.000 s1.859 MB10#7ball7.in答案正确0.000 s1.621 MB10#8ball8.in答案正确0.000 s1.527 MB10#9ball9.in答案正确0.000 s1.805 MB10#10ball10.in答案正确0.015 s1.801 MB10试题 div&nbsp;&nbsp;源程序：div.cpp测试点输入文件测试结果运行用时内存消耗得分#1div1.in答案正确0.000 s1.391 MB10#2div2.in答案正确0.000 s1.391 MB10#3div3.in答案正确0.015 s1.391 MB10#4div4.in答案正确0.000 s1.395 MB10#5div5.in答案正确0.000 s1.395 MB10#6div6.in答案正确0.000 s1.395 MB10#7div7.in答案正确0.000 s1.387 MB10#8div8.in答案正确0.000 s1.395 MB10#9div9.in答案正确0.000 s1.391 MB10#10div10.in答案正确0.015 s1.391 MB10试题 tree&nbsp;&nbsp;源程序：tree.cpp测试点输入文件测试结果运行用时内存消耗得分#1tree1.in答案正确0.000 s2.859 MB10#2tree2.in答案正确0.000 s1.387 MB10#3tree3.in答案正确0.015 s1.395 MB10#4tree4.in答案正确0.000 s1.387 MB10#5tree5.in答案正确0.000 s1.387 MB10#6tree6.in运行超时不可用不可用0#7tree7.in运行超时不可用不可用0#8tree8.in运行超时不可用不可用0#9tree9.in运行超时不可用不可用0#10tree10.in运行超时不可用不可用0试题 card&nbsp;&nbsp;源程序：card.cpp测试点输入文件测试结果运行用时内存消耗得分#1card1.in答案正确0.015 s1.453 MB5#2card2.in答案错误 (...)0.000 s1.453 MB0#3card3.in答案正确0.000 s1.457 MB5#4card4.in答案错误 (...)0.000 s1.453 MB0#5card5.in答案错误 (...)0.000 s1.453 MB0#6card6.in答案错误 (...)0.015 s1.453 MB0#7card7.in答案正确0.140 s3.719 MB5#8card8.in答案错误 (...)0.093 s3.719 MB0#9card9.in答案错误 (...)0.156 s3.723 MB0#10card10.in答案正确0.093 s3.723 MB5#11card11.in答案错误 (...)0.109 s3.723 MB0#12card12.in答案正确0.109 s3.723 MB5#13card13.in答案正确0.156 s3.723 MB5#14card14.in答案正确0.171 s3.723 MB5#15card15.in答案错误 (...)0.187 s3.723 MB0#16card16.in答案错误 (...)0.140 s3.719 MB0#17card17.in答案正确0.140 s3.723 MB5#18card18.in答案正确0.156 s3.719 MB5#19card19.in答案正确0.140 s3.723 MB5#20card20.in答案正确0.109 s3.719 MB5返回顶部选手：hsdfz王羽婷试题 ball&nbsp;&nbsp;源程序：ball.cpp测试点输入文件测试结果运行用时内存消耗得分#1ball1.in答案正确0.000 s2.105 MB10#2ball2.in答案正确0.000 s1.438 MB10#3ball3.in答案正确0.000 s1.434 MB10#4ball4.in答案正确0.000 s1.434 MB10#5ball5.in答案正确0.000 s2.715 MB10#6ball6.in答案正确0.031 s2.996 MB10#7ball7.in答案正确0.015 s2.180 MB10#8ball8.in答案正确0.000 s1.848 MB10#9ball9.in答案正确0.000 s2.809 MB10#10ball10.in答案正确0.015 s2.797 MB10试题 div&nbsp;&nbsp;源程序：div.cpp测试点输入文件测试结果运行用时内存消耗得分#1div1.in答案正确0.000 s1.398 MB10#2div2.in答案正确0.000 s1.402 MB10#3div3.in答案正确0.000 s1.398 MB10#4div4.in答案正确0.000 s1.402 MB10#5div5.in答案正确0.000 s1.398 MB10#6div6.in答案正确0.000 s1.398 MB10#7div7.in答案正确0.000 s1.402 MB10#8div8.in答案正确0.000 s1.406 MB10#9div9.in答案正确0.000 s1.398 MB10#10div10.in答案正确0.000 s1.402 MB10试题 tree&nbsp;&nbsp;源程序：tree.cpp测试点输入文件测试结果运行用时内存消耗得分#1tree1.in答案正确0.015 s2.707 MB10#2tree2.in答案正确0.000 s1.406 MB10#3tree3.in答案正确0.000 s1.414 MB10#4tree4.in答案正确0.000 s1.402 MB10#5tree5.in答案正确0.000 s1.406 MB10#6tree6.in答案正确0.015 s1.973 MB10#7tree7.in答案正确0.015 s1.957 MB10#8tree8.in答案正确0.000 s1.957 MB10#9tree9.in答案正确0.015 s2.055 MB10#10tree10.in答案正确0.000 s1.973 MB10试题 card&nbsp;&nbsp;源程序：card.cpp测试点输入文件测试结果运行用时内存消耗得分#1card1.in答案正确0.000 s1.453 MB5#2card2.in答案正确0.000 s1.453 MB5#3card3.in答案正确0.000 s1.453 MB5#4card4.in答案正确0.000 s1.457 MB5#5card5.in答案正确0.000 s1.457 MB5#6card6.in答案正确0.000 s1.457 MB5#7card7.in答案正确0.093 s2.965 MB5#8card8.in答案正确0.109 s2.961 MB5#9card9.in答案正确0.109 s2.961 MB5#10card10.in答案正确0.093 s2.961 MB5#11card11.in答案正确0.124 s2.961 MB5#12card12.in答案正确0.078 s2.965 MB5#13card13.in答案正确0.109 s2.965 MB5#14card14.in答案正确0.109 s2.961 MB5#15card15.in答案正确0.109 s2.961 MB5#16card16.in答案正确0.109 s2.961 MB5#17card17.in答案正确0.093 s2.961 MB5#18card18.in答案正确0.093 s2.965 MB5#19card19.in答案正确0.109 s2.965 MB5#20card20.in答案正确0.124 s2.961 MB5返回顶部选手：hsdfz田泽宇试题 ball&nbsp;&nbsp;源程序：ball.cpp测试点输入文件测试结果运行用时内存消耗得分#1ball1.in答案正确0.000 s1.473 MB10#2ball2.in答案正确0.000 s1.434 MB10#3ball3.in答案正确0.000 s1.430 MB10#4ball4.in答案正确0.000 s1.434 MB10#5ball5.in答案正确0.015 s1.809 MB10#6ball6.in答案正确0.015 s1.891 MB10#7ball7.in答案正确0.015 s1.652 MB10#8ball8.in答案正确0.000 s1.559 MB10#9ball9.in答案正确0.000 s1.840 MB10#10ball10.in答案正确0.000 s1.832 MB10试题 div&nbsp;&nbsp;源程序：div.cpp测试点输入文件测试结果运行用时内存消耗得分#1div1.in答案正确0.015 s1.441 MB10#2div2.in答案正确0.000 s1.438 MB10#3div3.in答案正确0.000 s1.438 MB10#4div4.in答案正确0.000 s1.441 MB10#5div5.in运行超时不可用不可用0#6div6.in运行超时不可用不可用0#7div7.in运行超时不可用不可用0#8div8.in运行超时不可用不可用0#9div9.in运行超时不可用不可用0#10div10.in运行超时不可用不可用0试题 tree&nbsp;&nbsp;源程序：tree.cpp测试点输入文件测试结果运行用时内存消耗得分#1tree1.in答案正确0.015 s2.812 MB10#2tree2.in答案正确0.000 s1.438 MB10#3tree3.in答案正确0.000 s1.449 MB10#4tree4.in答案正确0.015 s1.438 MB10#5tree5.in答案正确0.000 s1.445 MB10#6tree6.in答案正确0.031 s2.066 MB10#7tree7.in答案正确0.000 s2.051 MB10#8tree8.in答案正确0.031 s2.051 MB10#9tree9.in答案正确0.015 s2.168 MB10#10tree10.in答案正确0.015 s2.074 MB10试题 card&nbsp;&nbsp;源程序：card.cpp测试点输入文件测试结果运行用时内存消耗得分#1card1.in答案正确0.000 s1.469 MB5#2card2.in答案正确0.000 s1.465 MB5#3card3.in答案正确0.000 s1.469 MB5#4card4.in答案正确0.015 s1.465 MB5#5card5.in答案正确0.000 s1.469 MB5#6card6.in答案正确0.000 s1.469 MB5#7card7.in答案正确0.156 s6.195 MB5#8card8.in答案正确0.140 s6.191 MB5#9card9.in答案正确0.202 s6.195 MB5#10card10.in答案正确0.202 s6.195 MB5#11card11.in答案正确0.187 s6.191 MB5#12card12.in答案正确0.202 s6.191 MB5#13card13.in答案正确0.187 s6.191 MB5#14card14.in答案正确0.202 s6.195 MB5#15card15.in答案正确0.218 s6.191 MB5#16card16.in答案正确0.218 s6.191 MB5#17card17.in答案正确0.171 s6.191 MB5#18card18.in答案正确0.202 s6.191 MB5#19card19.in答案正确0.218 s6.195 MB5#20card20.in答案正确0.202 s6.191 MB5返回顶部选手：hsdfz郭青硕试题 ball&nbsp;&nbsp;源程序：ball.cpp测试点输入文件测试结果运行用时内存消耗得分#1ball1.in答案正确0.000 s1.434 MB10#2ball2.in答案正确0.015 s1.398 MB10#3ball3.in答案正确0.000 s1.398 MB10#4ball4.in答案正确0.000 s1.398 MB10#5ball5.in答案正确0.000 s1.469 MB10#6ball6.in答案正确0.000 s1.488 MB10#7ball7.in答案正确0.015 s1.441 MB10#8ball8.in答案正确0.000 s1.418 MB10#9ball9.in答案正确0.000 s1.477 MB10#10ball10.in答案正确0.000 s1.477 MB10试题 div&nbsp;&nbsp;源程序：div.cpp测试点输入文件测试结果运行用时内存消耗得分#1div1.in答案正确0.000 s1.363 MB10#2div2.in答案正确0.000 s1.359 MB10#3div3.in答案正确0.000 s1.363 MB10#4div4.in答案正确0.000 s1.359 MB10#5div5.in答案正确0.000 s1.363 MB10#6div6.in答案正确0.000 s1.359 MB10#7div7.in答案正确0.000 s1.359 MB10#8div8.in答案正确0.000 s1.363 MB10#9div9.in答案正确0.000 s1.367 MB10#10div10.in答案正确0.000 s1.363 MB10试题 tree&nbsp;&nbsp;源程序：tree.cpp测试点输入文件测试结果运行用时内存消耗得分#1tree1.in答案正确0.046 s3.684 MB10#2tree2.in答案正确0.000 s2.148 MB10#3tree3.in答案正确0.015 s2.168 MB10#4tree4.in答案正确0.015 s2.148 MB10#5tree5.in答案正确0.015 s2.156 MB10#6tree6.in答案正确0.046 s3.059 MB10#7tree7.in答案正确0.062 s3.047 MB10#8tree8.in答案正确0.046 s3.012 MB10#9tree9.in答案正确0.046 s3.176 MB10#10tree10.in答案正确0.046 s3.039 MB10试题 card&nbsp;&nbsp;源程序：card.cpp测试点输入文件测试结果运行用时内存消耗得分#1card1.in答案正确0.000 s1.430 MB5#2card2.in答案正确0.000 s1.426 MB5#3card3.in答案正确0.000 s1.434 MB5#4card4.in答案正确0.015 s1.426 MB5#5card5.in答案正确0.000 s1.426 MB5#6card6.in答案正确0.000 s1.430 MB5#7card7.in答案正确0.062 s4.434 MB5#8card8.in答案正确0.078 s4.438 MB5#9card9.in答案正确0.062 s4.441 MB5#10card10.in答案正确0.078 s4.441 MB5#11card11.in答案正确0.062 s4.438 MB5#12card12.in答案正确0.078 s4.438 MB5#13card13.in答案正确0.031 s4.441 MB5#14card14.in答案正确0.062 s4.434 MB5#15card15.in答案正确0.062 s4.438 MB5#16card16.in答案正确0.046 s4.434 MB5#17card17.in答案正确0.062 s4.438 MB5#18card18.in答案正确0.078 s4.441 MB5#19card19.in答案正确0.078 s4.438 MB5#20card20.in答案正确0.078 s4.438 MB5返回顶部选手：ssy余文博试题 ball&nbsp;&nbsp;未找到源程序试题 div&nbsp;&nbsp;源程序：div.cpp测试点输入文件测试结果运行用时内存消耗得分#1div1.in答案正确0.000 s1.430 MB10#2div2.in答案错误 (...)0.000 s1.430 MB0#3div3.in答案正确0.000 s1.430 MB10#4div4.in答案错误 (...)0.000 s1.430 MB0#5div5.in运行超时不可用不可用0#6div6.in答案错误 (...)0.000 s1.430 MB0#7div7.in运行超时不可用不可用0#8div8.in运行超时不可用不可用0#9div9.in运行超时不可用不可用0#10div10.in运行超时不可用不可用0试题 tree&nbsp;&nbsp;未找到源程序试题 card&nbsp;&nbsp;源程序：card.cpp测试点输入文件测试结果运行用时内存消耗得分#1card1.in答案错误 (...)0.015 s1.484 MB0#2card2.in答案错误 (...)0.015 s1.484 MB0#3card3.in答案错误 (...)0.015 s1.480 MB0#4card4.in答案错误 (...)0.015 s1.480 MB0#5card5.in答案错误 (...)0.015 s1.480 MB0#6card6.in答案错误 (...)0.000 s1.480 MB0#7card7.in运行超时不可用不可用0#8card8.in运行超时不可用不可用0#9card9.in运行超时不可用不可用0#10card10.in运行超时不可用不可用0#11card11.in运行超时不可用不可用0#12card12.in运行超时不可用不可用0#13card13.in运行超时不可用不可用0#14card14.in运行超时不可用不可用0#15card15.in运行超时不可用不可用0#16card16.in运行超时不可用不可用0#17card17.in运行超时不可用不可用0#18card18.in运行超时不可用不可用0#19card19.in运行超时不可用不可用0#20card20.in运行超时不可用不可用0返回顶部选手：ssy关天阳试题 ball&nbsp;&nbsp;源程序：ball.cpp测试点输入文件测试结果运行用时内存消耗得分#1ball1.in运行时错误不可用不可用0#2ball2.in答案错误 (...)0.000 s1.359 MB0#3ball3.in答案错误 (...)0.000 s1.359 MB0#4ball4.in答案错误 (...)0.000 s1.363 MB0#5ball5.in运行时错误不可用不可用0#6ball6.in运行时错误不可用不可用0#7ball7.in运行时错误不可用不可用0#8ball8.in运行时错误不可用不可用0#9ball9.in运行时错误不可用不可用0#10ball10.in运行时错误不可用不可用0试题 div&nbsp;&nbsp;源程序：div.cpp测试点输入文件测试结果运行用时内存消耗得分#1div1.in文件错误 (...)0.000 s1.359 MB0#2div2.in文件错误 (...)0.015 s1.359 MB0#3div3.in文件错误 (...)0.000 s1.363 MB0#4div4.in文件错误 (...)0.000 s1.363 MB0#5div5.in文件错误 (...)0.000 s1.363 MB0#6div6.in文件错误 (...)0.000 s1.363 MB0#7div7.in文件错误 (...)0.000 s1.363 MB0#8div8.in文件错误 (...)0.000 s1.363 MB0#9div9.in文件错误 (...)0.000 s1.363 MB0#10div10.in文件错误 (...)0.000 s1.359 MB0试题 tree&nbsp;&nbsp;源程序：tree.cpp测试点输入文件测试结果运行用时内存消耗得分#1tree1.in答案正确0.000 s1.559 MB10#2tree2.in答案错误 (...)0.000 s1.430 MB0#3tree3.in答案错误 (...)0.000 s1.430 MB0#4tree4.in答案错误 (...)0.000 s1.430 MB0#5tree5.in答案错误 (...)0.000 s1.434 MB0#6tree6.in答案错误 (...)0.000 s1.555 MB0#7tree7.in答案错误 (...)0.000 s1.555 MB0#8tree8.in答案错误 (...)0.015 s1.555 MB0#9tree9.in答案错误 (...)0.015 s1.578 MB0#10tree10.in答案错误 (...)0.015 s1.555 MB0试题 card&nbsp;&nbsp;未找到源程序返回顶部选手：ssy刘可一试题 ball&nbsp;&nbsp;未找到源程序试题 div&nbsp;&nbsp;源程序：div.cpp测试点输入文件测试结果运行用时内存消耗得分#1div1.in运行时错误不可用不可用0#2div2.in运行时错误不可用不可用0#3div3.in运行时错误不可用不可用0#4div4.in运行时错误不可用不可用0#5div5.in运行时错误不可用不可用0#6div6.in运行时错误不可用不可用0#7div7.in运行时错误不可用不可用0#8div8.in运行时错误不可用不可用0#9div9.in运行时错误不可用不可用0#10div10.in运行时错误不可用不可用0试题 tree&nbsp;&nbsp;未找到源程序试题 card&nbsp;&nbsp;源程序：card.cpp测试点输入文件测试结果运行用时内存消耗得分#1card1.in答案错误 (...)0.000 s2.203 MB0#2card2.in答案错误 (...)0.015 s2.199 MB0#3card3.in答案错误 (...)0.000 s2.203 MB0#4card4.in答案错误 (...)0.015 s2.199 MB0#5card5.in答案错误 (...)0.015 s2.203 MB0#6card6.in答案错误 (...)0.000 s2.199 MB0#7card7.in运行超时不可用不可用0#8card8.in运行超时不可用不可用0#9card9.in运行超时不可用不可用0#10card10.in运行超时不可用不可用0#11card11.in运行超时不可用不可用0#12card12.in运行超时不可用不可用0#13card13.in运行超时不可用不可用0#14card14.in运行超时不可用不可用0#15card15.in运行超时不可用不可用0#16card16.in运行超时不可用不可用0#17card17.in运行超时不可用不可用0#18card18.in运行超时不可用不可用0#19card19.in运行超时不可用不可用0#20card20.in运行超时不可用不可用0返回顶部选手：ssy史博辰试题 ball&nbsp;&nbsp;源程序：ball.cpp测试点输入文件测试结果运行用时内存消耗得分#1ball1.in答案错误 (...)0.015 s3.359 MB0#2ball2.in答案错误 (...)0.000 s3.320 MB0#3ball3.in答案错误 (...)0.000 s3.320 MB0#4ball4.in答案错误 (...)0.000 s3.320 MB0#5ball5.in答案错误 (...)0.031 s3.398 MB0#6ball6.in答案错误 (...)0.031 s3.410 MB0#7ball7.in答案错误 (...)0.015 s3.359 MB0#8ball8.in答案错误 (...)0.015 s3.340 MB0#9ball9.in答案错误 (...)0.031 s3.395 MB0#10ball10.in答案错误 (...)0.031 s3.395 MB0试题 div&nbsp;&nbsp;源程序：div.cpp测试点输入文件测试结果运行用时内存消耗得分#1div1.in答案正确0.000 s1.422 MB10#2div2.in答案错误 (...)0.000 s1.422 MB0#3div3.in答案错误 (...)0.000 s1.422 MB0#4div4.in答案正确0.000 s1.422 MB10#5div5.in运行超时不可用不可用0#6div6.in答案错误 (...)0.998 s1.426 MB0#7div7.in运行超时不可用不可用0#8div8.in运行超时不可用不可用0#9div9.in运行超时不可用不可用0#10div10.in运行超时不可用不可用0试题 tree&nbsp;&nbsp;未找到源程序试题 card&nbsp;&nbsp;未找到源程序返回顶部选手：ssy寇启瑞试题 ball&nbsp;&nbsp;未找到源程序试题 div&nbsp;&nbsp;源程序：div.cpp测试点输入文件测试结果运行用时内存消耗得分#1div1.in超过空间限制不可用不可用0#2div2.in超过空间限制不可用不可用0#3div3.in超过空间限制不可用不可用0#4div4.in超过空间限制不可用不可用0#5div5.in超过空间限制不可用不可用0#6div6.in超过空间限制不可用不可用0#7div7.in超过空间限制不可用不可用0#8div8.in超过空间限制不可用不可用0#9div9.in超过空间限制不可用不可用0#10div10.in超过空间限制不可用不可用0试题 tree&nbsp;&nbsp;未找到源程序试题 card&nbsp;&nbsp;源程序：card.cpp测试点输入文件测试结果运行用时内存消耗得分#1card1.in超过空间限制不可用不可用0#2card2.in超过空间限制不可用不可用0#3card3.in超过空间限制不可用不可用0#4card4.in超过空间限制不可用不可用0#5card5.in超过空间限制不可用不可用0#6card6.in超过空间限制不可用不可用0#7card7.in超过空间限制不可用不可用0#8card8.in超过空间限制不可用不可用0#9card9.in超过空间限制不可用不可用0#10card10.in超过空间限制不可用不可用0#11card11.in超过空间限制不可用不可用0#12card12.in超过空间限制不可用不可用0#13card13.in超过空间限制不可用不可用0#14card14.in超过空间限制不可用不可用0#15card15.in超过空间限制不可用不可用0#16card16.in超过空间限制不可用不可用0#17card17.in超过空间限制不可用不可用0#18card18.in超过空间限制不可用不可用0#19card19.in超过空间限制不可用不可用0#20card20.in超过空间限制不可用不可用0返回顶部选手：ssy张鑫试题 ball&nbsp;&nbsp;未找到源程序试题 div&nbsp;&nbsp;未找到源程序试题 tree&nbsp;&nbsp;未找到源程序试题 card&nbsp;&nbsp;源程序：card.cpp测试点输入文件测试结果运行用时内存消耗得分#1card1.in超过空间限制不可用不可用0#2card2.in超过空间限制不可用不可用0#3card3.in超过空间限制不可用不可用0#4card4.in超过空间限制不可用不可用0#5card5.in超过空间限制不可用不可用0#6card6.in超过空间限制不可用不可用0#7card7.in超过空间限制不可用不可用0#8card8.in超过空间限制不可用不可用0#9card9.in超过空间限制不可用不可用0#10card10.in超过空间限制不可用不可用0#11card11.in超过空间限制不可用不可用0#12card12.in超过空间限制不可用不可用0#13card13.in超过空间限制不可用不可用0#14card14.in超过空间限制不可用不可用0#15card15.in超过空间限制不可用不可用0#16card16.in超过空间限制不可用不可用0#17card17.in超过空间限制不可用不可用0#18card18.in超过空间限制不可用不可用0#19card19.in超过空间限制不可用不可用0#20card20.in超过空间限制不可用不可用0返回顶部选手：ssy柏一航试题 ball&nbsp;&nbsp;源程序：ball.cpp测试点输入文件测试结果运行用时内存消耗得分#1ball1.in运行时错误不可用不可用0#2ball2.in答案正确0.000 s1.387 MB10#3ball3.in答案正确0.000 s1.383 MB10#4ball4.in答案正确0.000 s1.383 MB10#5ball5.in运行时错误不可用不可用0#6ball6.in运行时错误不可用不可用0#7ball7.in运行时错误不可用不可用0#8ball8.in运行时错误不可用不可用0#9ball9.in运行时错误不可用不可用0#10ball10.in运行时错误不可用不可用0试题 div&nbsp;&nbsp;源程序：div.cpp测试点输入文件测试结果运行用时内存消耗得分#1div1.in答案错误 (...)0.015 s1.402 MB0#2div2.in答案错误 (...)0.000 s1.402 MB0#3div3.in答案错误 (...)0.000 s1.398 MB0#4div4.in答案正确0.000 s1.398 MB10#5div5.in答案错误 (...)0.000 s1.398 MB0#6div6.in答案错误 (...)0.000 s1.398 MB0#7div7.in答案错误 (...)0.000 s1.395 MB0#8div8.in答案错误 (...)0.000 s1.395 MB0#9div9.in答案错误 (...)0.000 s1.398 MB0#10div10.in答案错误 (...)0.000 s1.398 MB0试题 tree&nbsp;&nbsp;源程序：tree.cpp测试点输入文件测试结果运行用时内存消耗得分#1tree1.in答案正确0.015 s3.262 MB10#2tree2.in答案正确0.015 s1.895 MB10#3tree3.in答案正确0.000 s1.906 MB10#4tree4.in答案正确0.000 s1.891 MB10#5tree5.in答案正确0.000 s1.898 MB10#6tree6.in答案正确0.031 s2.582 MB10#7tree7.in答案正确0.015 s2.582 MB10#8tree8.in答案正确0.031 s2.566 MB10#9tree9.in答案正确0.031 s2.699 MB10#10tree10.in答案正确0.031 s2.586 MB10试题 card&nbsp;&nbsp;源程序：card.cpp测试点输入文件测试结果运行用时内存消耗得分#1card1.in答案错误 (...)0.000 s1.414 MB0#2card2.in答案错误 (...)0.000 s1.414 MB0#3card3.in答案错误 (...)0.000 s1.414 MB0#4card4.in答案错误 (...)0.000 s1.418 MB0#5card5.in答案错误 (...)0.000 s1.414 MB0#6card6.in答案错误 (...)0.000 s1.414 MB0#7card7.in运行超时不可用不可用0#8card8.in运行超时不可用不可用0#9card9.in运行超时不可用不可用0#10card10.in运行超时不可用不可用0#11card11.in运行超时不可用不可用0#12card12.in运行超时不可用不可用0#13card13.in运行超时不可用不可用0#14card14.in运行超时不可用不可用0#15card15.in运行超时不可用不可用0#16card16.in运行超时不可用不可用0#17card17.in运行超时不可用不可用0#18card18.in运行超时不可用不可用0#19card19.in运行超时不可用不可用0#20card20.in运行超时不可用不可用0返回顶部选手：ssy段苏航试题 ball&nbsp;&nbsp;源程序：ball.cpp&nbsp;&nbsp;编译错误ball.cpp:10:11: error: no macro name given in #ifdef directive试题 div&nbsp;&nbsp;源程序：div.cpp&nbsp;&nbsp;编译错误div.cpp:10:11: error: no macro name given in #ifdef directive试题 tree&nbsp;&nbsp;未找到源程序试题 card&nbsp;&nbsp;源程序：card.cpp&nbsp;&nbsp;编译错误card.cpp:40:11: error: no macro name given in #ifdef directive返回顶部选手：ssy罗经纬试题 ball&nbsp;&nbsp;未找到源程序试题 div&nbsp;&nbsp;未找到源程序试题 tree&nbsp;&nbsp;未找到源程序试题 card&nbsp;&nbsp;源程序：card.cpp&nbsp;&nbsp;编译错误card.cpp: In function 'int main()':card.cpp:8:5: error: expected ';' before 'freopen'card.cpp:10:19: error: 'n' was not declared in this scopecard.cpp:10:22: error: 'm' was not declared in this scopecard.cpp:11:9: error: 'i' was not declared in this scopecard.cpp:15:9: error: 'j' was not declared in this scope返回顶部选手：std试题 ball&nbsp;&nbsp;源程序：ball.cpp测试点输入文件测试结果运行用时内存消耗得分#1ball1.in答案正确0.000 s2.246 MB10#2ball2.in答案正确0.000 s2.246 MB10#3ball3.in答案正确0.000 s2.250 MB10#4ball4.in答案正确0.000 s2.246 MB10#5ball5.in答案正确0.015 s2.246 MB10#6ball6.in答案正确0.000 s2.250 MB10#7ball7.in答案正确0.015 s2.250 MB10#8ball8.in答案正确0.015 s2.246 MB10#9ball9.in答案正确0.015 s2.246 MB10#10ball10.in答案正确0.000 s2.250 MB10试题 div&nbsp;&nbsp;源程序：div.cpp测试点输入文件测试结果运行用时内存消耗得分#1div1.in答案正确0.000 s1.379 MB10#2div2.in答案正确0.000 s1.379 MB10#3div3.in答案正确0.000 s1.375 MB10#4div4.in答案正确0.000 s1.379 MB10#5div5.in答案正确0.000 s1.379 MB10#6div6.in答案正确0.000 s1.379 MB10#7div7.in答案正确0.000 s1.375 MB10#8div8.in答案正确0.000 s1.379 MB10#9div9.in答案正确0.000 s1.375 MB10#10div10.in答案正确0.000 s1.379 MB10试题 tree&nbsp;&nbsp;源程序：tree.cpp测试点输入文件测试结果运行用时内存消耗得分#1tree1.in答案正确0.015 s2.852 MB10#2tree2.in答案正确0.000 s1.484 MB10#3tree3.in答案正确0.000 s1.496 MB10#4tree4.in答案正确0.000 s1.484 MB10#5tree5.in答案正确0.000 s1.488 MB10#6tree6.in答案正确0.000 s2.113 MB10#7tree7.in答案正确0.015 s2.105 MB10#8tree8.in答案正确0.000 s2.094 MB10#9tree9.in答案正确0.031 s2.207 MB10#10tree10.in答案正确0.000 s2.121 MB10试题 card&nbsp;&nbsp;源程序：card.cpp测试点输入文件测试结果运行用时内存消耗得分#1card1.in答案正确0.000 s1.422 MB5#2card2.in答案正确0.015 s1.426 MB5#3card3.in答案正确0.000 s1.422 MB5#4card4.in答案正确0.000 s1.422 MB5#5card5.in答案正确0.000 s1.422 MB5#6card6.in答案正确0.000 s1.422 MB5#7card7.in答案正确0.109 s4.434 MB5#8card8.in答案正确0.109 s4.430 MB5#9card9.in答案正确0.124 s4.434 MB5#10card10.in答案正确0.124 s4.434 MB5#11card11.in答案正确0.093 s4.438 MB5#12card12.in答案正确0.109 s4.438 MB5#13card13.in答案正确0.109 s4.430 MB5#14card14.in答案正确0.124 s4.434 MB5#15card15.in答案正确0.124 s4.434 MB5#16card16.in答案正确0.109 s4.434 MB5#17card17.in答案正确0.124 s4.434 MB5#18card18.in答案正确0.124 s4.430 MB5#19card19.in答案正确0.093 s4.438 MB5#20card20.in答案正确0.109 s4.438 MB5返回顶部"},{"title":"我的朋友们","date":"2076-11-29T08:54:34.955Z","updated":"2020-01-05T15:17:30.000Z","comments":true,"path":"friends/index.html","permalink":"http://yoursite.com/friends/index.html","excerpt":"","text":""},{"title":"","date":"2076-11-29T08:54:34.955Z","updated":"2020-01-05T15:17:52.000Z","comments":true,"path":"404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":""}],"posts":[{"title":"扩展中国剩余定理","slug":"扩展中国剩余定理","date":"2020-02-02T07:21:23.000Z","updated":"2020-02-03T08:18:03.000Z","comments":true,"path":"扩展中国剩余定理/","link":"","permalink":"http://yoursite.com/%E6%89%A9%E5%B1%95%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/","excerpt":"中国剩余定理是$\\text{OI}$中较为基础却常用的数论算法之一。而扩展中国剩余定理作为扩展，解决的问题较中国剩余定理广。本文将介绍扩展中国剩余定理相关内容。","text":"中国剩余定理是$\\text{OI}$中较为基础却常用的数论算法之一。而扩展中国剩余定理作为扩展，解决的问题较中国剩余定理广。本文将介绍扩展中国剩余定理相关内容。 前言中国剩余定理是$\\text{OI}$中较为基础却常用的数论算法之一。而扩展中国剩余定理作为扩展，解决的问题较中国剩余定理广。本文将介绍扩展中国剩余定理相关内容。 前置知识：扩展欧几里得（$\\text{Exgcd}$） 扩展中国剩余定理要解决的问题扩展中国剩余定理要解决的问题是求解线性模方程组。 已知如下$k$个模意义下的方程，求$x$的最小非负整数解。 $\\left{\\begin{aligned}x\\equiv\\ a_1(\\mod m_1) \\quad\\ x\\equiv\\ a_2(\\mod m_2) \\quad\\ x\\equiv\\ a_3(\\mod m_3) \\quad\\ …\\quad\\x\\equiv\\ a_k(\\mod m_k) \\quad\\end{aligned}\\right.$ 整体思路扩展中国剩余定理解决此问题的大体思路是将方程依次合并。具体来说，对任意两个方程合并，之后继续做下去，直到剩下一个方程。这样方程组就可以变成一个同余方程，可以用$\\text{Exgcd}$解出最小的非负整数$x$。而现在的关键问题就是：如何将两个同余方程合并成一个。 合并同余方程的证明过程现在只需考虑合并两个方程。假设这两个方程如下： $$\\left{\\begin{aligned}x\\equiv\\ a_1(\\mod m_1) \\quad\\ x\\equiv\\ a_2(\\mod m_2) \\quad\\end{aligned}\\right.$$ 也就是： $$\\left{\\begin{aligned}x=a_1+k_1m_1 \\ x=a_2+k_2m_2\\end{aligned}\\right.$$ 所以： $$a_1+k_1m_1=a_2+k_2m_2$$ 移项得： $$k_1m_1-k_2m_2=a_2-a_1$$ 目前方程的形式很类似$\\text{Exgcd}$可解的方程形式： $$ax+by=\\text{gcd}(x,y)$$ 而$a_2-a_1$不一定等于$\\text{gcd}(m_1,m_2)$，不能直接用$\\text{Exgcd}$求解。 但我们可以解出如下方程$k_1’,k_2’$的解： $$k_1’m_1+k_2’m_2=\\text{gcd}(m_1,m_2)$$ 注意，这里解得的$k_1’,k_2’$的解有多组。 将这个方程两边乘上$\\frac{a_2-a_1}{\\text{gcd}(m_1,m_2)}$就是我们要解的方程，所以方程的解为： $$\\left{\\begin{aligned}k_1=k_1’* \\frac{a_2-a_1}{\\text{gcd}(m_1,m_2)}\\ k_2=-k_2’* \\frac{a_2-a_1}{\\text{gcd}(m_1,m_2)}\\end{aligned}\\right.$$ 将方程的解代回到最初的方程 $$\\left{\\begin{aligned}x=a_1+k_1m_1 \\ x=a_2+k_2m_2\\end{aligned}\\right.$$ 中，可得： $$\\left{\\begin{aligned}x=a_1+k_1’* \\frac{a_2-a_1}{\\text{gcd}(m_1,m_2)}m_1 \\ x=a_2-k_2’ \\frac{a_2-a_1}{\\text{gcd}(m_1,m_2)}*m_2\\end{aligned}\\right.$$ 由于$k_1’,k_2’$有多组解，这样的$x$会有多种取值，而不同取值之间成等差，差既是$\\frac{a_2-a_1}{\\text{gcd}(m_1,m_2)}m_1 $的倍数，又是$\\frac{a_2-a_1}{\\text{gcd}(m_1,m_2)}m_2$的倍数。由此又可得出，差是$\\frac{m_1*m_2}{\\text{gcd}(m_1,m_2)}$的倍数，即$\\text{lcm}(m_1,m_2)$的倍数。 因此：$x=k_1’m_1+x_1\\text{lcm}(m_1,m_2)$ 即可将两个同余方程 $$\\left{\\begin{aligned}x\\equiv\\ a_1(\\mod m_1) \\quad\\ x\\equiv\\ a_2(\\mod m_2) \\quad\\end{aligned}\\right.$$ 合并为 $$x\\equiv k_1’*m_1+x_1(\\mod (\\text{lcm}(m_1,m_2)))$$ 结论将两个同余方程 $$\\left{\\begin{aligned}x\\equiv\\ a_1(\\mod m_1) \\quad\\ x\\equiv\\ a_2(\\mod m_2) \\quad\\end{aligned}\\right.$$ 合并为一个的步骤为： 1.求解 $$k_1’m_1+k_2’m_2=\\text{gcd}(m_1,m_2)$$ 中的$k_1’$。 2.合并后的方程为： $$x\\equiv k_1’*m_1+x_1(\\mod (\\text{lcm}(m_1,m_2)))$$","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"算法/数学","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"http://yoursite.com/tags/%E6%95%B0%E5%AD%A6/"},{"name":"中国剩余定理","slug":"中国剩余定理","permalink":"http://yoursite.com/tags/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/"}]},{"title":"hexo文章的font matter","slug":"hexo文章的font matter","date":"2020-01-09T03:59:14.200Z","updated":"2020-01-09T04:07:08.000Z","comments":true,"path":"hexo文章的font matter/","link":"","permalink":"http://yoursite.com/hexo%E6%96%87%E7%AB%A0%E7%9A%84font%20matter/","excerpt":"","text":"字段 含义 值类型 默认值 layout 布局模版 String - title 标题 String - date 创建时间 Date 文件创建时间 updated 更新日期 Date 文件修改时间 permalink 覆盖文章网址 String - music 内部音乐控件 详见【music】 - keywords 页面关键词 String - description 页面描述、摘要 String - author 作者 String config.author author_url 作者链接 String config.url avatar 作者头像 String config.avatar cover 是否显示封面 Bool true meta 文章或页面的meta信息 Bool, Array theme.meta sidebar 页面侧边栏 Bool, Array theme.sidebar body 页面主体元素 Array theme.body layout=post时特有的字段： 字段 含义 值类型 默认值 categories 分类 String, Array - tag 标签 String, Array - toc 是否生成目录 Bool true popular_posts 显示相关文章 Bool true mathjax 是否渲染公式 Bool, String false top 是否置顶 Bool false thumbnail 缩略图 String false icons 图标 Array [] 实例： 123456789101112--title: tags: - categories: - mathjax: truetop: falsethumbnail: ---本文是hexo博客文章参数的合集。&lt;!--more--&gt;","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"http://yoursite.com/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"c++STL-Map的使用","slug":"c++STL-Map的使用","date":"2019-11-23T00:41:47.000Z","updated":"2020-01-11T05:10:22.000Z","comments":true,"path":"c++STL-Map的使用/","link":"","permalink":"http://yoursite.com/c++STL-Map%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"$\\text{map,unordered_map}​$是$\\text{c++STL}​$ 中的一种数据结构，能够实现映射操作，在某些题目中可起到不可替代的作用，本文介绍它们的使用方法。","text":"$\\text{map,unordered_map}​$是$\\text{c++STL}​$ 中的一种数据结构，能够实现映射操作，在某些题目中可起到不可替代的作用，本文介绍它们的使用方法。 前言$\\text{map,unordered_map}​$是$\\text{c++STL}​$ 中的一种数据结构，能够实现映射操作，在某些题目中可起到不可替代的作用，本文介绍它们的使用方法。 Map用途Map可用于将一种类型的变量映射到另一种类型的变量。所以，它应该保护两个关键字，从一个映射到另一个。其实，数组就是一种int到其他类型的映射。例如：$\\text{int}$类型的数组a，a[x]=y也就是把$x$映射到$y​$。 有了数组，要map干什么？ 数组只是数字到其他类型的映射，但是假如我们要字符串到数字的映射怎么办？比如，将字符串abc映射到数字$5​$，对于数组，a[&quot;abc&quot;]=5显然会CE，但是有了map就不一样了。有$map​$，你甚至可以这样：a[10000000000000000000]++;。 使用方法头文件1#include&lt;map&gt; 定义1234map&lt;int,int&gt; a;map&lt;string,char&gt; a;map&lt;string,int&gt; a;... 其中尖括号内，左面是第一关键字，右面是第二关键字。 插入、修改、访问以map&lt;string,int&gt; a为例 下标访问即可a[&quot;abc&quot;]=2; 遍历方法一循环遍历，下标访问,想数组一样。 12for(int i=1;i&lt;=100;i++) cout&lt;&lt;a[i]; 如果储存值域过大，这种方式会导致TLE。 方法二利用迭代器，可以只遍历存在的映射，跳过空位。 1234for(map&lt;int,int&gt;::iterator i=a.begin();i!=a.end();i++)&#123; printf(\"%d %d\\n\",i-&gt;first,i-&gt;second);&#125; 如果不会指针或迭代器，背下来即可，无需理解。这种方式遍历的顺序是 第一关键字由小至大。 时间复杂度 内部实现是一颗平衡树，每次操作复杂度为$log$级别的。 Unordered_mapUnordered_map与Map的区别不大，这里不再重复介绍相同点。以下对其不同之处进行介绍。 遍历遍历的方式是一样的，不过值得注意的是，用迭代器遍历时，遍历的元素顺序是乱的。 时间复杂度由于内部实现是哈希表 ，插入和查询的复杂度均为$\\theta(n)$","categories":[{"name":"STL","slug":"STL","permalink":"http://yoursite.com/categories/STL/"}],"tags":[{"name":"STL","slug":"STL","permalink":"http://yoursite.com/tags/STL/"},{"name":"Map","slug":"Map","permalink":"http://yoursite.com/tags/Map/"},{"name":"Unordered_map","slug":"Unordered-map","permalink":"http://yoursite.com/tags/Unordered-map/"}]},{"title":"会考历史","slug":"会考历史","date":"2019-11-02T15:02:25.000Z","updated":"2020-02-03T08:07:49.000Z","comments":true,"path":"会考历史/","link":"","permalink":"http://yoursite.com/%E4%BC%9A%E8%80%83%E5%8E%86%E5%8F%B2/","excerpt":"本文是博主在会考前总结整理得，收集了历史必修一、二、三常考的知识点。","text":"本文是博主在会考前总结整理得，收集了历史必修一、二、三常考的知识点。 会考历史——partychicken，zf 必修一第一单元 中国古代的中央集权制度夏 禅让-&gt;世袭 商 内外服制度 占卜和祭祀 神权和王权紧密结合 周 分封制 宗法制 核心：嫡长子继承制 大宗与小宗 礼乐制：维护宗法制和分封制的工具 秦中央官制 秦：三公九卿制 隋唐：三省六部制 三省： 中书：决策 尚书：执行 门下：审议 六部：吏、户、礼、兵、刑、工 宋：二府三司制 元：中书一省制 明：废丞相，设立内阁 清：设立内阁、军机处 地方行政体制 秦：郡县制 汉初：郡国并行制 元：行省制 选官制度 西周：世卿世禄制 战国、秦、西汉初：军功爵制 汉武帝时期：察举制（推荐）、征辟制（征聘） 魏晋南北朝：九品中正制 隋唐至明清：科举制 监察制度 秦：御史大夫 汉武帝：刺史 宋朝：通判 明清：达到顶峰。监察御史，六科给事中（中央），按察使司（地方） 第二单元 古希腊和古罗马的政治制度古希腊 城邦特点：小国寡民 民主政治特点：人民主权，轮番而治 公民条件 祖籍本邦 成年男性 民主进程 1.梭伦改革——将雅典引上民主轨道 2.克利斯提尼改革——雅典民主制度确立 陶片放逐法 3.伯利克里改革——雅典民主制度黄金时期 古罗马 习惯法 成文法 古罗马第一部成文法：《十二铜表法》 罗马法发展完备：《查士丁尼民法大全》 罗马法影响： 对罗马的影响 有利于协调社会矛盾 巩固帝国统治 对世界的影响： 为近代资本主义国家立法提供规范 罗马法一些规则沿用至今 第三单元 近代西方资本主义政体的建立英国 政体：君主立宪制 行政制度：议会制 政体确立途径：光荣革命、《权利法案》 以责任内阁制为核心，国王统而不治 美国 政体：民主共和制 行政制度：总统制 国家结构：联邦制 文件：《1787年宪法》 三权分立原则： 国会：立法 参议院，众议院：行政 最高法院：司法 人民主权原则：总统、议会由民选产生 是近代世界第一部成文宪法 法国 政体：民主共和制 行政制度：议会制 文件：《法兰西第三共和国宪法》（《1875年宪法》） 行政权归内阁，总统 内阁对议会负责 德国 政体：君主立宪制 文件：《德意志帝国宪法》 浓厚的帝国主义和专制主义色彩 项目 美国 英国 德国 法国 国家元首 总统 国王 国王 总统 国家元首产生方式 民选，有任期 世袭，终身制 世袭、终身制 议会选举、有任期 国家元首有无实权 有 无 有 有 政府首脑 总统 首相 首相 总统 政府产生方式 总统任命 议会产生 皇帝任命 议会产生 政府与议会关系 总统不对国会负责 内阁、首相对议会负责 政府不对议会负责 对议会负责 国家权力中心 总统 议会 皇帝 议会 第四单元 内忧外患与中华民族的奋起中国沦为半殖民地半封建化社会的过程 时间 战争 条约 事迹 内容 影响 1840-1842 鸦片战争 《南京条约》 为开放五口通商：广州、福州、厦门、宁波、上海（广夏福宁上） 主权和领土完整被破坏，中国开始沦为半殖民地半封建化社会 1856-1860 第二次鸦片战争 《天津条约》 《北京条约》 开始认识到学习西方的重要性，中国半殖民地半封建化程度加深 1894-1895 甲午中日战争 《马关条约》 丁汝昌、邓世昌、刘永福 割让台湾，开放重庆、日本在华设厂 中国半殖民地半封建化程度大大加深 1900-1901 八国联军侵华 《辛丑条约》 允许外国驻兵保护 中国彻底沦为半殖民地半封建社会 太平天国运动 1851：洪秀全金田起义 1853：定都南京，改名天京，《天朝田亩制度》 1856：天京事变，严重内讧 1859：洪仁玕《资政新篇》 （第一部有资本主义性质的施政方案） 1864：天京陷落 辛亥革命 1905：同盟会成立，孙中山 “驱除鞑虏，恢复中华民族主义，创立民国民权主义，平均地权民生主义“ 1911：武昌首义 1912《中华民国临时约法》 第一部具有资产阶级共和国宪法性质的国家临时大法 五四运动 口号：“废除二十一条”、“外争国权，内惩国贼”等 中国无产阶级力量登上历史舞台 中国拒绝在《凡尔赛和约》上签字 第五单元 马克思主义的产生，发展和中国新民主主义革命马克思主义的诞生（1848） 《共产党宣言》发表 巴黎公社 第一个工人政权 标志着社会主义由理论变为实践 俄国十月革命 1917：二月革命，资产阶级建立起临时政府 1917：列宁《四月提纲》，要实现社会主义革命 1917.7：七月流血事件（武力镇压革命力量） 1917.11：推翻临时政府 第一个社会主义国家 政体：苏维埃社会主义共和政体 措施： 《和平法令》宣布退出帝国主义战争 《土地法令》把土地分给劳动者使用 十月革命意义 第一次获得胜利的社会主义革命 社会主义由理论变为现实 使俄国摆脱封建残余束缚和剥削阶级通知 中国新民主主义革命 1921 中共一大 确立党的名称 党的奋斗目标：推翻资产阶级，建立无产阶级专政，废除私有制 1922 中共二大 更改目标：反对帝国主义、封建主义、军阀，建立民主共和国 1923 中共三大 寻求合作 1924.1 国民党一大 国共第一次合作形成。 1925-1927 国民革命 1927-1937 国共十年对峙 1927：八七会议，土地革命：废除封建剥削 1927：秋收起义，创建井冈山革命根据地，以农村包围城市，最后夺取全国政权 1931-1945 抗日战争 1931：九一八事变 1937：卢沟桥事变 百团大战：1940年，彭德怀 太平洋战争:1941年，敌后战场成为主要战场 胜利意义 国际意义 中国抗战是世界反法西斯战争的重要组成部分 时间最长，抗击日本兵力最多 国内意义 第一次取得反对帝国主义侵略的完全胜利 为民主革命胜利奠定基础 1946-1949 解放战争 1948-1949 三大战役：辽沈、淮海、平津 1949：渡江战役 红军长征 时间：1934-1936 1935.1 遵义会议 确立毛泽东领导地位 扭转长期被动挨打局面 1935 《八一宣言》 建立抗日民族统一战线的主张 1936.10 在甘肃会宁会师 西安事变：1936年 重庆谈判：1945年，国共双方达成《双十协定》 第六单元 中国社会主义的政治建设与祖国统一新中国的政治建设 开国大典 第一次政治协商会议：1949.9 时间：1949.10.1 1954年宪法 中国第一部社会主义类型宪法 人民代表大会制度 确立标志：1954年宪法 曲折 1957右派斗争扩大，建设停顿 文革期间，名存实亡 多党合作和政治协商制度 指导思想：长期共存，互相监督 合作形式：政治协商 1982年提出：长期共存，互相监督，肝胆相照，荣辱与共 民族区域自治制度 社会主义政治建设的曲折发展 文化大革命 时间：1966-1976 第十一届三中全会 转折：胡耀邦主持，平反冤假错案 颁布1982年宪法，法律体系较完备 依法治国 十五大确立为改革重点 1999写入宪法，标志中国进入建设法治化社会新时期 祖国统一的历史潮流 一国两制 提出：邓小平，针对台湾问题 香港：1997.7.1回归 澳门：1999.12.20回归 台湾问题 1979：《告台湾同胞书》和平统一 1992：九二共识，海峡两岸均坚持一个中国原则 1995：江泽民，八项主张 2005：《反分裂国家法》促进祖国和平统一 第七单元 复杂多样的当代世界两极格局 政治上，1947杜鲁门主义 标志着冷战开始 对抗：共产党和工人党情报局反击 经济上，1947马歇尔计划 对杜鲁门主义的大规模应用 对抗：经济互助委员会反击 军事上，1949《北大西洋公约》，北约 对抗：《华沙条约》，华约，标志着两极格局形成 热战 朝鲜战争（1950-1953）：中美关系破裂 越南战争（1961-1973）：苏联军事实力大体赶上美国 世界政治格局多极化趋势 欧共体 1951：欧洲煤钢共同体 1958：欧洲经济共同体、欧洲原子能共同体 1967：合并成欧洲共同体 日本：成为资本主义世界第二经济大国 不结盟运动 1961：第一次不结盟国家和政府首脑会议，标志不结盟运动诞生 不结盟运动标志着第三世界国家以独立的力量登上了国际政治舞台 新中国外交 外交政策： 建国初期 方针：独立自主的和平外交方针 “一边倒”，“另起炉灶”，“打扫干净屋子再请客” 改革开放以来 原则：平等互利，形式多样，讲求实效，共同发展 1950：中苏签订《中苏友好同盟互助条约》 1953：和平共处五项原则 周恩来接见印度代表团时提出 标志中国外交政策的成熟，成为解决国与国问题的准则 1954：参加日内瓦会议 1955：参加亚非会议，并提出“求同存异” 1971：第26届联大，中国在联合国的一切合法权利得到恢复 1972：尼克松访华，《中美上海公报》 1972：《中日联合声明》，中日关系正常化 1978：《中美建交联合公报》 1979：中美正式建交 2001：上海合作组织，促进地区和平与稳定 必修二","categories":[{"name":"文化课","slug":"文化课","permalink":"http://yoursite.com/categories/%E6%96%87%E5%8C%96%E8%AF%BE/"}],"tags":[{"name":"文化课","slug":"文化课","permalink":"http://yoursite.com/tags/%E6%96%87%E5%8C%96%E8%AF%BE/"},{"name":"历史","slug":"历史","permalink":"http://yoursite.com/tags/%E5%8E%86%E5%8F%B2/"}]},{"title":"最小费用最大流","slug":"最小费用最大流","date":"2019-07-06T05:42:00.000Z","updated":"2020-02-03T08:08:53.000Z","comments":true,"path":"最小费用最大流/","link":"","permalink":"http://yoursite.com/%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81/","excerpt":"网络流是OI中比较常出现的算法，而最小费用最大流是其最常用的算法之一，阅读本文前，请确保掌握了网络最大流的Dinic的求法，详见网络最大流","text":"网络流是OI中比较常出现的算法，而最小费用最大流是其最常用的算法之一，阅读本文前，请确保掌握了网络最大流的Dinic的求法，详见网络最大流 前言本文发表于： 个人博客：链接 洛谷博客：链接 网络流是OI中比较常出现的算法，而最小费用最大流是其最常用的算法之一，阅读本文前，请确保掌握了网络最大流的Dinic的求法，详见网络最大流 最小费用最大流算法简介最小费用最大流（以下简称费用流），是在网络最大流的基础上，给每个边增加了另一个值——费用，代表每流过一个单位的流量，就会耗费这些费用。而费用流算法，就是在求最大流的同时，找出所花费用最小的方案，并求出这个最小费用。 实现方法首先，对于同一个图，它的最大流是一个固定的值，但是有很多方案，而求费用最小的走法，便可以利用最短路算法，以费用为最短路的边权。 思考一下，Dinic中的反边思想实际上是让程序可以沿着反边跑回去，达到反悔目的。所以费用流中，反边的费用需要设置成正边的相反数，保证在返回时费用也会还回来。 由于反边有负边权，所以要用已死的SPFA 把$Dinic$中的$Bfs$改为$SPFA$即可,每次找残量图中$S-T$的最短路径（费用作为边权），并按照$Dinic$的方式增广这条路径。 $Dinic$增广时需要把残量图中流量更改，所以要用能记录路径的$SPFA$ 建图12345678910int head[N],to[N],next[N],f[N],c[N];//f是容量，c是费用int cnt=1;void Add(int x,int y,int z,int cost)&#123; to[++cnt]=y; f[cnt]=z; c[cnt]=cost; next[cnt]=head[x]; head[x]=cnt;&#125; SPFA1234567891011121314151617181920212223242526272829303132333435363738int dis[N];/*spfa的距离数组*/int flow[N];/*源点到此处流量*/int vis[N];int pre[N];//每个点的前驱 int last[N];bool Spfa() &#123; memset(dis,0x7f,sizeof(dis)); memset(flow,0x7f,sizeof(flow)); memset(vis,0,sizeof(vis)); queue&lt;int&gt; q; q.push(S); vis[S]=1,dis[S]=0; pre[T]=-1; while(!q.empty()) &#123; int u=q.front(); q.pop(); vis[u]=0; for(int i=head[u];i;i=next[i]) &#123; int v=to[i]; if(f[i]&gt;0 &amp;&amp; dis[v]&gt;dis[u]+c[i])//有残量，能松弛 &#123; dis[v]=dis[u]+c[i];//更新距离 pre[v]=u;//SPFA记录前驱 last[v]=i;//记录边的编号，便于增广时更改边权 flow[v]=min(flow[u],f[i]); if(!vis[v]) &#123; vis[v]=1; q.push(v); &#125; &#125; &#125; &#125; return ~pre[T];&#125; 主函数 12345678910111213141516int Flow,Cost;void Mcmf()&#123; while(Spfa()) &#123; int u=T; Flow+=flow[T]; Cost+=flow[T]*dis[T]; while(u!=S)//遍历这次的增广路（最短路） &#123; f[last[u]]-=flow[T];//更新边权 f[last[u]^1]+=flow[T]; u=pre[u]; &#125; &#125;&#125; 总结这种费用流算法实际上就是在增广时优先考虑费用（用最短路$\\text{SPFA}$实现），保证费用最小（反正由于反边的存在，$\\text{Dinic}$怎么流到最后都能流出最大流 ）。 完整代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#define next adjagagusing namespace std; const int N=1000010;int head[N],to[N],next[N],f[N],c[N];int cnt=1;int n,m,S,T;void Add(int x,int y,int z,int cost)&#123; to[++cnt]=y; f[cnt]=z; c[cnt]=cost; next[cnt]=head[x]; head[x]=cnt;&#125;int dis[N];int flow[N];int vis[N];int pre[N];int last[N];bool Spfa() &#123; memset(dis,0x7f,sizeof(dis)); memset(flow,0x7f,sizeof(flow)); memset(vis,0,sizeof(vis)); queue&lt;int&gt; q; q.push(S); vis[S]=1,dis[S]=0; pre[T]=-1; while(!q.empty()) &#123; int u=q.front(); q.pop(); vis[u]=0; for(int i=head[u];i;i=next[i]) &#123; int v=to[i]; if(f[i]&gt;0 &amp;&amp; dis[v]&gt;dis[u]+c[i]) &#123; dis[v]=dis[u]+c[i]; pre[v]=u; last[v]=i; flow[v]=min(flow[u],f[i]); if(!vis[v]) &#123; vis[v]=1; q.push(v); &#125; &#125; &#125; &#125; return ~pre[T];&#125;int Flow,Cost;void Mcmf()&#123; while(Spfa()) &#123; int u=T; Flow+=flow[T]; Cost+=flow[T]*dis[T]; while(u!=S) &#123; f[last[u]]-=flow[T]; f[last[u]^1]+=flow[T]; u=pre[u]; &#125; &#125;&#125;int main()&#123; scanf(\"%d %d %d %d\",&amp;n,&amp;m,&amp;S,&amp;T); for(int i=1;i&lt;=m;i++) &#123; int x,y,z,c; scanf(\"%d %d %d %d\",&amp;x,&amp;y,&amp;z,&amp;c); Add(x,y,z,c); Add(y,x,0,-c); &#125; Mcmf(); printf(\"%d %d\\n\",Flow,Cost); return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"网络流","slug":"算法/网络流","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E7%BD%91%E7%BB%9C%E6%B5%81/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"费用流","slug":"费用流","permalink":"http://yoursite.com/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"}]},{"title":"网络最大流","slug":"网络最大流","date":"2019-06-27T05:23:00.000Z","updated":"2020-02-03T08:08:42.000Z","comments":true,"path":"网络最大流/","link":"","permalink":"http://yoursite.com/%E7%BD%91%E7%BB%9C%E6%9C%80%E5%A4%A7%E6%B5%81/","excerpt":"网络最大流算法能在信息学竞赛中处理很多问题，而且往往是不可被其它算法替代的。而最大流算法则是处理问题的方法之一。本文将介绍网络最大流的算法及其优化。","text":"网络最大流算法能在信息学竞赛中处理很多问题，而且往往是不可被其它算法替代的。而最大流算法则是处理问题的方法之一。本文将介绍网络最大流的算法及其优化。 前言本文发表于： 个人博客：传送门 洛谷博客：传送门 网络最大流算法能在信息学竞赛中处理很多问题，而且往往是不可被其它算法替代的。而最大流算法则是处理问题的方法之一。本文将介绍网络最大流的算法及其优化。 关于本文代码 存图方式：数组链式前项星。 网络最大流算法-Dinic前置知识几个概念 源点（$S$)：网络流流出的点 汇点（$T$)：网络流流入的点 流量：一条边上流过流的多少 容量：一条边最大流量 残量：一条边上剩余流量，即容量$-$流量 朴素的算法由于网络流算法都是基于增广这一思路的，接下来对增广进行介绍。 要想求出网络最大流，思路大体上就是不停地寻找增广路，直到没有增广路，即可保证求到了最大流。 增广：1.找到一条从源点通向到汇点的路径，并且这条路径上，每条边都有残量（这代表这条路并没有流满，完全可以增加一些流量），这条路叫做增广路。 2.取这条增广路上残量最小值，代表这条增广路上可以增加这么多流量（取最小值的原因显然）。 3.将增广路上每条边残量减去增加的流量，加入答案； 4.直到找不到增广路。 HACK如果仔细思考，以上算法仍然存在缺陷： 如下图： 此时找到的最大流是$10$，而实际上是$15$，因此，我们要进行改进。 改进这里是解决网络流问题的关键步骤： 引入反向边 即每次在找到增广路，更新残量时，同时将其反向边的残量相应增加： 具体过程如下图： 这样求出的最大流是15，正确。 实际上，引入了反向边，让程序可以进行一次$S-3-4-1-2-T$这样的增广。 第一次增广不一定能寻得恰当的路线，而反向边可以让程序有反悔的机会，便是对的。 效率这样多次进行增广，会导致程序效率便得非常低。例如下图： 会增广很多次。于是我们引入Dinic算法。 Dinic$\\text{Dinic}$在原有算法基础上，增加了分层图，即根据距离源点的距离，将每个点进行深度标号，每次找增广路时都保证深度递增地寻找。 分层（BFS）以下是分层部分的代码： 12345678910111213141516171819202122bool Bfs()//返回是否分层成功，即是否有最短路&#123; queue&lt;int&gt; q; memset(dep,0,sizeof(dep));//一定不要忘了清空 dep[S]=1; q.push(S); while(!q.empty()) &#123; int u=q.front(); q.pop(); for(int i=head[u];i;i=next[i]) &#123; int v=to[i]; if(w[i] &amp;&amp; !dep[v])//有残量，而且通往的点还没有访问过（标记过深度） &#123; dep[v]=dep[u]+1; q.push(v); &#125; &#125; &#125; return dep[T];&#125; 增广（DFS）以下是找增广路部分的代码： 12345678910111213141516171819int Dfs(int u,int dis)//当前节点，到目前为止可增加流量，返回可增加流量&#123; if(u==T || (!dis)) return dis;//到达汇点||已无残量 int sum=0; for(int i=head[u];i;i=next[i]) &#123; int v=to[i]; if(dep[v]==dep[u]+1 &amp;&amp; w[i])//通向的边在下一层且有残量 &#123; int di=Dfs(v,min(dis,w[i])); if(di&gt;0) &#123; w[i]-=di,w[i^1]+=di; return di;//传递; &#125; &#125; &#125; return 0;//无增广路&#125; 调用部分123456789int Dinic()&#123; int ans=0; while(Bfs())//能分层 &#123; ans+=Dfs(S,10000000); &#125; return ans;&#125; 主函数需要注意的是，为了实现增加反边，在建图时就需要提前建好容量为$0$的反边。 补充 在链式前向星建图中，$cnt$初始值设成$1$,这样对于编号为$i$的边，它的反边编号就是$i$^$1$ 1234567891011121314int main()&#123; cnt=1; scanf(\"%d %d %d %d\",&amp;n,&amp;m,&amp;S,&amp;T); for(int i=1;i&lt;=m;i++) &#123; int x,y,z; scanf(\"%d %d %d\",&amp;x,&amp;y,&amp;z); Add(x,y,z); Add(y,x,0); &#125; printf(\"%d\\n\",Dinic()); return 0;&#125; Dinic的优化以上的$\\text{Dinic}$算法是优化前的，一下对它的$3$种优化进行一一介绍： 当前弧优化在每次增广后，某个节点引出的几条边的残量会被更新成$0$，在原有算法中，残量为$0$的边仍会被扫一遍，而当前弧优化即是对上次停下的位置进行记录，下次直接从上次结束的位置开始。 实现方法就是用一个数组记录每个点处理到了第几条边，在代码中只需要加入几行即可，如下： 增广（DFS）12345678910111213141516171819int cur[N];int Dfs(int u,int dis)&#123; if(u==T || (!dis)) return dis; for(int &amp;i=cur[u];i;i=next[i])//注意这里的&amp; 和cur，在i增加的同时，cur[i]的值也会相应增加，达到了记录的目的 &#123; int v=to[i]; if(dep[v]==dep[u]+1 &amp;&amp; w[i]) &#123; int di=Dfs(v,min(dis,w[i])); if(di&gt;0) &#123; w[i]-=di,w[i^1]+=di; return di;//传递; &#125; &#125; &#125; return 0;//无增广路&#125; 调用部分12345678910int Dinic()&#123; int ans=0; while(Bfs())//能分层 &#123; memcpy(cur,head,sizeof(head));//重新更改回第一条边 ans+=Dfs(S,10000000); &#125; return ans;&#125; 多路增广每次不只是找一条增广路，而是只要可以就都递归下去，这样增广出来的不只是一条链，而是一个网，可以加快运行速度（降低常数） 增广部分12345678910111213141516171819int Dfs(int u,int dis)&#123; if(u==T || (!dis)) return dis; int flow=0; for(int i=cur[u];i;i=next[i]) &#123; cur[u]=i; int v=to[i]; if(dep[v]==dep[u]+1) &#123; int di=Dfs(v,min(dis,w[i]));//注意这个一定要放到if里面，否则会导致图不分层，导致TLE/MLE flow+=di;//这里不急着return，而是记录一下这条链上能增广的流量，再接着找下一条链 dis-=di;//把从u开始能增广的容量相应减去 w[i]-=di,w[i^1]+=di;//更新边权 if(!dis) break;//没容量了 &#125; &#125; return flow;&#125; 炸点当一个点连的边的残量都为$0$时，这个点已经没有用了，之后就不要再进入这个点了，这就是“炸点”。 具体实现可以把这个点的深度设置成$-1$，保证不会再次访问这个点。 123456789101112131415161718192021int Dfs(int u,int dis)&#123; if(u==T || (!dis)) return dis; int flow=0; for(int i=cur[u];i;i=next[i]) &#123; cur[u]=i; int v=to[i]; if(dep[v]==dep[u]+1) &#123; int di=Dfs(v,min(dis,w[i])); flow+=di; dis-=di; w[i]-=di,w[i^1]+=di; if(!dis) break; &#125; &#125; if(!flow)//这个点甚至没有增广出一点流量 dep[u]=-1;//炸掉它 return flow;&#125; 总结Dinic算法是较为高效的网络流算法，建议使用时加入以上$3$条优化。 下面给出完整代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#define next adjagagusing namespace std; const int N=1000010;int head[N],to[N],next[N],w[N];int cnt=1;int n,m,S,T;void Add(int x,int y,int z)&#123; to[++cnt]=y; w[cnt]=z; next[cnt]=head[x]; head[x]=cnt;&#125;int dep[N];bool Bfs()&#123; queue&lt;int&gt; q; memset(dep,0,sizeof(dep)); dep[S]=1; q.push(S); while(!q.empty()) &#123; int u=q.front(); q.pop(); for(int i=head[u];i;i=next[i]) &#123; int v=to[i]; if(w[i] &amp;&amp; !dep[v]) &#123; dep[v]=dep[u]+1; q.push(v); &#125; &#125; &#125; return dep[T];&#125;int cur[N];int Dfs(int u,int dis)&#123; if(u==T || (!dis)) return dis; int flow=0; for(int i=cur[u];i;i=next[i]) &#123; cur[u]=i; int v=to[i]; if(dep[v]==dep[u]+1) &#123; int di=Dfs(v,min(dis,w[i])); flow+=di; dis-=di; w[i]-=di,w[i^1]+=di; if(!dis) break; &#125; &#125; if(!flow) dep[u]=-1; return flow;&#125;int Dinic()&#123; int ans=0; while(Bfs()) &#123; memcpy(cur,head,sizeof(head)); ans+=Dfs(S,10000000); &#125; return ans;&#125;int main()&#123; cnt=1; scanf(\"%d %d %d %d\",&amp;n,&amp;m,&amp;S,&amp;T); for(int i=1;i&lt;=m;i++) &#123; int x,y,z; scanf(\"%d %d %d\",&amp;x,&amp;y,&amp;z); Add(x,y,z); Add(y,x,0); &#125; printf(\"%d\\n\",Dinic()); return 0;&#125; 参考资料https://www.cnblogs.com/SYCstudio/p/7260613.html","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"网络流","slug":"算法/网络流","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E7%BD%91%E7%BB%9C%E6%B5%81/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"最大流","slug":"最大流","permalink":"http://yoursite.com/tags/%E6%9C%80%E5%A4%A7%E6%B5%81/"}]},{"title":"链式前向星","slug":"链式前向星","date":"2019-04-11T07:08:00.000Z","updated":"2020-02-03T08:08:18.000Z","comments":true,"path":"链式前向星/","link":"","permalink":"http://yoursite.com/%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F/","excerpt":"链式前向星是类似于邻接表的存图方式，具有空间复杂度小，便于遍历等优点，不过无法快速判断两点间是否有边","text":"链式前向星是类似于邻接表的存图方式，具有空间复杂度小，便于遍历等优点，不过无法快速判断两点间是否有边 前言链式前向星是类似于邻接表的存图方式，具有空间复杂度小，便于遍历等优点，不过无法快速判断两点间是否有边 储存实现原理这种存图方式只需要开一个数组存储每个点引出的第一条边，然后存储每个点作为起点的每条边，这样就可以做到不重不漏。 在链式前向星存图中，我们需要定义一个结构体： 12345struct EDGE &#123; int next; int to;&#125;edge[1000000]; 和一个数组： 1int head[1000000]; 和一个变量： 1int cnt&#x3D;0;&#x2F;&#x2F;指针 你会发现竟然没存起点！！其实起点是用$head$存的 实例： 如图：这样的一个有向图，输入是： 12341 21 31 42 3 逐步分析：1.输入1 2，代表1连向2。123cnt++;&#x2F;&#x2F;作为结构体下标，没有意义head[1]&#x3D;cnt;&#x2F;&#x2F;结点1的第一个儿子存在了edge[cnt]里面edge[cnt].to&#x3D;2;结点1的儿子是2 此时：$cnt=1$ $edge$ $cnt=1$ $cnt=2$ $ cnt=3$ $cnt=4$ $to $ $2$ $0$ $ 0$ $0$ $next$ $ 0 $ $0 $ $0$ $0$ $head $ 下标$=1 $ 下标$=2$ 下标$=3 $ 下标$=4 $ 值 $1 $ $ 0 $ $ 0 $ $ 0 $ 2.输入1 3，代表1连向3。12345678910cnt++;head[1]=cnt;edge[cnt].to=3;结点1的儿子是3//这时,3成为了结点1的儿子，不过2被挤了下去...//所以要引入结构体中next元素，记录：3还有个兄弟（next）是2//所以代码要换成：cnt++;edge[cnt].to=3;//结点1连向3edge[cnt].next=head[1];//3的兄弟是2head[1]=cnt;//更新head 此时：$cnt=2$ $edge$ $cnt=1$ $cnt=2$ $ cnt=3$ $cnt=4$ $to $ $2$ $3$ $ 0$ $0$ $next$ $ 0 $ $1 $ $0$ $0$ $head $ 下标$=1 $ 下标$=2$ 下标$=3 $ 下标$=4 $ 值 $2 $ $ 0 $ $ 0 $ $ 0 $ 3.输入1 4，代表1连向4。此时：$cnt=3$ $edge$ $cnt=1$ $cnt=2$ $ cnt=3$ $cnt=4$ $to $ $2$ $3$ $ 4$ $0$ $next$ $ 0 $ $1 $ $2$ $0$ $head $ 下标$=1 $ 下标$=2$ 下标$=3 $ 下标$=4 $ 值 $3 $ $ 0 $ $ 0 $ $ 0 $ 4.输入2 3，代表2连向3。此时：$cnt=4$ $edge$ $cnt=1$ $cnt=2$ $ cnt=3$ $cnt=4$ $to $ $2$ $3$ $ 4$ $3$ $next$ $ 0 $ $1 $ $2$ $0$ $head $ 下标$=1 $ 下标$=2$ 下标$=3 $ 下标$=4 $ 值 $3 $ $ 4 $ $ 0 $ $ 0 $ 注意：$edge[cnt].next$ 和$head[1]$存贮的都是结构体下标（即$cnt$的值）若要访问指向的边的编号，分别用$edge[edge[cnt].next].to$，$edge[head[1]].to$ 若需要记录权值，在结构体中加入一个元素即可 代码：带权值： 123456789101112131415161718192021222324252627#include&lt;iostream&gt;using namespace std;struct edge &#123; int next; int to; int wei;&#125;edge[MAXM];int head[MAXN];//head[i]为i点的第一条边int cnt=0;void addedge(int u,int v,int w) //起点，终点，权值 &#123; edge[++cnt].next=head[u];//更新cnt edge[cnt].to=v; edge[cnt].w=w; head[u]=cnt;&#125;int main()&#123; int n; for(int i=1;i&lt;=n;i++) &#123; int a,b,wei; addedge(a,b,wei); //如果是无向图，还要addedge(b,a,wei); &#125;&#125; 注意： 这里的$next$指的是遍历时的下一条边，$head$指的是遍历时的第一条边，而存边时相当于反过来操作，所以$next$记录上一条边，而$head$记录最后一条边。 边的遍历在遍历以x为起点的所有边时，只需要这样就行 1for(int i=head[x];i;i=edge[i].next) 这个循环的结束条件是$i$等于$0$，因为最后一条边，也就是存边时第一条边，在把$head$值存进$next$时，$head$还没有更新过，也就是$0$。所以当$next$返回$0$时，就说明这些边遍历完毕了。 优势与特点既可以存图，也可以存树，比起邻接矩阵，链式前向星的空间复杂度是$O(n)$,大大节省了存储空间，因为按边存储省掉了很多两点无边的空间。并且在遍历的时候，那些与起点无边相连的点也不需要进行处理，可以说时间和空间都占优势，这就是被OIer们广泛使用的原因。 补充+技巧 （$2019/1/15 update$） 1234567void addedge(int u,int v,int w) //起点，终点，权值 &#123; edge[++cnt].next=head[u];//更新cnt edge[cnt].to=v; edge[cnt].w=w; head[u]=cnt;&#125;这个代码中，$cnt$代表边的编号。 如果$cnt$初始值赋为$1$,存的是无向图，那么： 边$cnt$的反向边是$cnt$^$1$","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"算法/图论","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"存图","slug":"存图","permalink":"http://yoursite.com/tags/%E5%AD%98%E5%9B%BE/"}]},{"title":"后缀数组","slug":"后缀数组","date":"2019-04-10T13:01:00.000Z","updated":"2020-02-03T08:07:39.000Z","comments":true,"path":"后缀数组/","link":"","permalink":"http://yoursite.com/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/","excerpt":"","text":"什么是后缀数组：看几条定义(应该没啥用)： 子串 在字符串$s$中，取任意$i&lt;=j$，那么在$s$中截取从$i$到$j$的这一段就叫做$s$的一个子串后缀 后缀 就是从字符串的某个位置i到字符串末尾的子串，我们定义以$s$的第$i$个字符为第一个元素的后缀为$suff(i)$ 后缀数组 把$s$的每个后缀按照字典序排序， 后缀数组$sa[i]$就表示排名为i的后缀的起始位置的下标 而它的映射数组$rk[i]$就表示起始位置的下标为i的后缀的排名 即：$sa$表示排名为$i$的是啥，$rk$表示第$i$个的排名是啥 后缀数组的思想先说最暴力的情况，对每个后缀排序$(nlogn)%，但是这是一个字符串，所以比较任意两个后缀的复杂度其实是%O(n)%，复杂度$O(n^2logn)$的，肯定会$T$,接下来需要把优化。 优化优化1：倍增——对排序的优化我们不是把每一个后缀字符串列举出来，当做没有联系的字符串进行排序，而是把每一个后缀都放在原串中考虑。 1.先根据单个字符排序，(即先按照每个后缀的第一个字符排序）。对于每个字符，我们按照字典序给一个排名(当然可以并列)，这里称作关键字。 2.接下来我们再把相邻的两个关键字合并到一起(即先按照每个后缀的前两个字符排序）。这样就是以第一个字符(也就是自己本身)的排名为第一关键字，以第二个字符的排名为第二关键字，把组成的新数排完序之后再次标号。(没有第二关键字的补零) 3.接下来就要倍增了：我们对于一个在第$i$位上的关键字，它的第二关键字就是第$i+2$位置上的，联想一下，因为现在第i位上的关键字是$suff(i)$的前两个字符的排名，第$i+2$位置上的关键字是$suff(i+2)$的前两个字符的排名，这两个一合并，不就是$suff(i)$的前四个字符的排名吗？方法同上，排序之后重新标号，没有第二关键字的补零。同理我们可以证明，下一次我们要合并的是第$i$位和第$i+4$位，以此类推即可 ··· 当所有的排名都不同的时候我们直接退出就可以了，因为已经排好了。 这样排序的速度稳定在$(logn)$ 优化2——基数排序如果我们用快排的话，复杂度就是$(nlog^2n)$ 还是太大。 这里我们用一波基数排序优化一下。在这里我们可以注意到，每一次排序都是排两位数，所以基数排序可以将它优化到$O(n)$级别，总复杂度就是$(nlogn)$。 介绍一下什么是基数排序，这里就拿两位数举例 我们要建两个桶，一个装个位，一个装十位，我们先把数加到个位桶里面，再加到十位桶里面，这样就能保证对于每个十位桶，桶内的顺序肯定是按个位升序的。 最长公共前缀——后缀数组的辅助工具什么是LCP？我们定义$LCP(i,j)$为$suff(sa[i])$与$suff(sa[j])$的最长公共前缀 为什么要求LCP？后缀数组这个东西，不可能只让你排个序就完事了……大多数情况下我们都需要用到这个辅助工具LCP来做题的关于LCP的几条性质显而易见的 LCP(i,j)=LCP(j,i); LCP(i,i)=len(sa[i])=n-sa[i]+1;对于$i&gt;j$的情况，我们可以把它转化成$i&lt;j$，对于$i==j$的情况，我们可以直接算长度，所以我们直接讨论$i&lt;j$的情况就可以了。 我们每次依次比较字符肯定是不行的，单次复杂度为$O(n)$，太高了，所以我们要做一定的预处理才行。 几个性质LCP(i,k)=min(LCP(i,j),LCP(j,k)) LCP(i,k)=min(LCP(j,j-1)) 对于任意1&lt;i&lt;=j&lt;=k&lt;=n 怎么求LCP？我们设$height[i]$为$LCP(i,i-1)$，$1&lt;i&lt;=n$，显然$height[1]=0;$ 由上面的几个性质可得，$LCP(i,k)=min(height[j]) i+1&lt;=j&lt;=k$ 那么$height$怎么求，我们要利用这些后缀之间的联系 设$h[i]=height[rk[i]]$，同样的，$height[i]=h[sa[i]]$; 那么现在来证明最关键的一条定理： $h[i]&gt;=h[i-1]-1;$ 首先我们设第$i-1$个字符串按排名来的前面的那个字符串是第k个字符串，注意$k$不一定是$i-2$，因为第$k$个字符串是按字典序排名来的$i-1$前面那个，并不是指在原字符串中位置在$i-1$前面的那个第$i-2$个字符串。 这时，依据$height[]$的定义，第k个字符串和第i-1个字符串的公共前缀自然是$height[rk[i-1]]$，现在先讨论一下第$k+1$个字符串和第$i$个字符串的关系。 第一种情况，第$k$个字符串和第$i-1$个字符串的首字符不同，那么第k+1个字符串的排名既可能在$i$的前面，也可能在i的后面，但没有关系，因为$height[rk[i-1]]$就是$0$了呀，那么无论$height[rk[i]]$是多少都会有$height[rk[i]]&gt;=height[rk[i-1]]-1$，也就是$h[i]&gt;=h[i-1]-1$。 第二种情况，第$k$个字符串和第$i-1$个字符串的首字符相同，那么由于第$k+1$个字符串就是第k个字符串去掉首字符得到的，第$i$个字符串也是第$i-1$个字符串去掉首字符得到的，那么显然第$k+1$个字符串要排在第$i$个字符串前面。同时，第$k$个字符串和第$i-1$个字符串的最长公共前缀是$height[rk[i-1]]$， 那么自然第k+1个字符串和第i个字符串的最长公共前缀就是$height[rk[i-1]]-1$。 到此为止，第二种情况的证明还没有完，我们可以试想一下，对于比第$i$个字符串的排名更靠前的那些字符串，谁和第i个字符串的相似度最高（这里说的相似度是指最长公共前缀的长度）？显然是排名紧邻第$i$个字符串的那个字符串了呀，即4sa[rank[i]-1]4。但是我们前面求得，有一个排在i前面的字符串$k+1$，$LCP(rk[i],rk[k+1])=height[rk[i-1]]-1;$ 又因为$height[rk[i]]=LCP(i,i-1)&gt;=LCP(i,k+1)$ 所以$height[rk[i]]&gt;=height[rk[i-1]]-1$，也即$h[i]&gt;=h[i-1]-1$. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;cstdio&gt;#include&lt;cstring&gt;#define rint register int#define inv inline void#define ini inline int#define maxn 1000050using namespace std;char s[maxn];int y[maxn],x[maxn],c[maxn],sa[maxn],rk[maxn],height[maxn],wt[30];int n,m;inv putout(int x)&#123; if(!x) &#123;putchar(48);return;&#125; rint l&#x3D;0; while(x) wt[++l]&#x3D;x%10,x&#x2F;&#x3D;10; while(l) putchar(wt[l--]+48);&#125;inv get_SA()&#123; for (rint i&#x3D;1;i&lt;&#x3D;n;++i) ++c[x[i]&#x3D;s[i]]; &#x2F;&#x2F;c数组是桶 &#x2F;&#x2F;x[i]是第i个元素的第一关键字 for (rint i&#x3D;2;i&lt;&#x3D;m;++i) c[i]+&#x3D;c[i-1]; &#x2F;&#x2F;做c的前缀和，我们就可以得出每个关键字最多是在第几名 for (rint i&#x3D;n;i&gt;&#x3D;1;--i) sa[c[x[i]]--]&#x3D;i; for (rint k&#x3D;1;k&lt;&#x3D;n;k&lt;&lt;&#x3D;1) &#123; rint num&#x3D;0; for (rint i&#x3D;n-k+1;i&lt;&#x3D;n;++i) y[++num]&#x3D;i; &#x2F;&#x2F;y[i]表示第二关键字排名为i的数，第一关键字的位置 &#x2F;&#x2F;第n-k+1到第n位是没有第二关键字的 所以排名在最前面 for (rint i&#x3D;1;i&lt;&#x3D;n;++i) if (sa[i]&gt;k) y[++num]&#x3D;sa[i]-k; &#x2F;&#x2F;排名为i的数 在数组中是否在第k位以后 &#x2F;&#x2F;如果满足(sa[i]&gt;k) 那么它可以作为别人的第二关键字，就把它的第一关键字的位置添加进y就行了 &#x2F;&#x2F;所以i枚举的是第二关键字的排名，第二关键字靠前的先入队 for (rint i&#x3D;1;i&lt;&#x3D;m;++i) c[i]&#x3D;0; &#x2F;&#x2F;初始化c桶 for (rint i&#x3D;1;i&lt;&#x3D;n;++i) ++c[x[i]]; &#x2F;&#x2F;因为上一次循环已经算出了这次的第一关键字 所以直接加就行了 for (rint i&#x3D;2;i&lt;&#x3D;m;++i) c[i]+&#x3D;c[i-1];&#x2F;&#x2F;第一关键字排名为1~i的数有多少个 for (rint i&#x3D;n;i&gt;&#x3D;1;--i) sa[c[x[y[i]]]--]&#x3D;y[i],y[i]&#x3D;0; &#x2F;&#x2F;因为y的顺序是按照第二关键字的顺序来排的 &#x2F;&#x2F;第二关键字靠后的，在同一个第一关键字桶中排名越靠后 &#x2F;&#x2F;基数排序 swap(x,y); &#x2F;&#x2F;这里不用想太多，因为要生成新的x时要用到旧的，就把旧的复制下来，没别的意思 x[sa[1]]&#x3D;1;num&#x3D;1; for (rint i&#x3D;2;i&lt;&#x3D;n;++i) x[sa[i]]&#x3D;(y[sa[i]]&#x3D;&#x3D;y[sa[i-1]] &amp;&amp; y[sa[i]+k]&#x3D;&#x3D;y[sa[i-1]+k]) ? num : ++num; &#x2F;&#x2F;因为sa[i]已经排好序了，所以可以按排名枚举，生成下一次的第一关键字 if (num&#x3D;&#x3D;n) break; m&#x3D;num; &#x2F;&#x2F;这里就不用那个122了，因为都有新的编号了 &#125; for (rint i&#x3D;1;i&lt;&#x3D;n;++i) putout(sa[i]),putchar(&#39; &#39;);&#125;inv get_height()&#123; rint k&#x3D;0; for (rint i&#x3D;1;i&lt;&#x3D;n;++i) rk[sa[i]]&#x3D;i; for (rint i&#x3D;1;i&lt;&#x3D;n;++i) &#123; if (rk[i]&#x3D;&#x3D;1) continue;&#x2F;&#x2F;第一名height为0 if (k) --k;&#x2F;&#x2F;h[i]&gt;&#x3D;h[i-1]+1; rint j&#x3D;sa[rk[i]-1]; while (j+k&lt;&#x3D;n &amp;&amp; i+k&lt;&#x3D;n &amp;&amp; s[i+k]&#x3D;&#x3D;s[j+k]) ++k; height[rk[i]]&#x3D;k;&#x2F;&#x2F;h[i]&#x3D;height[rk[i]]; &#125; putchar(10);for (rint i&#x3D;1;i&lt;&#x3D;n;++i) putout(height[i]),putchar(&#39; &#39;);&#125;int main()&#123; gets(s+1); n&#x3D;strlen(s+1);m&#x3D;122; &#x2F;&#x2F;因为这个题不读入n和m所以要自己设 &#x2F;&#x2F;n表示原字符串长度，m表示字符个数，ascll(&#39;z&#39;)&#x3D;122 &#x2F;&#x2F;我们第一次读入字符直接不用转化，按原来的ascll码来就可以了 &#x2F;&#x2F;因为转化数字和大小写字母还得分类讨论，怪麻烦的 get_SA(); &#x2F;&#x2F;get_height();&#125; &lt;img src=&quot;https://img-blog.csdn.net/20151129213701642&quot; width=256 height=256 /&gt;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"字符串","slug":"算法/字符串","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"单源最短路算法——Dijkstra","slug":"Dijkstra","date":"2019-03-25T09:20:00.000Z","updated":"2019-11-28T15:33:00.000Z","comments":true,"path":"Dijkstra/","link":"","permalink":"http://yoursite.com/Dijkstra/","excerpt":"$ \\text{Dijkstra} ​$ 算法用于解决单源最短路问题的算法之一，是图论较为基础的部分。","text":"$ \\text{Dijkstra} ​$ 算法用于解决单源最短路问题的算法之一，是图论较为基础的部分。 提示：本文为作者早期时所写，部分内容可能描述不清，过于复杂，包含错误等。 前言$ \\text{Dijkstra} ​$ 算法用于解决单源最短路问题的算法之一，是图论较为基础的部分。 实现方法：1.定义ans[100000]，ans[i]代表到达i点的最小花费 2.定义bool数组visit，代表是否来过这里 2.ans[起点]=0,其余的赋值为inf 3.定义一个curr变量，visit[current]=1（访问过），代表现在的位置，初始值为起点。 4.列举所有与curr相联通的的点，将这些点(i)的ans值更新： $ ans[i]=min(ans[i],ans[curr]+ ​$ 到这些点需要的花费 $)​$ 5. 列举所有访问过的的点，找到ans值最小的点，赋值给curr，visit[current]=1（访问过） 6 所有点都访问过（visit[i]都==1），程序结束。此时，ans[i]代表从起点到i的最短路径 伪代码123456789101112131415161718192021bool vis[1000000];//是否访问过int ans[1000000];int curr=起点;memset(ans,0x7fffffff,sizeof(ans))while(vis[curr]==0)&#123; vis[curr]=1; for(int i;列举所有curr连通的点） &#123; ans[i]=min(ans[i],ans[curr]+k)//k代表从curr点到i点的最短路 &#125; int minn=2147483647; for(int i=1;i&lt;=m;i++)//列举所有点 &#123; if(vis[i]==1&amp;&amp;ans[i]&lt;minn)//访问过且小 &#123; minn=ans[i];//更新最小值 curr=i;//更新下一个点 &#125; &#125;&#125; 存图方式链式前向星以下是关于链式前向星的介绍 ，会的可以跳过： 边的存储这种存图方式只需要开一个数组存储每个点引出的第一条边，然后存储每个点作为起点的每条边，这样就可以做到不重不漏。 在链式前向星存图中，我们需要定义一个结构体： 12345struct EDGE &#123; int next; int to;&#125;edge[1000000]; 和一个数组： 1int head[1000000]; 和一个变量： 1int cnt=0;//指针 你会发现竟然没存起点！！其实起点是用$head$存的 举例： 如图：这样的一个有向图，输入是： 12341 21 31 42 3 逐步分析：1.输入1 2，代表1连向2。123cnt++;//作为结构体下标，没有意义head[1]=cnt;//结点1的第一个儿子存在了edge[cnt]里面edge[cnt].to=2;结点1的儿子是2 此时：$cnt=1$ $edge$ $cnt=1$ $cnt=2$ $ cnt=3$ $cnt=4$ $to $ $2$ $0$ $ 0$ $0$ $next$ $ 0 $ $0 $ $0$ $0$ $head $ 下标$=1 $ 下标$=2$ 下标$=3 $ 下标$=4 $ 值 $1 $ $ 0 $ $ 0 $ $ 0 $ 2.输入1 3，代表1连向3。12345678910cnt++;head[1]=cnt;edge[cnt].to=3;结点1的儿子是3//这时,3成为了结点1的儿子，不过2被挤了下去...//所以要引入结构体中next元素，记录：3还有个兄弟（next）是2//所以代码要换成：cnt++;edge[cnt].to=3;//结点1连向3edge[cnt].next=head[1];//3的兄弟是2head[1]=cnt;//更新head 此时：$cnt=2$ $edge$ $cnt=1$ $cnt=2$ $ cnt=3$ $cnt=4$ $to $ $2$ $3$ $ 0$ $0$ $next$ $ 0 $ $1 $ $0$ $0$ $head $ 下标$=1 $ 下标$=2$ 下标$=3 $ 下标$=4 $ 值 $2 $ $ 0 $ $ 0 $ $ 0 $ 3.输入1 4，代表1连向4。此时：$cnt=3$ $edge$ $cnt=1$ $cnt=2$ $ cnt=3$ $cnt=4$ $to $ $2$ $3$ $ 4$ $0$ $next$ $ 0 $ $1 $ $2$ $0$ $head $ 下标$=1 $ 下标$=2$ 下标$=3 $ 下标$=4 $ 值 $3 $ $ 0 $ $ 0 $ $ 0 $ 4.输入2 3，代表2连向3。此时：$cnt=4$ $edge$ $cnt=1$ $cnt=2$ $ cnt=3$ $cnt=4$ $to $ $2$ $3$ $ 4$ $3$ $next$ $ 0 $ $1 $ $2$ $0$ $head $ 下标$=1 $ 下标$=2$ 下标$=3 $ 下标$=4 $ 值 $3 $ $ 4 $ $ 0 $ $ 0 $ 注意：$edge[cnt].next$ 和$head[1]$存贮的都是结构体下标（即$cnt$的值）若要访问指向的边的编号，分别用$edge[edge[cnt].next].to$，$edge[head[1]].to$若需要记录权值，在结构体中加入一个元素即可代码：(带权值） 123456789101112131415161718192021222324252627#include&lt;iostream&gt;using namespace std;struct edge &#123; int next; int to; int wei;&#125;edge[MAXM];int head[MAXN];//head[i]为i点的第一条边int cnt=0;void addedge(int u,int v,int w) //起点，终点，权值 &#123; edge[++cnt].next=head[u];//更新cnt edge[cnt].to=v; edge[cnt].w=w; head[u]=cnt;&#125;int main()&#123; int n; for(int i=1;i&lt;=n;i++) &#123; int a,b,wei; addedge(a,b,wei); //如果是无向图，还要addedge(b,a,wei); &#125;&#125; 注意： 这里的next指的是遍历时的下一条边，head指的是遍历时的第一条边，而存边时相当于反过来操作，所以next记录上一条边，而head记录最后一条边。 边的遍历在遍历以x为起点的所有边时，只需要这样就行 for(int i=head[x];i!=0;i=edge[i].next)这个循环的结束条件是i等于0，因为最后一条边，也就是存边时第一条边，在把head值存进next时，head还没有更新过，也就是0。所以当next返回0时，就说明这些边遍历完毕了。 优势与特点既可以存图，也可以存树，比起邻接矩阵，链式前向星的空间复杂度是O（n），大大节省了存储空间，因为按边存储省掉了很多两点无边的空间。并且在遍历的时候，那些与起点无边相连的点也不需要进行处理，可以说时间和空间都占优势，这就是被OIer们广泛使用的原因。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;using namespace std;int head[100000],cnt;long long ans[1000000];bool vis[1000000];int m,n,s;struct edge&#123; int to; int nextt; int wei;&#125;edge[1000000];void addedge(int x,int y,int z)&#123; edge[++cnt].to=y; edge[cnt].wei=z; edge[cnt].nextt=head[x]; head[x]=cnt;&#125;int main()&#123; cin&gt;&gt;m&gt;&gt;n&gt;&gt;s; for(int i=1;i&lt;=n;i++) &#123; ans[i]=2147483647; &#125; ans[s]=0; for(int i=1;i&lt;=n;i++) &#123; int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; addedge(a,b,c); &#125; int pos=s; while(vis[pos]==0) &#123; long long minn=2147483647; vis[pos]=1; for(int i=head[pos];i!=0;i=edge[i].nextt) &#123; if(!vis[edge[i].to]&amp;&amp;ans[edge[i].to]&gt;ans[pos]+edge[i].wei) &#123; ans[edge[i].to]=ans[pos]+edge[i].wei; &#125; &#125; for(int i=1;i&lt;=m;i++) &#123; if(ans[i]&lt;minn&amp;&amp;vis[i]==0) &#123; minn=ans[i]; pos=i; &#125; &#125; &#125; for(int i=1;i&lt;=m;i++) &#123; cout&lt;&lt;ans[i]&lt;&lt;' '; &#125;&#125; 以上是Dijkstra的基础介绍，上面的这份代码是不加优化的Dijkstra，能通过P3371单源最短路径（弱化版）不过在这道题中会TLE。 优化在上面第五步中：5. 列举所有访问过的的点，找到ans值最小的点 这一步由于每次都要遍历一遍所有点，复杂度为$O(n)$ 不过可以用堆（STL：优先队列）进行优化，复杂度为$O(logn)$ 简单介绍优先队列一种数据结构，支持找出数列中最大值，弹出最大值 重载运算符后还可以维护最小值 代码： 头文件 1#include&lt;queue&gt; 定义 1priority_queue&lt;int&gt; q; 加入 1q.push(a); 弹出最大值 1q.pop() 查询最大值 1q.top() 详细的可看P3378 【模板】堆 代码对以上代码加入堆优化： 由于每个点有两个值需要存储（$ans$值，点的编号）,所以要用结构体 由于要找最小的点，所以用优先队列时需要重载运算符： 123456789struct node&#123; int ans;//ans值 int id;//点编号 bool operator &lt;(const node &amp;x)const//重载运算符 &#123; return x.ans&lt;ans; &#125;&#125;; 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;int head[100000],cnt;long long ans[1000000];bool vis[1000000];int m,n,s;struct edge&#123; int to; int nextt; int wei;&#125;edge[1000000];struct priority&#123; int ans; int id; bool operator &lt;(const priority &amp;x)const &#123; return x.ans&lt;ans; &#125;&#125;;void addedge(int x,int y,int z)&#123; edge[++cnt].to=y; edge[cnt].wei=z; edge[cnt].nextt=head[x]; head[x]=cnt;&#125;priority_queue&lt;priority&gt; q;int main()&#123; cin&gt;&gt;m&gt;&gt;n&gt;&gt;s; for(int i=1;i&lt;=n;i++) &#123; ans[i]=2147483647; &#125; ans[s]=0; for(int i=1;i&lt;=n;i++) &#123; int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; addedge(a,b,c); &#125; int u; q.push((priority)&#123;0,s&#125;); while(!q.empty()) &#123; priority temp=q.top(); q.pop(); u=temp.id; if(!vis[u]) &#123; vis[u]=1; for(int i=head[u];i;i=edge[i].nextt) &#123; int v=edge[i].to; if(ans[v]&gt;ans[u]+edge[i].wei) &#123; ans[v]=ans[u]+edge[i].wei; if(!vis[v]) &#123; q.push((priority)&#123;ans[v],v&#125;); &#125; &#125; &#125; &#125; &#125; for(int i=1;i&lt;=m;i++) &#123; cout&lt;&lt;ans[i]&lt;&lt;' '; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"最短路","slug":"算法/最短路","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E6%9C%80%E7%9F%AD%E8%B7%AF/"}],"tags":[{"name":"最短路","slug":"最短路","permalink":"http://yoursite.com/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"}]},{"title":"Hexo博客搭建","slug":"Hexo博客搭建记录","date":"2019-03-23T07:55:00.000Z","updated":"2020-02-03T07:59:23.000Z","comments":true,"path":"Hexo博客搭建记录/","link":"","permalink":"http://yoursite.com/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/","excerpt":"","text":"搭建记录修改博客内容首次使用1.打开安装包安装Git，Node 2.下载hexo 12npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.orgnpm install -g hexo 3.安装hexo 1hexo init 4.配置github 12git config --global user.email &quot;zfMMG9000@163.com&quot;git config --global user.name &quot;2018haha&quot; 5.绑定github密匙 1ssh-keygen 并把路径中id_rsa.pub用记事本打开，复制到github的key上 更改博客设置有两个位置： hexo设置\\_config.yml next主题设置\\themes\\hexo-theme-next-6.7.0\\_config.yml 详细请百度 写文章hexo n &quot;文章名&quot;在\\source\\_posts中找到文件并编辑 开头几个参数： 1234567---title: categories: 日志mathjax: truetags: [记录,笔记,日志]keywords: [1,2]--- 详细可以参见 预览，发布预览： 1hexo s 发布： 123hexo cleanhexo ghexo d","categories":[{"name":"教程","slug":"教程","permalink":"http://yoursite.com/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"教程","slug":"教程","permalink":"http://yoursite.com/tags/%E6%95%99%E7%A8%8B/"},{"name":"博客搭建","slug":"博客搭建","permalink":"http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"基础动态规划汇总","slug":"基础动态规划汇总","date":"2018-12-08T00:46:27.000Z","updated":"2020-02-03T08:08:03.000Z","comments":true,"path":"基础动态规划汇总/","link":"","permalink":"http://yoursite.com/%E5%9F%BA%E7%A1%80%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%B1%87%E6%80%BB/","excerpt":"动态规划是OI种经典的算法之一，用途较为广泛。","text":"动态规划是OI种经典的算法之一，用途较为广泛。 前言动态规划是OI种经典的算法之一，用途较为广泛。 背包背包问题特点：每种物品都有一个价值val和体积wei. 你现在有一个背包容积为V,你想用一些物品装背包使得物品总价值最大. 0-1背包实现方法状态转移方程：$dp[i][j]=max(dp[i-1][j],dp[i-1][j-wei[i]]+val[i]);$$i$代表一共选几个物品，$j$代表背包剩余容量，$wei[i]$代表i占容量，$val[i]$代表i的价值 由于$dp[i][ ]$只与$dp[i-1][ ]$有关，可以用滚动数组压掉第一维 或者：只开一个数组，直接在原数组上修改 由于$dp[i][j]$只与$dp[i-1]m$有关，如果仍然从前向后枚举j，会更改前面的值，对后续决策产生影响，所以我们需要从后往前枚举$j$，更新$j$的值 代码：1234567for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#x2F;&#x2F;枚举装几个物品&#123; for(int j&#x3D;v;j&gt;&#x3D;wei[i];j--)&#x2F;&#x2F;枚举体积 &#123; dp[j]&#x3D;max(dp[j],dp[j-wei[i]]+w[i]); &#125;&#125; 典型题：P1048 采药 1234567891011121314151617181920212223242526#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;int wei[105], val[105];int dp[1005];int main()&#123; int t,m,res&#x3D;-1; scanf(&quot;%d%d&quot;,&amp;t,&amp;m); for(int i&#x3D;1;i&lt;&#x3D;m;i++) &#123; scanf(&quot;%d%d&quot;,&amp;wei[i],&amp;val[i]); &#125; for(int i&#x3D;1;i&lt;&#x3D;m;i++) &#123; for(int j&#x3D;t;j&gt;&#x3D;0;j--) &#123; if(j&gt;&#x3D;wei[i]) &#123; dp[j]&#x3D;max(dp[j-wei[i]]+val[i], dp[j]); &#125; &#125; &#125; printf(&quot;%d&quot;,dp[t]); return 0;&#125; 完全背包特点：此类背包问题与01背包不同的是：我们的每种物品有无限多个,可重复选取。 实现方法01背包中，为了防止更新时对后续更新产生影响，$t$要从后往前枚举。而完全背包只需改为从前往后即可。 代码：1234567for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#x2F;&#x2F;枚举装几个物品&#123; for(int j&#x3D;wei[i];j&lt;&#x3D;v;j++)&#x2F;&#x2F;枚举体积 &#123; dp[j]&#x3D;max(dp[j],dp[j-wei[i]]+w[i]); &#125;&#125; 典型题：P1616 疯狂的采药 1234567891011121314151617181920212223#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;long long f[1000001],v[1000001],h[1000001];long long max(long long a,long long b)&#123; if(a&gt;b) return a; else return b;&#125;int main()&#123; long long i,j,m,n; scanf(&quot;%ld %ld&quot;,&amp;m,&amp;n); for(i&#x3D;1;i&lt;&#x3D;n;i++) scanf(&quot;%ld %ld&quot;,&amp;h[i],&amp;v[i]); for(i&#x3D;1;i&lt;&#x3D;n;i++) for(j&#x3D;h[i];j&lt;&#x3D;m;j++) f[j]&#x3D;max(f[j],f[j-h[i]]+v[i]); printf(&quot;%ld\\n&quot;,f[m]); return 0;&#125; 多重背包线性动归线性动归特点： 只在一个数列上的dp。 实现方法用$dp[i]$代表到$i$为止最优策略。 典型题最长不下降子序列：给定一个数列，求出最长不下降子序列的长度。 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;using namespace std;int a[100000];int dp[1000000];int main()&#123; int n; cin&gt;&gt;n; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; cin&gt;&gt;a[i]; dp[i]&#x3D;1; &#125; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; for(int j&#x3D;1;j&lt;i;j++) &#123; if(a[i]&gt;&#x3D;a[j])&#x2F;&#x2F;可以更新 &#123; dp[i]&#x3D;max(dp[i],dp[j]+1);&#x2F;&#x2F;取所有可以更新的情况中，更新后的最优决策（即最大值） &#125; &#125; &#125; int ans&#x3D;0; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; ans&#x3D;max(ans,dp[i]); &#125; cout&lt;&lt;ans; return 0; &#125; 变形：P1091 合唱队形 1234567891011121314151617181920212223#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;int n,a[105],f[2][105],ans;int main()&#123; cin&gt;&gt;n; for(int i&#x3D;1;i&lt;&#x3D;n;i++) cin&gt;&gt;a[i]; for(int i&#x3D;1;i&lt;&#x3D;n;i++) for(int j&#x3D;0;j&lt;i;j++) if(a[i]&gt;a[j]) f[0][i]&#x3D;max(f[0][i],f[0][j]+1); a[n+1]&#x3D;0; for(int i&#x3D;n;i;i--) for(int j&#x3D;n+1;j&gt;i;j--) if(a[i]&gt;a[j]) f[1][i]&#x3D;max(f[1][i],f[1][j]+1); for(int i&#x3D;1;i&lt;&#x3D;n;i++) ans&#x3D;max(f[0][i]+f[1][i]-1,ans); printf(&quot;%d\\n&quot;,n-ans); return 0;&#125; 导弹拦截 友好城市 区间动归区间动归特点： 实现方法用$dp[i][j]$代表区间$[i,j]$的最大值；或者表示区间$[i,i+j]$的最大值。 典型题：P1880 [NOI1995]石子合并 树形动归树形动归特点： 在一棵树上的动态规划 实现方法类比P1216 [USACO1.5]数字三角形 Number Triangles，这题的思路是从三角形底部一层层合并到最顶部，便可得到答案 数字三角形代码： 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;using namespace std;int a[10000][10000];int main()&#123; int n; cin&gt;&gt;n; int num&#x3D;0; for(int i&#x3D;0;i&lt;n;i++) &#123; for(int j&#x3D;0;j&lt;&#x3D;i;j++) &#123; cin&gt;&gt;a[i][j]; &#125; &#125; int j&#x3D;0; for(int i&#x3D;n-2;i&gt;&#x3D;0;i--) &#123; for(int j&#x3D;0;j&lt;&#x3D;i;j++) &#123; if(a[i+1][j]&gt;&#x3D;a[i+1][j+1]) &#123; a[i][j]+&#x3D;a[i+1][j]; &#125; else &#123; a[i][j]+&#x3D;a[i+1][j+1]; &#125; &#125; &#125; cout&lt;&lt;a[0][0];&#125; 树形动归与这个类似，应该从树的底部开始，向上处理 程序实现如何存树：利用链式前向星把树存成无向图代码： 1234567int head[1666],pre[3666],to[3666],cnt&#x3D;0;void add_edge(int a,int b)&#123; to[++cnt]&#x3D;b; pre[cnt]&#x3D;head[a]; head[a]&#x3D;cnt;&#125; 详细解释：链式前向星 如何从底部向上动归：递归实现代码： 123456789101112void treedp(int pos)&#x2F;&#x2F;pos是现在的位置 &#123; vis[pos]&#x3D;1;&#x2F;&#x2F;标记已访问过 for(int i&#x3D;head[pos];i!&#x3D;-1;i&#x3D;pre[i])&#x2F;&#x2F;链式前向星的遍历 &#123; if(!vis[to[i]])&#x2F;&#x2F;第一次到达（防止在返回过程中再次递归下去，形成死循环） &#123; treedp(to[i]);&#x2F;&#x2F;递归到下一层 ···&#x2F;&#x2F;状态转移方程 &#125; &#125;&#125; 典型题 P1352 没有上司的舞会 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;int f[5][6000];int n,b,a,root;int cun[12000],zhi[12000],geshu[12000];bool vis[100000];void dp(int x)&#123; vis[x]&#x3D;1; for(int i&#x3D;zhi[x];i;i&#x3D;cun[i]) &#123; if(vis[i]&#x3D;&#x3D;0) &#123; dp(i); f[1][x]&#x3D;max(max(f[1][x],f[0][i]+f[1][x]),f[0][i]); f[0][x]&#x3D;max(max(f[0][x],f[1][i]+f[0][x]),max(f[1][i],f[0][i])); &#125; &#125;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i&#x3D;1;i&lt;&#x3D;n;i++) scanf(&quot;%d&quot;,&amp;f[1][i]); for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); geshu[a]++; cun[a]&#x3D;zhi[b]; zhi[b]&#x3D;a; &#125; for(int i&#x3D;1;i&lt;&#x3D;n;i++) if(geshu[i]&#x3D;&#x3D;0) &#123; root&#x3D;i; break; &#125; dp(root); printf(&quot;%d&quot;,max(f[1][root],f[0][root])); return 0;&#125; P2016 战略游戏此题技巧：用$dp[0][i]$代表i这点不放的最优值，$dp[1][i]$代表i这点放的最优值 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int n,a,b,c,cnt,head[1666],f[1666][2];struct edge&#123; int to; int next;&#125;edge[3333];void add_edge(int x,int y)&#123; ++cnt; edge[cnt].to&#x3D;y; edge[cnt].next&#x3D;head[x]; head[x]&#x3D;cnt;&#125;void tree(int x,int from)&#123; f[x][1]&#x3D;1; f[x][0]&#x3D;0; if(head[x]&#x3D;&#x3D;0) &#123; f[x][0]&#x3D;10000000; &#125; for(int i&#x3D;head[x];i;i&#x3D;edge[i].next) &#123; if(edge[i].to!&#x3D;from) &#123; tree(edge[i].to,x); f[x][1]+&#x3D;min(f[edge[i].to][1],f[edge[i].to][0]); f[x][0]+&#x3D;f[edge[i].to][1]; &#125; &#125; &#125;int main()&#123; cin&gt;&gt;n; for(int i&#x3D;1;i&lt;&#x3D;n;i++) &#123; cin&gt;&gt;a&gt;&gt;b; a++; for(int j&#x3D;1;j&lt;&#x3D;b;j++) &#123; cin&gt;&gt;c; c++; add_edge(a,c); add_edge(c,a); &#125; &#125; tree(1,0); int ans&#x3D;min(f[1][1],f[1][0]); printf(&quot;%d&quot;,ans);&#125; 状压动归状压动归特点：一般在矩阵上进行动归，不过由于情况过多，不可以开inf维数组进行解决，就需要使用状态压缩动归。在这类动态规划中，每个点的状态往往只用0或1来表示（复杂一些的可能需要用0,1,2），每一行每个点上的数字可以连成一个01串，如果我们把它看成一个二进制数，即可用一个十进制数来表示复杂的状态，即状态压缩。 实现方法 用十进制数表示一个状态，对每一个合法的状态（十进制数字）进行处理（通过位运算） 由于限制了摆放k个，所以需要统计当前状态摆放了几个（二进制中1的个数） 先进行预处理，将可能方案（用一个十进制数表示）存入数组，将这个方案中1的个数存入数组，顺便简要删除一些不可行的方案，降低复杂度，然后在剩余方案上进行动归。 典型题 P1896 [SCOI2005]互不侵犯 题意分析 一个$nn$的矩阵，有多少种方式，不重叠地摆放k个$33$的方块，要求输出方案数。 处理方块中心点位置，看中心点放在某个位置是否合法（它的上下左…八个方向有没有其他方块） 根据两个方块中心点一定不相邻，删掉一些方案预处理123456789101112131415161718192021void prepare()&#x2F;&#x2F;预处理可用情况 &#123; int k; s0&#x3D;0; ans&#x3D;0; memset(f,0,sizeof(f)); for(int i&#x3D;0;i&lt;(1&lt;&lt;n);i++)&#x2F;&#x2F;十进制数从0枚举到 1&lt;&lt;n，即可把所有状态处理全 &#123; if(i&amp;(i&lt;&lt;1))continue;&#x2F;&#x2F;如果这个方案中有两个相邻，一定不满足条件，略过 k&#x3D;0;&#x2F;&#x2F;计数器 for(int j&#x3D;0;j&lt;n;j++)&#x2F;&#x2F;------ &#123;&#x2F;&#x2F; 统 if(i&amp;(1&lt;&lt;j))&#x2F;&#x2F; 计 &#123;&#x2F;&#x2F; 1的 k++;&#x2F;&#x2F; 个 &#125;&#x2F;&#x2F; 数 &#125;&#x2F;&#x2F; ------ s[++s0]&#x3D;i; num[s0]&#x3D;k; &#125;&#125; 斜率优化","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"算法/动态规划","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"背包","slug":"背包","permalink":"http://yoursite.com/tags/%E8%83%8C%E5%8C%85/"},{"name":"树形动态规划","slug":"树形动态规划","permalink":"http://yoursite.com/tags/%E6%A0%91%E5%BD%A2%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"区间动态规划","slug":"区间动态规划","permalink":"http://yoursite.com/tags/%E5%8C%BA%E9%97%B4%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"状态压缩动态规划","slug":"状态压缩动态规划","permalink":"http://yoursite.com/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"各种Tarjan算法详解","slug":"tarjan","date":"1970-01-01T00:00:00.000Z","updated":"2020-02-03T08:07:28.000Z","comments":true,"path":"tarjan/","link":"","permalink":"http://yoursite.com/tarjan/","excerpt":"$\\text{Tarjan}$算法是图论中实用/常用的算法之一，能解决强连通分量，双连通分量，割点和桥，求$\\text{LCA}$等问题，本文将对以上用途一一介绍","text":"$\\text{Tarjan}$算法是图论中实用/常用的算法之一，能解决强连通分量，双连通分量，割点和桥，求$\\text{LCA}$等问题，本文将对以上用途一一介绍 注意：本文对强连通分量的介绍已经完成，而其他部分尚未完成。 前言$\\text{Tarjan}$算法是图论中实用/常用的算法之一，能解决强连通分量，双连通分量，割点和桥，求$\\text{LCA}$等问题，本文将对以上用途一一介绍 强连通分量定义一个强连通分量是指一个有向图中的最大强联通子图。 强联通子图：任意两点可以互相到达的有向图。 如下图，就有3个强联通分量：{1,2,3}，{4}，{5}。 做法（一）如何找强联通分量。进行$\\text{Dfs}$遍历，在$\\text{Dfs}$树上操作。如果在$\\text{Dfs}$时发现遍历到了一个访问过的的点（如下图的$1$号节点），那么说明从这个点出发，可以回到自己，即这条路径构成了一个环，环上的点是强联通的。 但根据强联通分量的定义，这只能说明他们在同一个强联通分量内，不能保证他们就是一个强连通分量，还要接着处理。 （二）找完整的强联通分量。考虑什么情况下才能保证上述的环构成一个强连通分量。上述的环都是由一个节点$S$和它在Dfs树中的子树构成的，那么只要保证子树内没有节点连向$S$的祖先，即可保证这是一个强连通分量。 原因比较好理解：若该点子树中有点连向了他的祖先，那么他的祖先便属于这个强连通分量，显然可以构成一个更大的强联通图。 可以参见下图辅助理解。图中$2$号节点的子树中，$4$号节点连向了$2$的父亲——$1$号点，那么环{2,3,4}就属于强联通分量{1,2,3,4}，而不能单独构成强联通分量。 （三）找准确的强连通分量。以上的算法貌似还有一个问题：我们能通过第二条（二）找完整的强联通分量。找到强联通分量所在的子树，但是我们并不知道子树中哪些节点属于，哪些节点不属于。 解决办法： 就像$\\text{Dfs}$找环一样，用一个栈记录即可。 $u$之后的所有点在u被回溯到时$u$和栈中所有在它之后的点都构成强连通分量。具体见代码实现。 然后各位神仙们就可以脑补代码实现了，本次就到这里，感谢阅读！ 程序实现定义一些数组：1234int dfn[N];//表示在Dfs时是第几个被搜到的int low[N];//表示这个点的子树节点及他们连向的点的最小$dfn$值。为了实现上面的第二步int sta[N&#125;;//int vis[N];//记录点是否在栈中 实现过程1.最外层框架是对树的$\\text{Dfs}$。 2.每遍历到一个节点$u$: (1)初始化dfn[u]=low[u]=++cnt(cnt是计数器）。 根据数组含义可以理解，在处理前，子树中dfn最小的就是dfn[u],所以把low[u]初始化为dfn[u] (2)把$u$入栈，标记vis[u]=1 (3)接着遍历它所能到达的节点$v$，判断$v$是否访问过（方法：看dfn值是否等于0）。 a.未访问过：接着递归Dfs(v)，并用$v$的$low$值更新$u$:low[u]=min(low[u],low[v])因为子树中的节点可能连向$u$的祖先节点，所以按照$dfn$的含义更新它。 b.访问过： 如果$v$在栈中，说明$u$,$v$在一个强连通分量，那么更新low[u]:low[u]=min(low[u],low[v]) 如果不在栈中，说明$u$不能到达$v$,二者没有关联，不进行处理。 (4) 处理完$u$的子树后： 此时dfn[u]和low[u]都已经确定好。若dfn[u]==low[u]，根据数组含义，表明$u$是子树中所有点能到达的dfn最小的点，这也就满足了上文中的（二）找完整的强联通分量。（还记得吗），即满足了：u点与它的子孙节点构成了一个最大的强连通图,即强连通分量。 这时我们只需把栈中$u$后面的点和$u$一并弹出（别忘更新$\\text{vis}$），弹出的这些点就是一个强连通分量了。 代码Tarjan建议参照上文对比阅读代码。 1234567891011121314151617181920212223242526272829303132int dfn[N],low[N],t;//数组定义同上面的解释int sta[N],top;int vis[N];int col[N],tot;//用于标记答案，col相同的点在一个强连通分量中void Tarjan(int u)&#123; low[u]=dfn[u]=++t; sta[++top]=u; vis[u]=1; for(int i=head[u];i;i=next[i]) &#123; int v=to[i]; if(!dfn[v]) &#123; Tarjan(v); low[u]=min(low[u],low[v]); &#125; else if(vis[v]) low[u]=min(low[u],dfn[v]); &#125; if(dfn[u]==low[u]) &#123; int v; tot++; do&#123; v=sta[top]; top--; vis[v]=0; col[v]=tot; &#125;while(u!=v); &#125;&#125; 主函数注意：由于图可能不连通，从一个点开始Dfs可能不会遍历所有点，所以要这样写： 12for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#x2F;&#x2F;遍历所有点 if(!dfn[i]) Tarjan(i); 时间复杂度每个点只被入栈，出栈一次，时间复杂度为$O(n)$ 双连通分量、割点和桥概念双联通分量与强联通分量类似，是一个无向图中的最大双连通子图。它分为两类：点双连通分量，边双连通分量（简称点双，边双）。 点双连通分量、割点定义点双连通分量：是指一个无向图中的最大点双连通子图。 点双连通图：一个去掉任意一节点都不会改变它的连通性的无向图。 例如，下面这个图中，{1,2,3,4,5}就是一个点双连通分量 割点：若一个图中，有一点$A$,删掉该点会使图不连通，那么称点$A$为割点。 性质根据定义可以看出，任意两点间都有至少两条点不重复的路径。 点双连通分量之间以割点连接，且两个点双连通分量之间有且只有一个割点。 割点求法首先类似于强连通分量，Tarjan求割点也是在Dfs基础上运行的，所以先获得一个Dfs树。 对于根节点：比较好判断。统计一下根节点的子树个数，若 子树个数$\\geq 2$，那么割掉根节点，两个子树便不再联通，即可说明根节点是割点。 对于非根节点：根据割点的定义和Dfs树，可以知道，割点被割掉后，图一定是被分成了割点的子树A和除子树节点外所有的点B两部分。简单点说，割掉割点相当于把子树剪掉了。经过分析，只要割掉一个点后，A和B不连通，即可保证该点是割点。也就是说，当A中的所有点，都只是通过这个点连接着B，而没有其它边连接A和B，即可说明 参考资料https://www.cnblogs.com/stxy-ferryman/p/7779347.html https://www.cnblogs.com/ljk123-de-bo-ke/p/10888905.html https://www.luogu.org/blog/shiboao/post-ti-gao-ge-dian","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"tarjan","slug":"算法/tarjan","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/tarjan/"}],"tags":[{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"tarjan","slug":"tarjan","permalink":"http://yoursite.com/tags/tarjan/"},{"name":"强连通分量","slug":"强连通分量","permalink":"http://yoursite.com/tags/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"},{"name":"双连通分量","slug":"双连通分量","permalink":"http://yoursite.com/tags/%E5%8F%8C%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"},{"name":"割点","slug":"割点","permalink":"http://yoursite.com/tags/%E5%89%B2%E7%82%B9/"},{"name":"桥","slug":"桥","permalink":"http://yoursite.com/tags/%E6%A1%A5/"}]},{"title":"省选前知识点","slug":"省选前知识点","date":"1970-01-01T00:00:00.000Z","updated":"2020-02-03T08:08:35.000Z","comments":true,"path":"省选前知识点/","link":"","permalink":"http://yoursite.com/%E7%9C%81%E9%80%89%E5%89%8D%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"本文列出了省选前的所有常见OI算法，按照难度排序，供参考。","text":"本文列出了省选前的所有常见OI算法，按照难度排序，供参考。 前言本文列出了省选前的所有常见OI算法，按照难度排序，供参考。 数据结构 数组 链表 双向链表 队列 单调队列 栈 单调栈 堆 并查集 带权并查集 树状数组 线段树 线段树合并 线段树分治 平衡树 分块 莫队 树上莫队 块状链表 树套树 可并堆 KDTree 可持久化线段树 主席树 01Trie 字符串 KMP Trie树 manacher AC自动机 后缀数组 后缀自动机 图论 最小生成树 最短路 k短路 次短路 拓扑排序 网络流 Tarjan 树 LCA 树链剖分 点分治 边分治 LCT 虚树 数学 欧几里得 扩展欧几里得 中国剩余定理 扩展中国剩余定理 欧拉定理 欧拉函数 lucas定理 矩阵乘法 乘法逆元 概率期望 博弈论 *拉格朗日乘子法 \\10. 中国剩余定理 \\11. 线性规划与网络流 \\12. 单纯型线性规划 \\13. 辛普森积分 \\14. 模线性方程组 \\15. 容斥原理与莫比乌斯反演 \\16. 置换群 \\17. 快速傅里叶变换 \\18. *大步小步法（BSGS），扩展BSGS 参考资料http://hzwer.com/1234.html","categories":[{"name":"总结","slug":"总结","permalink":"http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"总结","slug":"总结","permalink":"http://yoursite.com/tags/%E6%80%BB%E7%BB%93/"},{"name":"列表","slug":"列表","permalink":"http://yoursite.com/tags/%E5%88%97%E8%A1%A8/"}]}]}